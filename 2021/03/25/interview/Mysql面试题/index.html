<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="D033aiBRFi">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://phpdi.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="MySQL 索引最左前缀原则有一个复合索引：  1INDEX(a, b, c) 哪些组合会用上索引？ 答案123456查询方式                                                   能否用上索引---------------------------------------------------+----------------------------">
<meta property="og:type" content="article">
<meta property="og:title" content="interview&#x2F;Mysql面试题">
<meta property="og:url" content="https://phpdi.github.io/2021/03/25/interview/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="phpdi">
<meta property="og:description" content="MySQL 索引最左前缀原则有一个复合索引：  1INDEX(a, b, c) 哪些组合会用上索引？ 答案123456查询方式                                                   能否用上索引---------------------------------------------------+----------------------------">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://phpdi.github.io/2021/03/25/interview/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/mysql1.jpg">
<meta property="og:image" content="https://phpdi.github.io/2021/03/25/interview/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/mysql2.png">
<meta property="og:image" content="https://phpdi.github.io/2021/03/25/interview/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/mysql3.png">
<meta property="article:published_time" content="2021-03-25T03:33:32.842Z">
<meta property="article:modified_time" content="2021-04-06T05:47:36.148Z">
<meta property="article:author" content="Chen Yu">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://phpdi.github.io/2021/03/25/interview/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/mysql1.jpg">

<link rel="canonical" href="https://phpdi.github.io/2021/03/25/interview/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>interview/Mysql面试题 | phpdi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">phpdi</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">飞向自由</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://phpdi.github.io/2021/03/25/interview/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpeg">
      <meta itemprop="name" content="Chen Yu">
      <meta itemprop="description" content="自律给我自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="phpdi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          interview/Mysql面试题
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-25 11:33:32" itemprop="dateCreated datePublished" datetime="2021-03-25T11:33:32+08:00">2021-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 13:47:36" itemprop="dateModified" datetime="2021-04-06T13:47:36+08:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index">
                    <span itemprop="name">interview</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="MySQL-索引最左前缀原则"><a href="#MySQL-索引最左前缀原则" class="headerlink" title="MySQL 索引最左前缀原则"></a>MySQL 索引最左前缀原则</h1><p>有一个复合索引： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INDEX(a, b, c)</span><br></pre></td></tr></table></figure>
<p>哪些组合会用上索引？</p>
<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查询方式                                                   能否用上索引</span><br><span class="line">---------------------------------------------------+----------------------------</span><br><span class="line">select * from users where a&#x3D;1 and b&#x3D;2       能用上a、b</span><br><span class="line">select * from users where b&#x3D;2 and a&#x3D;1       能用上a、b（有MySQL查询优化器）</span><br><span class="line">select * from users where a&#x3D;2 and c&#x3D;1       能用上 a</span><br><span class="line">select * from users where b&#x3D;2 and c&#x3D;1       不能</span><br></pre></td></tr></table></figure>

<a id="more"></a>


<h1 id="MySQL-INT和CHAR隐式类型转换需要注意什么？"><a href="#MySQL-INT和CHAR隐式类型转换需要注意什么？" class="headerlink" title="MySQL INT和CHAR隐式类型转换需要注意什么？"></a>MySQL INT和CHAR隐式类型转换需要注意什么？</h1><h2 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h2><p>主要需要记住下面两点：  </p>
<ul>
<li>当查询字段是INT类型，如果查询条件为CHAR，将查询条件转换为INT，如果是字符串前导都是数字，将截取前导数字用来比较，如果没有前导数字，则转换为0。</li>
<li>当查询字段是CHAR/VARCHAR类型，如果查询条件为INT，将查询字段为换为INT再进行比较，可能会造成全表扫描。<h2 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h2>有如下一张测试表product，id为int类型，name为varchar类型。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+----------+</span><br><span class="line">| id | name   |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | apple   |</span><br><span class="line">|  2 | banana |</span><br><span class="line">|  3 | 99cat   |</span><br><span class="line">+----+----------+</span><br></pre></td></tr></table></figure>
情况1:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询条件转化为数字1再比较</span><br><span class="line">mysql&gt; select * from product where id &#x3D; &#39;1abc23&#39;;</span><br><span class="line">+----+---------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+---------+</span><br><span class="line">|  1 | apple  |</span><br><span class="line">+----+---------+</span><br></pre></td></tr></table></figure>
情况2:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询字段全部转化成数字，id:1和id:2字段值转化为0，id:3转化成99，再比较</span><br><span class="line">mysql&gt; select * from product where name&#x3D;0;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name   |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | apple   |</span><br><span class="line">|  2 | banana |</span><br><span class="line">+----+----------+</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="MySQL-执行-select-count-from-articles，MyISAM和InnoDB哪个快？"><a href="#MySQL-执行-select-count-from-articles，MyISAM和InnoDB哪个快？" class="headerlink" title="MySQL 执行 select count(*) from articles，MyISAM和InnoDB哪个快？"></a>MySQL 执行 select count(*) from articles，MyISAM和InnoDB哪个快？</h1><h2 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h2><p>MyISAM 快，因为 MyISAM 本身就记录了数量，而InnoDB要扫描数据。</p>
<h1 id="MySQL-sql中left-join、right-join、inner-join有什么区别？"><a href="#MySQL-sql中left-join、right-join、inner-join有什么区别？" class="headerlink" title="MySQL sql中left join、right join、inner join有什么区别？"></a>MySQL sql中left join、right join、inner join有什么区别？</h1><h2 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h2><ul>
<li>left join：左联接，返回包括左表中的所有记录和右表中联结字段相等的记录</li>
<li>right join：右联接，返回包括右表中的所有记录和左表中联结字段相等的记录</li>
<li>inner join：内联接，只返回两个表中联结字段相等的行</li>
</ul>
<h1 id="MYSQL-主从服务器，如果主服务器是InnoDB引擎，从服务器是MyISAM引擎，应用中会遇到什么问题？"><a href="#MYSQL-主从服务器，如果主服务器是InnoDB引擎，从服务器是MyISAM引擎，应用中会遇到什么问题？" class="headerlink" title="MYSQL 主从服务器，如果主服务器是InnoDB引擎，从服务器是MyISAM引擎，应用中会遇到什么问题？"></a>MYSQL 主从服务器，如果主服务器是InnoDB引擎，从服务器是MyISAM引擎，应用中会遇到什么问题？</h1><h2 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h2><ul>
<li>MyISAM表锁，所以每次插入都会锁表一次。</li>
<li>MyISAM不支持事务，备份时可能会丢失数据。</li>
</ul>
<h1 id="MySQL-sql语句应该考虑哪些安全性？"><a href="#MySQL-sql语句应该考虑哪些安全性？" class="headerlink" title="MySQL sql语句应该考虑哪些安全性？"></a>MySQL sql语句应该考虑哪些安全性？</h1><h2 id="答案-5"><a href="#答案-5" class="headerlink" title="答案"></a>答案</h2><ul>
<li>防止sql注入，对特殊字符进行转义、过滤或者使用预编译sql语句绑定</li>
<li>使用最小权限原则，特别是不要使用root账户，为不同的动作或者操作建立不同的账户</li>
<li>当sql出错时，不要把数据库出错的信息暴露到客户端</li>
</ul>
<h1 id="MySQL事务的隔离级别"><a href="#MySQL事务的隔离级别" class="headerlink" title="MySQL事务的隔离级别"></a>MySQL事务的隔离级别</h1><h2 id="答案-6"><a href="#答案-6" class="headerlink" title="答案"></a>答案</h2><p>SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。<br>低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。<br>这4种隔离级别是：  </p>
<ul>
<li>Read Uncommitted：读取未提交内容</li>
<li>Read Committed：读取提交内容</li>
<li>Repeatable Read：可重读</li>
<li>Serializable：可串行化</li>
</ul>
<h2 id="答案解析-1"><a href="#答案解析-1" class="headerlink" title="答案解析"></a>答案解析</h2><p>Read Uncommitted（读取未提交内容）：在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，<br>因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。  </p>
<p>Read Committed（读取提交内容）：这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：<br>一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），<br>因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p>
<p>Repeatable Read（可重读）：这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。<br>不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，<br>另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。<br>InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p>
<p>Serializable（可串行化）：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，<br>它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争</p>
<p>这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：脏读(Drity Read)：某个事务已更新一份<br>数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。<br>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。<br>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，<br>先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p>
<p>在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：<br><img src="/2021/03/25/interview/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/mysql1.jpg" alt></p>
<h1 id="MySQL-如何高效率随机获取N条数据？"><a href="#MySQL-如何高效率随机获取N条数据？" class="headerlink" title="MySQL 如何高效率随机获取N条数据？"></a>MySQL 如何高效率随机获取N条数据？</h1><h2 id="答案-7"><a href="#答案-7" class="headerlink" title="答案"></a>答案</h2><p>假设表叫做mm_account。<br>ID连续的情况下（注意不能带where，否则结果不好）：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM &#96;mm_account&#96; AS t1 JOIN (SELECT ROUND(RAND() * (SELECT MAX(id) FROM &#96;mm_account&#96;)) AS id) AS t2</span><br><span class="line">WHERE t1.id &gt;&#x3D; t2.id</span><br><span class="line">ORDER BY t1.id ASC LIMIT 4;</span><br></pre></td></tr></table></figure>
<p>ID不连续的情况下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &#96;mm_account&#96; </span><br><span class="line">WHERE id &gt;&#x3D; (SELECT floor(RAND() * (SELECT MAX(id) FROM &#96;mm_account&#96;)))  and city&#x3D;&quot;city_91&quot; and showSex&#x3D;1</span><br><span class="line">ORDER BY id LIMIT 4;</span><br></pre></td></tr></table></figure>
<p>如果有一个字段叫id，最快的方法如下（随机获取5条）：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM mm_account </span><br><span class="line">WHERE id &gt;&#x3D; ((SELECT MAX(id) FROM mm_account)-(SELECT MIN(id) FROM mm_account)) * RAND() + (SELECT MIN(id) FROM mm_account)</span><br><span class="line">limit 5;</span><br></pre></td></tr></table></figure>
<p>如果带where语句，上面就不适合了，带where语句请看下面：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM &#96;mm_account&#96; AS t1 JOIN (SELECT ROUND(RAND() * (</span><br><span class="line">(SELECT MAX(id) FROM &#96;mm_account&#96; where id&lt;1000 )-(SELECT MIN(id) FROM &#96;mm_account&#96; where id&lt;1000 ))+(SELECT MIN(id) FROM &#96;mm_account&#96; where id&lt;1000 )) AS id) AS t2</span><br><span class="line">WHERE t1.id &gt;&#x3D; t2.id</span><br><span class="line">ORDER BY t1.id LIMIT 5;</span><br></pre></td></tr></table></figure>

<h1 id="MySQL-简述聚簇索引和非聚簇索引"><a href="#MySQL-简述聚簇索引和非聚簇索引" class="headerlink" title="MySQL 简述聚簇索引和非聚簇索引"></a>MySQL 简述聚簇索引和非聚簇索引</h1><h2 id="答案-8"><a href="#答案-8" class="headerlink" title="答案"></a>答案</h2><p>聚簇索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是索引节点，并保留一个链接指向对应数据块。<br>MyISAM的是非聚簇索引，B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。<br>InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上<br>MySQL InnoDB一定会建立聚簇索引，把实际数据行和相关的键值保存在一块，这也决定了一个表只能有一个聚簇索引<br>1.InnoDB通常根据主键值(primary key)进行聚簇<br>2.如果没有创建主键，则会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引<br>3.上面二个条件都不满足，InnoDB会自己创建一个虚拟的聚集索引</p>
<p>聚簇索引的  </p>
<ul>
<li>优点：就是提高数据访问性能。</li>
<li>缺点：维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候。</li>
</ul>
<h1 id="MySQL-有哪些索引类型"><a href="#MySQL-有哪些索引类型" class="headerlink" title="MySQL 有哪些索引类型"></a>MySQL 有哪些索引类型</h1><h2 id="答案-9"><a href="#答案-9" class="headerlink" title="答案"></a>答案</h2><ul>
<li>1.主键索引</li>
<li>2.普通索引</li>
<li>3.唯一索引</li>
<li>4.全文索引</li>
</ul>
<h1 id="MySQL-有哪些存储引擎？"><a href="#MySQL-有哪些存储引擎？" class="headerlink" title="MySQL 有哪些存储引擎？"></a>MySQL 有哪些存储引擎？</h1><h2 id="答案-10"><a href="#答案-10" class="headerlink" title="答案"></a>答案</h2><ul>
<li>1.InnoDB：默认存储引擎，使用最广泛。</li>
<li>2.MyISAM：表锁，不支持事务。</li>
<li>3.Archive：适合日志和数据采集类应用。</li>
<li>4.Memory：适合访问速度快，数据丢失也没有关系的场景。</li>
<li>5.CSV：将普通csv保存再MySQL中，主要用于数据交换。</li>
</ul>
<p>此外还有：Blackhole、Federated、Merge、NDB等存储引擎。</p>
<h1 id="MySQL-悲观锁和乐观锁是什么？"><a href="#MySQL-悲观锁和乐观锁是什么？" class="headerlink" title="MySQL 悲观锁和乐观锁是什么？"></a>MySQL 悲观锁和乐观锁是什么？</h1><h2 id="答案-11"><a href="#答案-11" class="headerlink" title="答案"></a>答案</h2><p>悲观锁和乐观锁都是为保证一致性的一种锁。  </p>
<h2 id="一、悲观锁"><a href="#一、悲观锁" class="headerlink" title="一、悲观锁"></a>一、悲观锁</h2><h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><ul>
<li>1.关闭autocommit=0;</li>
<li>2.在事务中使用 select .. from … where … for update;给行加排他锁</li>
<li>3.select命中的行必须有索引，否则会锁表</li>
</ul>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>1.保守策略，所以数据安全性高</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>1.有加锁等额外开销，效率低</li>
<li>2.可能引起死锁</li>
<li>3.降低并行行，数据被锁住后其他事物必须等待</li>
</ul>
<h2 id="二、乐观锁"><a href="#二、乐观锁" class="headerlink" title="二、乐观锁"></a>二、乐观锁</h2><h3 id="使用：-1"><a href="#使用：-1" class="headerlink" title="使用："></a>使用：</h3><ul>
<li>1.表中增加版本号或时间戳数据列</li>
<li>2.读取数据是同时读取版本号</li>
<li>3.更新数据时添加版本号为条件，同时版本号增加1</li>
<li>4.如果更更新失败，提示用户<h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3></li>
<li>1.没有锁，效率高</li>
<li>2.不会引起死锁<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3></li>
<li>1.这里是列表文本遇到两个事务统一时间读取一行数据时，会引起问题</li>
</ul>
<h1 id="MySQL-InnoDB和MyISAM存储引擎有什么区别？"><a href="#MySQL-InnoDB和MyISAM存储引擎有什么区别？" class="headerlink" title="MySQL InnoDB和MyISAM存储引擎有什么区别？"></a>MySQL InnoDB和MyISAM存储引擎有什么区别？</h1><h2 id="答案-12"><a href="#答案-12" class="headerlink" title="答案"></a>答案</h2><h3 id="1、存储结构"><a href="#1、存储结构" class="headerlink" title="1、存储结构"></a>1、存储结构</h3><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。  </p>
<p>InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。  </p>
<h3 id="2、存储空间"><a href="#2、存储空间" class="headerlink" title="2、存储空间"></a>2、存储空间</h3><p>MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。  </p>
<p>InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p>
<h3 id="3、可移植性、备份及恢复"><a href="#3、可移植性、备份及恢复" class="headerlink" title="3、可移植性、备份及恢复"></a>3、可移植性、备份及恢复</h3><p>MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。</p>
<p>InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p>
<h3 id="4、事务支持"><a href="#4、事务支持" class="headerlink" title="4、事务支持"></a>4、事务支持</h3><p>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。  </p>
<p>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p>
<h3 id="5、AUTO-INCREMENT"><a href="#5、AUTO-INCREMENT" class="headerlink" title="5、AUTO_INCREMENT"></a>5、AUTO_INCREMENT</h3><p>MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。  </p>
<p>InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一</p>
<h3 id="6、表锁差异"><a href="#6、表锁差异" class="headerlink" title="6、表锁差异"></a>6、表锁差异</h3><p>MyISAM：只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。  </p>
<p>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p>
<h3 id="7、全文索引"><a href="#7、全文索引" class="headerlink" title="7、全文索引"></a>7、全文索引</h3><p>MyISAM：支持 FULLTEXT类型的全文索引  </p>
<p>InnoDB：5.7之后支持FULLTEXT类型的全文索引</p>
<h3 id="8、表主键"><a href="#8、表主键" class="headerlink" title="8、表主键"></a>8、表主键</h3><p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。<br>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。</p>
<h3 id="9、表的具体行数"><a href="#9、表的具体行数" class="headerlink" title="9、表的具体行数"></a>9、表的具体行数</h3><p>MyISAM：保存有表的总行数，如果select count(*) from table;会直接取出出该值。</p>
<p>InnoDB：没有保存表的总行数，如果使用select count(*) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p>
<h3 id="10、CURD操作"><a href="#10、CURD操作" class="headerlink" title="10、CURD操作"></a>10、CURD操作</h3><p>MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。</p>
<p>InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p>
<h3 id="11、外键"><a href="#11、外键" class="headerlink" title="11、外键"></a>11、外键</h3><p>MyISAM：不支持<br>InnoDB：支持</p>
<h3 id="12、崩溃自动恢复"><a href="#12、崩溃自动恢复" class="headerlink" title="12、崩溃自动恢复"></a>12、崩溃自动恢复</h3><p>MyISAM：不支持<br>InnoDB：支持</p>
<h1 id="MySQL-事务的四大特性及含义"><a href="#MySQL-事务的四大特性及含义" class="headerlink" title="MySQL 事务的四大特性及含义"></a>MySQL 事务的四大特性及含义</h1><h2 id="答案-13"><a href="#答案-13" class="headerlink" title="答案"></a>答案</h2><ul>
<li>1.持久性</li>
<li>2.原子性</li>
<li>3.一致性</li>
<li>4.隔离性<h2 id="答案记忆"><a href="#答案记忆" class="headerlink" title="答案记忆"></a>答案记忆</h2>十元一个 (持原一隔)</li>
</ul>
<h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>数据库事务transanction正确执行的四个基本要素。ACID,持久性(Durability)、原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)。  </p>
<ul>
<li>持久性: 在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</li>
<li>原子性: 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li>一致性: 在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</li>
<li>隔离性: 隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。</li>
</ul>
<h1 id="MySQL-主键-超键-候选键-外键"><a href="#MySQL-主键-超键-候选键-外键" class="headerlink" title="MySQL 主键 超键 候选键 外键"></a>MySQL 主键 超键 候选键 外键</h1><h2 id="答案-14"><a href="#答案-14" class="headerlink" title="答案"></a>答案</h2><h3 id="主-键"><a href="#主-键" class="headerlink" title="主 键"></a>主 键</h3><p>数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p>
<h3 id="超-键"><a href="#超-键" class="headerlink" title="超 键"></a>超 键</h3><p>在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p>
<h3 id="候选键"><a href="#候选键" class="headerlink" title="候选键"></a>候选键</h3><p>是最小超键，即没有冗余元素的超键。</p>
<h3 id="外-键"><a href="#外-键" class="headerlink" title="外 键"></a>外 键</h3><p>在一个表中存在的另一个表的主键称此表的外键。</p>
<h1 id="MySQL-视图的作用，视图可以更改么？"><a href="#MySQL-视图的作用，视图可以更改么？" class="headerlink" title="MySQL 视图的作用，视图可以更改么？"></a>MySQL 视图的作用，视图可以更改么？</h1><h2 id="答案-15"><a href="#答案-15" class="headerlink" title="答案"></a>答案</h2><p>视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询；不包含任何列或数据。使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。  </p>
<p>视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by 则对视图再次order by将被覆盖。</p>
<p>创建视图：create view XXX as XXXXXXXXXXXXXX;  </p>
<p>对于某些视图比如未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新；但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。</p>
<h1 id="MySQL-drop-delete与truncate的区别"><a href="#MySQL-drop-delete与truncate的区别" class="headerlink" title="MySQL drop,delete与truncate的区别"></a>MySQL drop,delete与truncate的区别</h1><h2 id="答案-16"><a href="#答案-16" class="headerlink" title="答案"></a>答案</h2><ul>
<li>drop直接删掉表</li>
<li>truncate删除表中数据，再插入时自增长id又从1开始</li>
<li>delete删除表中数据，可以加where字句。</li>
</ul>
<p>（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。  </p>
<p>（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。</p>
<p>（3） 一般而言，drop &gt; truncate &gt; delete</p>
<p>（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view</p>
<p>（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。</p>
<p>（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。</p>
<p>（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。</p>
<p>（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚</p>
<p>（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。</p>
<p>（10） Truncate table 表名 速度快,而且效率高,因为: truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p>
<p>（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。</p>
<p>（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p>
<h1 id="MySQL-索引的工作原理及其种类"><a href="#MySQL-索引的工作原理及其种类" class="headerlink" title="MySQL 索引的工作原理及其种类"></a>MySQL 索引的工作原理及其种类</h1><h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><p>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p>
<p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。  </p>
<p>为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</p>
<p><img src="/2021/03/25/interview/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/mysql2.png" alt><br>图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。</p>
<p>创建索引可以大大提高系统的性能。<br>第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br>第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。<br>第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。<br>第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。<br>第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p>
<p>也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。</p>
<p>第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。<br>第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。<br>第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p>
<p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说，应该在这些列上创建索引：在经常需要搜索的列上，可以加快搜索的速度；在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p>
<p>同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点：  </p>
<p>第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 </p>
<p>第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p>
<p>第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</p>
<p>第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。  </p>
<p>根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。</p>
<p>唯一索引是不允许其中任何两行具有相同索引值的索引。  </p>
<p>当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。 主键索引 数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。 在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 聚集索引 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。</p>
<p>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p>
<h2 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h2><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的<strong>局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</strong></p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h2 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h2><p>到这里终于可以分析B-/+Tree索引的性能了。</p>
<p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：  </p>
<p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
<p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。  </p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<h1 id="MySQL-数据库范式"><a href="#MySQL-数据库范式" class="headerlink" title="MySQL 数据库范式"></a>MySQL 数据库范式</h1><h2 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h2><p>第一范式（1NF）在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</p>
<p>简而言之，第一范式就是无重复的列。</p>
<h2 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h2><p>第二范式（2NF）第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，</p>
<p>第二范式就是非主属性非部分依赖于主关键字。</p>
<h2 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h2><p>第三范式（3NF）满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之</p>
<p>第三范式就是属性不依赖于其它非主属性。（我的理解是消除冗余）</p>
<h1 id="MySQL-数据库优化的思路"><a href="#MySQL-数据库优化的思路" class="headerlink" title="MySQL 数据库优化的思路"></a>MySQL 数据库优化的思路</h1><h2 id="1-SQL语句优化"><a href="#1-SQL语句优化" class="headerlink" title="1.SQL语句优化"></a>1.SQL语句优化</h2><ul>
<li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</li>
<li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=0</li>
<li>很多时候用 exists 代替 in 是一个好的选择</li>
<li>用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过滤</li>
</ul>
<h2 id="2-索引优化"><a href="#2-索引优化" class="headerlink" title="2.索引优化"></a>2.索引优化</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>1.可以在这些列上创建索引<br>在经常需要搜索的列上，可以加快搜索的速度；<br>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；<br>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；<br>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；<br>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；<br>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度；  </p>
<h3 id="2-不应该创建索引的的这些列："><a href="#2-不应该创建索引的的这些列：" class="headerlink" title="2.不应该创建索引的的这些列："></a>2.不应该创建索引的的这些列：</h3><p>第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。<br>第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。<br>第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。<br>第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。  </p>
<h3 id="在数据库中创建索引"><a href="#在数据库中创建索引" class="headerlink" title="在数据库中创建索引"></a>在数据库中创建索引</h3><p>唯一索引：唯一索引是不允许其中任何两行具有相同索引值的索引。  </p>
<blockquote>
<p>当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。</p>
</blockquote>
<p>主键索引：数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。  </p>
<blockquote>
<p>在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。  </p>
</blockquote>
<p>聚集索引：在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。</p>
<blockquote>
<p>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p>
</blockquote>
<h3 id="使用索引的代价"><a href="#使用索引的代价" class="headerlink" title="使用索引的代价"></a>使用索引的代价</h3><ul>
<li>索引需要占用数据表以外的物理存储空间</li>
<li>创建索引和维护索引要花费一定的时间</li>
<li>当对表进行更新操作时，索引需要被重建，这样降低了数据的维护速度。</li>
</ul>
<h2 id="3-数据库结构优化"><a href="#3-数据库结构优化" class="headerlink" title="3.数据库结构优化"></a>3.数据库结构优化</h2><ul>
<li>范式优化： 比如消除冗余（节省空间。。）</li>
<li>反范式优化：比如适当加冗余等（减少join）</li>
<li>拆分表： 分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。</li>
<li>拆分其实又分垂直拆分和水平拆分： 案例： 简单购物系统暂设涉及如下表： 1.产品表（数据量10w，稳定） 2.订单表（数据量200w，且有增长趋势） 3.用户表 （数据量100w，且有增长趋势） 以mysql为例讲述下水平拆分和垂直拆分，mysql能容忍的数量级在百万静态数据可以到千万 垂直拆分：解决问题：表与表之间的io竞争 不解决问题：单表中数据量增长出现的压力 方案： 把产品表和用户表放到一个server上 订单表单独放到一个server上 水平拆分： 解决问题：单表中数据量增长出现的压力 不解决问题：表与表之间的io争夺</li>
</ul>
<p>方案： 用户表通过性别拆分为男用户表和女用户表 订单表通过已完成和完成中拆分为已完成订单和未完成订单 产品表 未完成订单放一个server上 已完成订单表盒男用户表放一个server上 女用户表放一个server上(女的爱购物 哈哈)</p>
<h2 id="4-服务器硬件优化"><a href="#4-服务器硬件优化" class="headerlink" title="4.服务器硬件优化"></a>4.服务器硬件优化</h2><p>这个么多花钱咯！</p>
<h1 id="MySQL-存储过程与触发器的区别"><a href="#MySQL-存储过程与触发器的区别" class="headerlink" title="MySQL 存储过程与触发器的区别"></a>MySQL 存储过程与触发器的区别</h1><p>触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。  </p>
<h1 id="MySQL-复制原理以及流程"><a href="#MySQL-复制原理以及流程" class="headerlink" title="MySQL 复制原理以及流程"></a>MySQL 复制原理以及流程</h1><h2 id="复制基本原理流程"><a href="#复制基本原理流程" class="headerlink" title="复制基本原理流程"></a>复制基本原理流程</h2><p>1.主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；<br>2.从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；<br>3.从：sql执行线程——执行relay log中的语句；  </p>
<h2 id="MySQL复制的线程有几个及之间的关联"><a href="#MySQL复制的线程有几个及之间的关联" class="headerlink" title="MySQL复制的线程有几个及之间的关联"></a>MySQL复制的线程有几个及之间的关联</h2><p>MySQL 的复制是基于如下 3 个线程的交互（ 多线程复制里面应该是 4 类线程）：<br>1.Master 上面的 binlog dump 线程，该线程负责将 master 的 binlog event 传到slave；<br>2.Slave 上面的 IO 线程，该线程负责接收 Master 传过来的 binlog，并写入 relay log；<br>3.Slave 上面的 SQL 线程，该线程负责读取 relay log 并执行；<br>4.如果是多线程复制，无论是 5.6 库级别的假多线程还是 MariaDB 或者 5.7 的真正的多线程复制， SQL 线程只做 coordinator，只负责把 relay log 中的 binlog读出来然后交给 worker 线程， woker 线程负责具体 binlog event 的执行；  </p>
<h2 id="MySQL如何保证复制过程中数据一致性及减少数据同步延时"><a href="#MySQL如何保证复制过程中数据一致性及减少数据同步延时" class="headerlink" title="MySQL如何保证复制过程中数据一致性及减少数据同步延时"></a>MySQL如何保证复制过程中数据一致性及减少数据同步延时</h2><h3 id="一致性主要有以下几个方面"><a href="#一致性主要有以下几个方面" class="headerlink" title="一致性主要有以下几个方面"></a>一致性主要有以下几个方面</h3><p>在 MySQL5.5 以及之前， slave 的 SQL 线程执行的 relay log 的位置只能保存在文件（ relay-log.info）里面，并且该文件默认每执行 10000 次事务做一次同步到磁盘， 这意味着 slave 意外 crash 重启时， SQL 线程执行到的位置和数据库的数据是不一致的，将导致复制报错，如果不重搭复制，则有可能会导致数据不一致。 MySQL 5.6 引入参数 relay_log_info_repository，将该参数设置为 TABLE 时， MySQL 将 SQL 线程执行到的位置存到mysql.slave_relay_log_info 表，这样更新该表的位置和 SQL 线程执行的用户事务绑定成一个事务，这样 slave 意外宕机后， slave 通过 innodb 的崩溃恢复可以把 SQL 线程执行到的位置和用户事务恢复到一致性的状态。  </p>
<p>MySQL 5.6 引入 GTID 复制，每个 GTID 对应的事务在每个实例上面最多执行一次， 这极大地提高了复制的数据一致性；  </p>
<p>MySQL 5.5 引入半同步复制， 用户安装半同步复制插件并且开启参数后，设置超时时间，可保证在超时时间内如果 binlog 不传到 slave 上面，那么用户提交事务时不会返回，直到超时后切成异步复制，但是如果切成异步之前用户线程提交时在 master 上面等待的时候，事务已经提交，该事务对 master 上面的其他 session 是可见的，如果这时 master 宕机，那么到 slave 上面该事务又不可见了，该问题直到 5.7 才解决；  </p>
<p>MySQL 5.7 引入无损半同步复制，引入参rpl_semi_sync_master_wait_point，该参数默认为 after_sync，指的是在切成半同步之前，事务不提交，而是接收到 slave 的 ACK 确认之后才提交该事务，从此，复制真正可以做到无损的了。  </p>
<p>可以再说一下 5.7 的无损复制情况下， master 意外宕机，重启后发现有 binlog没传到 slave 上面，这部分 binlog 怎么办？？？分 2 种情况讨论， 1 宕机时已经切成异步了， 2 是宕机时还没切成异步？？？ 这个怎么判断宕机时有没有切成异步呢？？？ 分别怎么处理？？？  </p>
<h3 id="延时性"><a href="#延时性" class="headerlink" title="延时性"></a>延时性</h3><p>5.5 是单线程复制， 5.6 是多库复制（对于单库或者单表的并发操作是没用的）， 5.7 是真正意义的多线程复制，它的原理是基于 group commit， 只要 master 上面的事务是 group commit 的，那 slave 上面也可以通过多个 worker线程去并发执行。 和 MairaDB10.0.0.5 引入多线程复制的原理基本一样。  </p>
<h2 id="工作遇到的复制-bug-的解决方法"><a href="#工作遇到的复制-bug-的解决方法" class="headerlink" title="工作遇到的复制 bug 的解决方法"></a>工作遇到的复制 bug 的解决方法</h2><p>5.6 的多库复制有时候自己会停止，我们写了一个脚本重新 start slave;</p>
<h1 id="MySQL-myisam与innodb的区别，至少5点"><a href="#MySQL-myisam与innodb的区别，至少5点" class="headerlink" title="MySQL myisam与innodb的区别，至少5点"></a>MySQL myisam与innodb的区别，至少5点</h1><h2 id="问5点不同"><a href="#问5点不同" class="headerlink" title="问5点不同"></a>问5点不同</h2><ul>
<li>1.InnoDB支持事物，而MyISAM不支持事物</li>
<li>2.InnoDB支持行级锁，而MyISAM支持表级锁</li>
<li>3.InnoDB支持MVCC, 而MyISAM不支持</li>
<li>4.InnoDB支持外键，而MyISAM不支持</li>
<li>5.InnoDB不支持全文索引，而MyISAM支持。</li>
<li>6.InnoDB不能通过直接拷贝表文件的方法拷贝表到另外一台机器， myisam 支持</li>
<li>7.InnoDB表支持多种行格式， myisam 不支持</li>
<li>8.InnoDB是索引组织表， myisam 是堆表</li>
</ul>
<h2 id="innodb引擎的4大特性"><a href="#innodb引擎的4大特性" class="headerlink" title="innodb引擎的4大特性"></a>innodb引擎的4大特性</h2><ul>
<li>1.插入缓冲（insert buffer)</li>
<li>2.二次写(double write)</li>
<li>3.自适应哈希索引(ahi)</li>
<li>4.预读(read ahead)</li>
</ul>
<h2 id="2者select-count-哪个更快，为什么"><a href="#2者select-count-哪个更快，为什么" class="headerlink" title="2者select count(*)哪个更快，为什么"></a>2者select count(*)哪个更快，为什么</h2><p>myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</p>
<h2 id="2-者的索引的实现方式"><a href="#2-者的索引的实现方式" class="headerlink" title="2 者的索引的实现方式"></a>2 者的索引的实现方式</h2><p>都是 B+树索引， Innodb 是索引组织表， myisam 是堆表， 索引组织表和堆表的区别要熟悉</p>
<h1 id="MySQL中varchar与char的区别以及varchar-50-中的50代表的涵义"><a href="#MySQL中varchar与char的区别以及varchar-50-中的50代表的涵义" class="headerlink" title="MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义"></a>MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义</h1><h2 id="1-varchar与char的区别"><a href="#1-varchar与char的区别" class="headerlink" title="(1)varchar与char的区别"></a>(1)varchar与char的区别</h2><p>在单字节字符集下， char（ N） 在内部存储的时候总是定长， 而且没有变长字段长度列表中。 在多字节字符集下面， char(N)如果存储的字节数超过 N，那么 char（ N）将和 varchar（ N）没有区别。在多字节字符集下面，如果存</p>
<p>储的字节数少于 N，那么存储 N 个字节，后面补空格，补到 N 字节长度。 都存储变长的数据和变长字段长度列表。 varchar(N)无论是什么字节字符集，都是变长的，即都存储变长数据和变长字段长度列表。</p>
<h2 id="2-varchar-50-中50的涵义"><a href="#2-varchar-50-中50的涵义" class="headerlink" title="(2)varchar(50)中50的涵义"></a>(2)varchar(50)中50的涵义</h2><p>最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。  </p>
<h2 id="3-int（20）中20的涵义"><a href="#3-int（20）中20的涵义" class="headerlink" title="(3)int（20）中20的涵义"></a>(3)int（20）中20的涵义</h2><p>是指显示字符的长度<br>不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</p>
<h2 id="4-mysql为什么这么设计"><a href="#4-mysql为什么这么设计" class="headerlink" title="(4)mysql为什么这么设计"></a>(4)mysql为什么这么设计</h2><p>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；  </p>
<h1 id="MySQL-innodb的事务与日志的实现方式"><a href="#MySQL-innodb的事务与日志的实现方式" class="headerlink" title="MySQL innodb的事务与日志的实现方式"></a>MySQL innodb的事务与日志的实现方式</h1><h2 id="1-有多少种日志"><a href="#1-有多少种日志" class="headerlink" title="(1)有多少种日志"></a>(1)有多少种日志</h2><p>redo和undo</p>
<h2 id="2-日志的存放形式"><a href="#2-日志的存放形式" class="headerlink" title="(2)日志的存放形式"></a>(2)日志的存放形式</h2><p>redo：在页修改的时候，先写到 redo log buffer 里面， 然后写到 redo log 的文件系统缓存里面(fwrite)，然后再同步到磁盘文件（ fsync）。<br>Undo：在 MySQL5.5 之前， undo 只能存放在 ibdata文件里面， 5.6 之后，可以通过设置 innodb_undo_tablespaces 参数把 undo log 存放在 ibdata之外。  </p>
<h2 id="3-事务是如何通过日志来实现的，说得越深入越好"><a href="#3-事务是如何通过日志来实现的，说得越深入越好" class="headerlink" title="(3)事务是如何通过日志来实现的，说得越深入越好"></a>(3)事务是如何通过日志来实现的，说得越深入越好</h2><p>基本流程如下：<br>因为事务在修改页时，要先记 undo，在记 undo 之前要记 undo 的 redo， 然后修改数据页，再记数据页修改的 redo。 Redo（里面包括 undo 的修改） 一定要比数据页先持久化到磁盘。 当事务需要回滚时，因为有 undo，可以把数据页回滚到前镜像的 状态，崩溃恢复时，如果 redo log 中事务没有对应的 commit 记录，那么需要用 undo把该事务的修改回滚到事务开始之前。 如果有 commit 记录，就用 redo 前滚到该事务完成时并提交掉。</p>
<h1 id="MySQL-binlog的几种日志录入格式以及区别"><a href="#MySQL-binlog的几种日志录入格式以及区别" class="headerlink" title="MySQL binlog的几种日志录入格式以及区别"></a>MySQL binlog的几种日志录入格式以及区别</h1><h2 id="1-各种日志格式的涵义"><a href="#1-各种日志格式的涵义" class="headerlink" title="(1)各种日志格式的涵义"></a>(1)各种日志格式的涵义</h2><p>Statement：每一条会修改数据的sql都会记录在binlog中。</p>
<p>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。(相比row能节约多少性能 与日志量，这个取决于应用的SQL情况，正常同一条记录修改或者插入row格式所产生的日志量还小于Statement产生的日志量， 但是考虑到如果带条 件的update操作，以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据应用的实际情况，其所 产生的日志量会增加多少，以及带来的IO性能问题。)</p>
<p>缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的 一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同 的结果。另外mysql 的复制,像一些特定函数功能，slave可与master上要保持一致会有很多相关问题(如sleep()函数， last_insert_id()，以及user-defined functions(udf)会出现问题).  </p>
<p>使用以下函数的语句也无法被复制：  </p>
<ul>
<li>LOAD_FILE()</li>
<li>UUID()</li>
<li>USER()</li>
<li>FOUND_ROWS()</li>
<li>SYSDATE() (除非启动时启用了 —sysdate-is-now 选项) 同时在INSERT …SELECT 会产生比 RBR 更多的行级锁</li>
</ul>
<p>2.Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。</p>
<p>优点：binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下 每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题  </p>
<p>缺点：所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比 如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。  </p>
<p>3.Mixedlevel: 是以上两种level的混合使用，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则 采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择 一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更。</p>
<h2 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="(2)适用场景"></a>(2)适用场景</h2><p>在一条 SQL 操作了多行数据时， statement 更节省空间， row 更占用空间。但是 row模式更可靠。</p>
<h2 id="3-结合第一个问题，每一种日志格式在复制中的优劣"><a href="#3-结合第一个问题，每一种日志格式在复制中的优劣" class="headerlink" title="(3)结合第一个问题，每一种日志格式在复制中的优劣"></a>(3)结合第一个问题，每一种日志格式在复制中的优劣</h2><p>Statement 可能占用空间会相对小一些，传送到 slave 的时间可能也短，但是没有 row模式的可靠。 Row 模式在操作多行数据时更占用空间， 但是可靠。  </p>
<p>#　MySQL 数据库cpu飙升到500%的话怎么处理？<br>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等　　</p>
<h1 id="MySQL-sql优化"><a href="#MySQL-sql优化" class="headerlink" title="MySQL sql优化"></a>MySQL sql优化</h1><h2 id="1-explain出来的各种item的意义"><a href="#1-explain出来的各种item的意义" class="headerlink" title="(1)explain出来的各种item的意义"></a>(1)explain出来的各种item的意义</h2><ul>
<li>id：每个被独立执行的操作的标志，表示对象被操作的顺序。一般来说， id 值大，先被执行；如果 id 值相同，则顺序从上到下。</li>
<li>select_type：查询中每个 select 子句的类型。</li>
<li>table：名字，被操作的对象名称，通常的表名(或者别名)，但是也有其他格式。</li>
<li>partitions：匹配的分区信息。</li>
<li>type:join 类型。</li>
<li>possible_keys：列出可能会用到的索引。</li>
<li>key：实际用到的索引。</li>
<li>key_len：用到的索引键的平均长度，单位为字节。</li>
<li>ref：表示本行被操作的对象的参照对象，可能是一个常量用 const 表示，也可能是其他表的</li>
<li>key：指向的对象，比如说驱动表的连接列。</li>
<li>rows：估计每次需要扫描的行数。</li>
<li>filtered:rows*filtered/100 表示该步骤最后得到的行数(估计值)。</li>
<li>extra：重要的补充信息。</li>
</ul>
<h2 id="2-profile的意义以及使用场景"><a href="#2-profile的意义以及使用场景" class="headerlink" title="(2)profile的意义以及使用场景"></a>(2)profile的意义以及使用场景</h2><p>Profile 用来分析 sql 性能的消耗分布情况。当用 explain 无法解决慢 SQL 的时候，需要用profile 来对 sql 进行更细致的分析，找出 sql 所花的时间大部分消耗在哪个部分，确认 sql的性能瓶颈。</p>
<h2 id="3-explain-中的索引问题"><a href="#3-explain-中的索引问题" class="headerlink" title="(3)explain 中的索引问题"></a>(3)explain 中的索引问题</h2><p>Explain 结果中，一般来说，要看到尽量用 index(type 为 const、 ref 等， key 列有值)，避免使用全表扫描(type 显式为 ALL)。比如说有 where 条件且选择性不错的列，需要建立索引。<br>被驱动表的连接列，也需要建立索引。被驱动表的连接列也可能会跟 where 条件列一起建立联合索引。当有排序或者 group by 的需求时，也可以考虑建立索引来达到直接排序和汇总的需求。  </p>
<h1 id="MySQL-备份计划，mysqldump以及xtranbackup的实现原理"><a href="#MySQL-备份计划，mysqldump以及xtranbackup的实现原理" class="headerlink" title="MySQL 备份计划，mysqldump以及xtranbackup的实现原理"></a>MySQL 备份计划，mysqldump以及xtranbackup的实现原理</h1><h2 id="1-备份计划"><a href="#1-备份计划" class="headerlink" title="(1)备份计划"></a>(1)备份计划</h2><p>视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。</p>
<h2 id="2-备份恢复时间"><a href="#2-备份恢复时间" class="headerlink" title="(2)备份恢复时间"></a>(2)备份恢复时间</h2><p>物理备份恢复快，逻辑备份恢复慢 这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考 20G的2分钟（mysqldump） 80G的30分钟(mysqldump) 111G的30分钟（mysqldump) 288G的3小时（xtra) 3T的4小时（xtra) 逻辑导入时间一般是备份时间的5倍以上</p>
<h2 id="3-备份恢复失败如何处理"><a href="#3-备份恢复失败如何处理" class="headerlink" title="(3)备份恢复失败如何处理"></a>(3)备份恢复失败如何处理</h2><p>首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。</p>
<h2 id="mysqldump和xtranbackup实现原理"><a href="#mysqldump和xtranbackup实现原理" class="headerlink" title="mysqldump和xtranbackup实现原理"></a>mysqldump和xtranbackup实现原理</h2><p>mysqldump</p>
<blockquote>
<p>mysqldump 属于逻辑备份。加入—single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION TRANSACTION ISOLATION LEVELREPEATABLE READ)， 之后显式开启一个事务(START TRANSACTION /!40100 WITH CONSISTENTSNAPSHOT /)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。 如果加上—master-data=1 的话，在刚开始的时候还会加一个数据库的读锁 (FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务</p>
</blockquote>
<p>xtranbackup</p>
<blockquote>
<p>xtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。最后完成 innodb 的备份后，会做一个 flush engine logs 的操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交 概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢最后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事 情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。 这样就做到了完美的热备。  </p>
</blockquote>
<p>mysqldump中备份出来的sql，如果我想sql文件中，一行只有一个insert….value()的话，怎么办？如果备份需要带上master的复制点信息怎么办？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--skip-extended-insert</span><br><span class="line">[root@helei-zhuanshu ~]# mysqldump -uroot -p helei --skip-extended-insert</span><br><span class="line">Enter password:</span><br><span class="line">  KEY &#96;idx_c1&#96; (&#96;c1&#96;),</span><br><span class="line">  KEY &#96;idx_c2&#96; (&#96;c2&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;51 DEFAULT CHARSET&#x3D;latin1;</span><br><span class="line">&#x2F;*!40101 SET character_set_client &#x3D; @saved_cs_client *&#x2F;;</span><br><span class="line">--</span><br><span class="line">-- Dumping data for table &#96;helei&#96;</span><br><span class="line">--</span><br><span class="line">LOCK TABLES &#96;helei&#96; WRITE;</span><br><span class="line">&#x2F;*!40000 ALTER TABLE &#96;helei&#96; DISABLE KEYS *&#x2F;;</span><br><span class="line">INSERT INTO &#96;helei&#96; VALUES (1,32,37,38,&#39;2016-10-18 06:19:24&#39;,&#39;susususususususususususu&#39;);</span><br><span class="line">INSERT INTO &#96;helei&#96; VALUES (2,37,46,21,&#39;2016-10-18 06:19:24&#39;,&#39;susususususu&#39;);</span><br><span class="line">INSERT INTO &#96;helei&#96; VALUES (3,21,5,14,&#39;2016-10-18 06:19:24&#39;,&#39;susu&#39;);</span><br></pre></td></tr></table></figure>
<p>如何从mysqldump产生的全库备份中只恢复某一个库、某一张表？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 全库备份</span><br><span class="line">[root@HE1 ~]# mysqldump -uroot -p --single-transaction -A --master-data&#x3D;2 &gt;dump.sql</span><br><span class="line"># 只还原erp库的内容</span><br><span class="line">[root@HE1 ~]# mysql -uroot -pMANAGER erp --one-database &lt;dump.sql</span><br><span class="line"># 可以看出这里主要用到的参数是--one-database简写-o的参数，极大方便了我们的恢复灵活性</span><br><span class="line"># 那么如何从全库备份中抽取某张表呢，全库恢复，再恢复某张表小库还可以，大库就很麻烦了，那我们可以利用正则表达式来进行快速抽取，具体实现方法如下：</span><br><span class="line"># 从全库备份中抽取出t表的表结构</span><br><span class="line">[root@HE1 ~]# sed -e&#39;&#x2F;.&#x2F;&#123;H;$!d;&#125;&#39; -e &#39;x;&#x2F;CREATE TABLE &#96;t&#96;&#x2F;!d;q&#39; dump.sql</span><br><span class="line">DROP TABLE IF EXISTS&#96;t&#96;;</span><br><span class="line">&#x2F;*!40101 SET@saved_cs_client     &#x3D;@@character_set_client *&#x2F;;</span><br><span class="line">&#x2F;*!40101 SETcharacter_set_client &#x3D; utf8 *&#x2F;;</span><br><span class="line">CREATE TABLE &#96;t&#96; (</span><br><span class="line">  &#96;id&#96; int(10) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;age&#96; tinyint(4) NOT NULL DEFAULT &#39;0&#39;,</span><br><span class="line">  &#96;name&#96; varchar(30) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDBAUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line">&#x2F;*!40101 SETcharacter_set_client &#x3D; @saved_cs_client *&#x2F;;</span><br><span class="line"># 从全库备份中抽取出t表的内容</span><br><span class="line">[root@HE1 ~]# grep&#39;INSERT INTO &#96;t&#96;&#39; dump.sql</span><br><span class="line">INSERT INTO &#96;t&#96;VALUES (0,0,&#39;&#39;),(1,0,&#39;aa&#39;),(2,0,&#39;bbb&#39;),(3,25,&#39;helei&#39;);</span><br></pre></td></tr></table></figure>

<h1 id="MySQL-500台db，在最快时间之内重启"><a href="#MySQL-500台db，在最快时间之内重启" class="headerlink" title="MySQL 500台db，在最快时间之内重启"></a>MySQL 500台db，在最快时间之内重启</h1><p>可以使用批量 ssh 工具 pssh 来对需要重启的机器执行重启命令。  </p>
<p>也可以使用 salt（前提是客户端有安装 salt）或者 ansible（ ansible 只需要 ssh 免登通了就行）等多线程工具同时操作多台服务器</p>
<h1 id="MySQL-innodb的读写参数优化"><a href="#MySQL-innodb的读写参数优化" class="headerlink" title="MySQL innodb的读写参数优化"></a>MySQL innodb的读写参数优化</h1><h2 id="1-读取参数"><a href="#1-读取参数" class="headerlink" title="(1)读取参数"></a>(1)读取参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># global buffer 以及 local buffer；</span><br><span class="line"># Global buffer：</span><br><span class="line">Innodb_buffer_pool_size</span><br><span class="line">innodb_log_buffer_size</span><br><span class="line">innodb_additional_mem_pool_size</span><br><span class="line"># local buffer(下面的都是 server 层的 session 变量，不是 innodb 的)：</span><br><span class="line">Read_buffer_size</span><br><span class="line">Join_buffer_size</span><br><span class="line">Sort_buffer_size</span><br><span class="line">Key_buffer_size</span><br><span class="line">Binlog_cache_size</span><br></pre></td></tr></table></figure>
<h2 id="2-写入参数"><a href="#2-写入参数" class="headerlink" title="(2)写入参数"></a>(2)写入参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">innodb_flush_log_at_trx_commit</span><br><span class="line">innodb_buffer_pool_size</span><br><span class="line">insert_buffer_size</span><br><span class="line">innodb_double_write</span><br><span class="line">innodb_write_io_thread</span><br><span class="line">innodb_flush_method</span><br></pre></td></tr></table></figure>

<h2 id="3-与IO相关的参数"><a href="#3-与IO相关的参数" class="headerlink" title="(3)与IO相关的参数"></a>(3)与IO相关的参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">innodb_write_io_threads &#x3D; 8</span><br><span class="line">innodb_read_io_threads &#x3D; 8</span><br><span class="line">innodb_thread_concurrency &#x3D; 0</span><br><span class="line">Sync_binlog</span><br><span class="line">Innodb_flush_log_at_trx_commit</span><br><span class="line">Innodb_lru_scan_depth</span><br><span class="line">Innodb_io_capacity</span><br><span class="line">Innodb_io_capacity_max</span><br><span class="line">innodb_log_buffer_size</span><br><span class="line">innodb_max_dirty_pages_pct</span><br></pre></td></tr></table></figure>

<h2 id="4-缓存参数以及缓存的适用场景"><a href="#4-缓存参数以及缓存的适用场景" class="headerlink" title="(4)缓存参数以及缓存的适用场景"></a>(4)缓存参数以及缓存的适用场景</h2><p>query cache/query_cache_type</p>
<p>并不是所有表都适合使用query cache。造成query cache失效的原因主要是相应的table发生了变更  </p>
<ul>
<li>第一个：读操作多的话看看比例，简单来说，如果是用户清单表，或者说是数据比例比较固定，比如说商品列表，是可以打开的，前提是这些库比较集中，数据库中的实务比较小。</li>
<li>第二个：我们“行骗”的时候，比如说我们竞标的时候压测，把query cache打开，还是能收到qps激增的效果，当然前提示前端的连接池什么的都配置一样。大部分情况下如果写入的居多，访问量并不多，那么就不要打开，例如社交网站的，10%的人产生内容，其余的90%都在消费，打开还是效果很好的，但是你如果是qq消息，或者聊天，那就很要命。</li>
<li>第三个：小网站或者没有高并发的无所谓，高并发下，会看到 很多 qcache 锁 等待，所以一般高并发下，不建议打开query cache</li>
</ul>
<h1 id="MySQL-你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？"><a href="#MySQL-你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？" class="headerlink" title="MySQL 你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？"></a>MySQL 你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？</h1><p>监控的工具有很多，例如zabbix，lepus，我这里用的是lepus</p>
<h1 id="MySQL-你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"><a href="#MySQL-你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？" class="headerlink" title="MySQL 你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"></a>MySQL 你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？</h1><p>主从一致性校验有多种工具，例如checksum、mysqldiff、pt-table-checksum等</p>
<h1 id="MySQL-InnoDB引擎的行锁是通过加在什么上完成-或称实现-的？为什么是这样子的？"><a href="#MySQL-InnoDB引擎的行锁是通过加在什么上完成-或称实现-的？为什么是这样子的？" class="headerlink" title="MySQL InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？"></a>MySQL InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？</h1><h2 id="答案-17"><a href="#答案-17" class="headerlink" title="答案"></a>答案</h2><p>InnoDB是基于索引来完成行锁  </p>
<p>例: select * from tab_with_index where id = 1 for update;</p>
<p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起。</p>
<h1 id="MySQL-表中有大字段X-例如：text类型-，且字段X不会经常更新，以读为主，请问您是选择拆成子表，还是继续放一起-写出您这样选择的理由"><a href="#MySQL-表中有大字段X-例如：text类型-，且字段X不会经常更新，以读为主，请问您是选择拆成子表，还是继续放一起-写出您这样选择的理由" class="headerlink" title="MySQL 表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为主，请问您是选择拆成子表，还是继续放一起?写出您这样选择的理由"></a>MySQL 表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为主，请问您是选择拆成子表，还是继续放一起?写出您这样选择的理由</h1><h2 id="答案-18"><a href="#答案-18" class="headerlink" title="答案"></a>答案</h2><p>拆带来的问题：连接消耗 + 存储拆分空间；不拆可能带来的问题：查询性能；</p>
<p>如果能容忍拆分带来的空间问题,拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区) 顺序IO,减少连接消耗,最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗</p>
<p>如果能容忍不拆分带来的查询性能损失的话:上面的方案在某个极致条件下肯定会出现问题,那么不拆就是最好的选择</p>
<h1 id="MySQL如何处理死锁"><a href="#MySQL如何处理死锁" class="headerlink" title="MySQL如何处理死锁?"></a>MySQL如何处理死锁?</h1><h2 id="一、什么是死锁"><a href="#一、什么是死锁" class="headerlink" title="一、什么是死锁"></a>一、什么是死锁</h2><p>官方定义如下：两个事务都持有对方需要的锁，并且在等待对方释放，并且双方都不会释放自己的锁。<br>这个就好比你有一个人质，对方有一个人质，你们俩去谈判说换人。你让对面放人，对面让你放人。<br><img src="/2021/03/25/interview/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/mysql3.png" alt></p>
<h2 id="二、为什么会形成死锁"><a href="#二、为什么会形成死锁" class="headerlink" title="二、为什么会形成死锁"></a>二、为什么会形成死锁</h2><p>看到这里，也许你会有这样的疑问，事务和谈判不一样，为什么事务不能使用完锁之后立马释放呢？居然还要操作完了之后一直持有锁？这就涉及到 MySQL 的并发控制了。  </p>
<p>MySQL的并发控制有两种方式，一个是 MVCC，一个是两阶段锁协议。那么为什么要并发控制呢？是因为多个用户同时操作 MySQL 的时候，为了提高并发性能并且要求如同多个用户的请求过来之后如同串行执行的一样（可串行化调度）。具体的并发控制这里不再展开。咱们继续深入讨论两阶段锁协议。  </p>
<h3 id="两阶段锁协议（2PL）"><a href="#两阶段锁协议（2PL）" class="headerlink" title="两阶段锁协议（2PL）"></a>两阶段锁协议（2PL）</h3><p>官方定义：  </p>
<blockquote>
<p>两阶段锁协议是指所有事务必须分两个阶段对数据加锁和解锁，在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁；在释放一个封锁之后，事务不再申请和获得任何其他封锁。</p>
</blockquote>
<p>对应到 MySQL 上分为两个阶段：</p>
<ul>
<li>扩展阶段（事务开始后，commit 之前）：获取锁</li>
<li>收缩阶段（commit 之后）：释放锁</li>
</ul>
<p>就是说呢，只有遵循两段锁协议，才能实现 可串行化调度。<br>但是两阶段锁协议不要求事务必须一次将所有需要使用的数据加锁，并且在加锁阶段没有顺序要求，所以这种并发控制方式会形成死锁。  </p>
<h1 id="三、MySQL-如何处理死锁？"><a href="#三、MySQL-如何处理死锁？" class="headerlink" title="三、MySQL 如何处理死锁？"></a>三、MySQL 如何处理死锁？</h1><p>MySQL有两种死锁处理方式：  </p>
<ul>
<li>等待，直到超时（innodb_lock_wait_timeout=50s）。</li>
<li>发起死锁检测，主动回滚一条事务，让其他事务继续执行（innodb_deadlock_detect=on）。<br>由于性能原因，一般都是使用死锁检测来进行处理死锁。</li>
</ul>
<h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>死锁检测的原理是构建一个以事务为顶点、锁为边的有向图，判断有向图是否存在环，存在即有死锁。</p>
<h2 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h2><p>检测到死锁之后，选择插入更新或者删除的行数最少的事务回滚，基于 INFORMATION_SCHEMA.INNODB_TRX 表中的 trx_weight 字段来判断。</p>
<h2 id="四、如何避免发生死锁"><a href="#四、如何避免发生死锁" class="headerlink" title="四、如何避免发生死锁"></a>四、如何避免发生死锁</h2><h3 id="收集死锁信息："><a href="#收集死锁信息：" class="headerlink" title="收集死锁信息："></a>收集死锁信息：</h3><ul>
<li>利用命令 SHOW ENGINE INNODB STATUS查看死锁原因。</li>
<li>调试阶段开启 innodb_print_all_deadlocks，收集所有死锁日志。<h3 id="减少死锁："><a href="#减少死锁：" class="headerlink" title="减少死锁："></a>减少死锁：</h3></li>
<li>使用事务，不使用 lock tables 。</li>
<li>保证没有长事务。</li>
<li>操作完之后立即提交事务，特别是在交互式命令行中。</li>
<li>如果在用 (SELECT … FOR UPDATE or SELECT … LOCK IN SHARE MODE)，尝试降低隔离级别。</li>
<li>修改多个表或者多个行的时候，将修改的顺序保持一致。</li>
<li>创建索引，可以使创建的锁更少。</li>
<li>最好不要用 (SELECT … FOR UPDATE or SELECT … LOCK IN SHARE MODE)。</li>
<li>如果上述都无法解决问题，那么尝试使用 lock tables t1, t2, t3 锁多张表</li>
</ul>
<h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><p><a href="https://www.jishuchi.com/read/mysql-interview" target="_blank" rel="noopener">https://www.jishuchi.com/read/mysql-interview</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># 面试题</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/25/redis/%E4%B8%80%E7%AB%99%E5%BC%8F%E5%AD%A6%E4%B9%A0redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E8%B7%B5/" rel="prev" title="redis/一站式学习redis从入门到高可用分布式实践">
      <i class="fa fa-chevron-left"></i> redis/一站式学习redis从入门到高可用分布式实践
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/25/interview/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="next" title="interview/Redis面试题">
      interview/Redis面试题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-索引最左前缀原则"><span class="nav-number">1.</span> <span class="nav-text">MySQL 索引最左前缀原则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#答案"><span class="nav-number">1.1.</span> <span class="nav-text">答案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-INT和CHAR隐式类型转换需要注意什么？"><span class="nav-number">2.</span> <span class="nav-text">MySQL INT和CHAR隐式类型转换需要注意什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#答案-1"><span class="nav-number">2.1.</span> <span class="nav-text">答案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#答案解析"><span class="nav-number">2.2.</span> <span class="nav-text">答案解析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-执行-select-count-from-articles，MyISAM和InnoDB哪个快？"><span class="nav-number">3.</span> <span class="nav-text">MySQL 执行 select count(*) from articles，MyISAM和InnoDB哪个快？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#答案-2"><span class="nav-number">3.1.</span> <span class="nav-text">答案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-sql中left-join、right-join、inner-join有什么区别？"><span class="nav-number">4.</span> <span class="nav-text">MySQL sql中left join、right join、inner join有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#答案-3"><span class="nav-number">4.1.</span> <span class="nav-text">答案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MYSQL-主从服务器，如果主服务器是InnoDB引擎，从服务器是MyISAM引擎，应用中会遇到什么问题？"><span class="nav-number">5.</span> <span class="nav-text">MYSQL 主从服务器，如果主服务器是InnoDB引擎，从服务器是MyISAM引擎，应用中会遇到什么问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#答案-4"><span class="nav-number">5.1.</span> <span class="nav-text">答案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-sql语句应该考虑哪些安全性？"><span class="nav-number">6.</span> <span class="nav-text">MySQL sql语句应该考虑哪些安全性？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#答案-5"><span class="nav-number">6.1.</span> <span class="nav-text">答案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL事务的隔离级别"><span class="nav-number">7.</span> <span class="nav-text">MySQL事务的隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#答案-6"><span class="nav-number">7.1.</span> <span class="nav-text">答案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#答案解析-1"><span class="nav-number">7.2.</span> <span class="nav-text">答案解析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-如何高效率随机获取N条数据？"><span class="nav-number">8.</span> <span class="nav-text">MySQL 如何高效率随机获取N条数据？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#答案-7"><span class="nav-number">8.1.</span> <span class="nav-text">答案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-简述聚簇索引和非聚簇索引"><span class="nav-number">9.</span> <span class="nav-text">MySQL 简述聚簇索引和非聚簇索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#答案-8"><span class="nav-number">9.1.</span> <span class="nav-text">答案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-有哪些索引类型"><span class="nav-number">10.</span> <span class="nav-text">MySQL 有哪些索引类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#答案-9"><span class="nav-number">10.1.</span> <span class="nav-text">答案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-有哪些存储引擎？"><span class="nav-number">11.</span> <span class="nav-text">MySQL 有哪些存储引擎？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#答案-10"><span class="nav-number">11.1.</span> <span class="nav-text">答案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-悲观锁和乐观锁是什么？"><span class="nav-number">12.</span> <span class="nav-text">MySQL 悲观锁和乐观锁是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#答案-11"><span class="nav-number">12.1.</span> <span class="nav-text">答案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一、悲观锁"><span class="nav-number">12.2.</span> <span class="nav-text">一、悲观锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用："><span class="nav-number">12.2.1.</span> <span class="nav-text">使用：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点："><span class="nav-number">12.2.2.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点："><span class="nav-number">12.2.3.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、乐观锁"><span class="nav-number">12.3.</span> <span class="nav-text">二、乐观锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用：-1"><span class="nav-number">12.3.1.</span> <span class="nav-text">使用：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点：-1"><span class="nav-number">12.3.2.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点：-1"><span class="nav-number">12.3.3.</span> <span class="nav-text">缺点：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-InnoDB和MyISAM存储引擎有什么区别？"><span class="nav-number">13.</span> <span class="nav-text">MySQL InnoDB和MyISAM存储引擎有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#答案-12"><span class="nav-number">13.1.</span> <span class="nav-text">答案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、存储结构"><span class="nav-number">13.1.1.</span> <span class="nav-text">1、存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、存储空间"><span class="nav-number">13.1.2.</span> <span class="nav-text">2、存储空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、可移植性、备份及恢复"><span class="nav-number">13.1.3.</span> <span class="nav-text">3、可移植性、备份及恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、事务支持"><span class="nav-number">13.1.4.</span> <span class="nav-text">4、事务支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、AUTO-INCREMENT"><span class="nav-number">13.1.5.</span> <span class="nav-text">5、AUTO_INCREMENT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、表锁差异"><span class="nav-number">13.1.6.</span> <span class="nav-text">6、表锁差异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、全文索引"><span class="nav-number">13.1.7.</span> <span class="nav-text">7、全文索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、表主键"><span class="nav-number">13.1.8.</span> <span class="nav-text">8、表主键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9、表的具体行数"><span class="nav-number">13.1.9.</span> <span class="nav-text">9、表的具体行数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10、CURD操作"><span class="nav-number">13.1.10.</span> <span class="nav-text">10、CURD操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11、外键"><span class="nav-number">13.1.11.</span> <span class="nav-text">11、外键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12、崩溃自动恢复"><span class="nav-number">13.1.12.</span> <span class="nav-text">12、崩溃自动恢复</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-事务的四大特性及含义"><span class="nav-number">14.</span> <span class="nav-text">MySQL 事务的四大特性及含义</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#答案-13"><span class="nav-number">14.1.</span> <span class="nav-text">答案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#答案记忆"><span class="nav-number">14.2.</span> <span class="nav-text">答案记忆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#含义"><span class="nav-number">14.3.</span> <span class="nav-text">含义</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-主键-超键-候选键-外键"><span class="nav-number">15.</span> <span class="nav-text">MySQL 主键 超键 候选键 外键</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#答案-14"><span class="nav-number">15.1.</span> <span class="nav-text">答案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主-键"><span class="nav-number">15.1.1.</span> <span class="nav-text">主 键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#超-键"><span class="nav-number">15.1.2.</span> <span class="nav-text">超 键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#候选键"><span class="nav-number">15.1.3.</span> <span class="nav-text">候选键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外-键"><span class="nav-number">15.1.4.</span> <span class="nav-text">外 键</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-视图的作用，视图可以更改么？"><span class="nav-number">16.</span> <span class="nav-text">MySQL 视图的作用，视图可以更改么？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#答案-15"><span class="nav-number">16.1.</span> <span class="nav-text">答案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-drop-delete与truncate的区别"><span class="nav-number">17.</span> <span class="nav-text">MySQL drop,delete与truncate的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#答案-16"><span class="nav-number">17.1.</span> <span class="nav-text">答案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-索引的工作原理及其种类"><span class="nav-number">18.</span> <span class="nav-text">MySQL 索引的工作原理及其种类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库索引"><span class="nav-number">18.1.</span> <span class="nav-text">数据库索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#局部性原理与磁盘预读"><span class="nav-number">18.2.</span> <span class="nav-text">局部性原理与磁盘预读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-Tree索引的性能分析"><span class="nav-number">18.3.</span> <span class="nav-text">B-&#x2F;+Tree索引的性能分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-数据库范式"><span class="nav-number">19.</span> <span class="nav-text">MySQL 数据库范式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一范式（1NF）"><span class="nav-number">19.1.</span> <span class="nav-text">第一范式（1NF）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二范式（2NF）"><span class="nav-number">19.2.</span> <span class="nav-text">第二范式（2NF）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三范式（3NF）"><span class="nav-number">19.3.</span> <span class="nav-text">第三范式（3NF）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-数据库优化的思路"><span class="nav-number">20.</span> <span class="nav-text">MySQL 数据库优化的思路</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-SQL语句优化"><span class="nav-number">20.1.</span> <span class="nav-text">1.SQL语句优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-索引优化"><span class="nav-number">20.2.</span> <span class="nav-text">2.索引优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#索引"><span class="nav-number">20.2.1.</span> <span class="nav-text">索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-不应该创建索引的的这些列："><span class="nav-number">20.2.2.</span> <span class="nav-text">2.不应该创建索引的的这些列：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在数据库中创建索引"><span class="nav-number">20.2.3.</span> <span class="nav-text">在数据库中创建索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用索引的代价"><span class="nav-number">20.2.4.</span> <span class="nav-text">使用索引的代价</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-数据库结构优化"><span class="nav-number">20.3.</span> <span class="nav-text">3.数据库结构优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-服务器硬件优化"><span class="nav-number">20.4.</span> <span class="nav-text">4.服务器硬件优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-存储过程与触发器的区别"><span class="nav-number">21.</span> <span class="nav-text">MySQL 存储过程与触发器的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-复制原理以及流程"><span class="nav-number">22.</span> <span class="nav-text">MySQL 复制原理以及流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#复制基本原理流程"><span class="nav-number">22.1.</span> <span class="nav-text">复制基本原理流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL复制的线程有几个及之间的关联"><span class="nav-number">22.2.</span> <span class="nav-text">MySQL复制的线程有几个及之间的关联</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL如何保证复制过程中数据一致性及减少数据同步延时"><span class="nav-number">22.3.</span> <span class="nav-text">MySQL如何保证复制过程中数据一致性及减少数据同步延时</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一致性主要有以下几个方面"><span class="nav-number">22.3.1.</span> <span class="nav-text">一致性主要有以下几个方面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#延时性"><span class="nav-number">22.3.2.</span> <span class="nav-text">延时性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工作遇到的复制-bug-的解决方法"><span class="nav-number">22.4.</span> <span class="nav-text">工作遇到的复制 bug 的解决方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-myisam与innodb的区别，至少5点"><span class="nav-number">23.</span> <span class="nav-text">MySQL myisam与innodb的区别，至少5点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问5点不同"><span class="nav-number">23.1.</span> <span class="nav-text">问5点不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#innodb引擎的4大特性"><span class="nav-number">23.2.</span> <span class="nav-text">innodb引擎的4大特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2者select-count-哪个更快，为什么"><span class="nav-number">23.3.</span> <span class="nav-text">2者select count(*)哪个更快，为什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-者的索引的实现方式"><span class="nav-number">23.4.</span> <span class="nav-text">2 者的索引的实现方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL中varchar与char的区别以及varchar-50-中的50代表的涵义"><span class="nav-number">24.</span> <span class="nav-text">MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-varchar与char的区别"><span class="nav-number">24.1.</span> <span class="nav-text">(1)varchar与char的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-varchar-50-中50的涵义"><span class="nav-number">24.2.</span> <span class="nav-text">(2)varchar(50)中50的涵义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-int（20）中20的涵义"><span class="nav-number">24.3.</span> <span class="nav-text">(3)int（20）中20的涵义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-mysql为什么这么设计"><span class="nav-number">24.4.</span> <span class="nav-text">(4)mysql为什么这么设计</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-innodb的事务与日志的实现方式"><span class="nav-number">25.</span> <span class="nav-text">MySQL innodb的事务与日志的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-有多少种日志"><span class="nav-number">25.1.</span> <span class="nav-text">(1)有多少种日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-日志的存放形式"><span class="nav-number">25.2.</span> <span class="nav-text">(2)日志的存放形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-事务是如何通过日志来实现的，说得越深入越好"><span class="nav-number">25.3.</span> <span class="nav-text">(3)事务是如何通过日志来实现的，说得越深入越好</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-binlog的几种日志录入格式以及区别"><span class="nav-number">26.</span> <span class="nav-text">MySQL binlog的几种日志录入格式以及区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-各种日志格式的涵义"><span class="nav-number">26.1.</span> <span class="nav-text">(1)各种日志格式的涵义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-适用场景"><span class="nav-number">26.2.</span> <span class="nav-text">(2)适用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-结合第一个问题，每一种日志格式在复制中的优劣"><span class="nav-number">26.3.</span> <span class="nav-text">(3)结合第一个问题，每一种日志格式在复制中的优劣</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-sql优化"><span class="nav-number">27.</span> <span class="nav-text">MySQL sql优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-explain出来的各种item的意义"><span class="nav-number">27.1.</span> <span class="nav-text">(1)explain出来的各种item的意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-profile的意义以及使用场景"><span class="nav-number">27.2.</span> <span class="nav-text">(2)profile的意义以及使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-explain-中的索引问题"><span class="nav-number">27.3.</span> <span class="nav-text">(3)explain 中的索引问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-备份计划，mysqldump以及xtranbackup的实现原理"><span class="nav-number">28.</span> <span class="nav-text">MySQL 备份计划，mysqldump以及xtranbackup的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-备份计划"><span class="nav-number">28.1.</span> <span class="nav-text">(1)备份计划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-备份恢复时间"><span class="nav-number">28.2.</span> <span class="nav-text">(2)备份恢复时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-备份恢复失败如何处理"><span class="nav-number">28.3.</span> <span class="nav-text">(3)备份恢复失败如何处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysqldump和xtranbackup实现原理"><span class="nav-number">28.4.</span> <span class="nav-text">mysqldump和xtranbackup实现原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-500台db，在最快时间之内重启"><span class="nav-number">29.</span> <span class="nav-text">MySQL 500台db，在最快时间之内重启</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-innodb的读写参数优化"><span class="nav-number">30.</span> <span class="nav-text">MySQL innodb的读写参数优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-读取参数"><span class="nav-number">30.1.</span> <span class="nav-text">(1)读取参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-写入参数"><span class="nav-number">30.2.</span> <span class="nav-text">(2)写入参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-与IO相关的参数"><span class="nav-number">30.3.</span> <span class="nav-text">(3)与IO相关的参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-缓存参数以及缓存的适用场景"><span class="nav-number">30.4.</span> <span class="nav-text">(4)缓存参数以及缓存的适用场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？"><span class="nav-number">31.</span> <span class="nav-text">MySQL 你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"><span class="nav-number">32.</span> <span class="nav-text">MySQL 你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-InnoDB引擎的行锁是通过加在什么上完成-或称实现-的？为什么是这样子的？"><span class="nav-number">33.</span> <span class="nav-text">MySQL InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#答案-17"><span class="nav-number">33.1.</span> <span class="nav-text">答案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-表中有大字段X-例如：text类型-，且字段X不会经常更新，以读为主，请问您是选择拆成子表，还是继续放一起-写出您这样选择的理由"><span class="nav-number">34.</span> <span class="nav-text">MySQL 表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为主，请问您是选择拆成子表，还是继续放一起?写出您这样选择的理由</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#答案-18"><span class="nav-number">34.1.</span> <span class="nav-text">答案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL如何处理死锁"><span class="nav-number">35.</span> <span class="nav-text">MySQL如何处理死锁?</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、什么是死锁"><span class="nav-number">35.1.</span> <span class="nav-text">一、什么是死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、为什么会形成死锁"><span class="nav-number">35.2.</span> <span class="nav-text">二、为什么会形成死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#两阶段锁协议（2PL）"><span class="nav-number">35.2.1.</span> <span class="nav-text">两阶段锁协议（2PL）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、MySQL-如何处理死锁？"><span class="nav-number">36.</span> <span class="nav-text">三、MySQL 如何处理死锁？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁检测"><span class="nav-number">36.1.</span> <span class="nav-text">死锁检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回滚"><span class="nav-number">36.2.</span> <span class="nav-text">回滚</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、如何避免发生死锁"><span class="nav-number">36.3.</span> <span class="nav-text">四、如何避免发生死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#收集死锁信息："><span class="nav-number">36.3.1.</span> <span class="nav-text">收集死锁信息：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#减少死锁："><span class="nav-number">36.3.2.</span> <span class="nav-text">减少死锁：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#摘录"><span class="nav-number">37.</span> <span class="nav-text">摘录</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chen Yu"
      src="/images/head.jpeg">
  <p class="site-author-name" itemprop="name">Chen Yu</p>
  <div class="site-description" itemprop="description">自律给我自由</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Yu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
