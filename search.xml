<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>go/工作中遇到的问题</title>
    <url>/2020/12/01/go/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>此文章记录，go开发中遇到的一些问题</p>
<a id="more"></a>

<h2 id="go-httpClient-出现大量ESTABLISHED-TIME-WAIT"><a href="#go-httpClient-出现大量ESTABLISHED-TIME-WAIT" class="headerlink" title="go httpClient 出现大量ESTABLISHED ,TIME_WAIT"></a>go httpClient 出现大量ESTABLISHED ,TIME_WAIT</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>用户通过浏览器访问 go web 服务器A, A会通过httpClient 向服务器B发起http请求；</p>
<p>服务器A 工作一段时间后总会报连接不上服务器B，服务器B重启后，一切正常；</p>
<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>由于go httpClient默认使用的是长连接，请求服务器B后，连接并未被释放掉，导致服务器A经过一段时间后socket被占满。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>golang http客户端在发送http请求的时候，需要头信息中声明本次使用的是http短链接。 </p>
<h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tr :&#x3D; &amp;http.Transport&#123;</span><br><span class="line">    DisableKeepAlives: true,&#x2F;&#x2F;禁用长连接</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="beegoOrm-或者gorm-如何向数据库中插入nil"><a href="#beegoOrm-或者gorm-如何向数据库中插入nil" class="headerlink" title="beegoOrm 或者gorm 如何向数据库中插入nil"></a>beegoOrm 或者gorm 如何向数据库中插入nil</h2><p>默认情况下 orm 会将字段零值插入数据库</p>
<h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><p>定义字段为指针类型</p>
<h2 id="go-常用工具"><a href="#go-常用工具" class="headerlink" title="go 常用工具"></a>go 常用工具</h2><ul>
<li>go vet main.go  打印检查</li>
<li>go run -race main.go  竞态检查</li>
<li>go build -ldflags “-s -w” -a -v -o main -trimpath main.go  减小执行程序大小， 原理，剥离调试代码 <blockquote>
<p>终极压缩： upx -9 main.go</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu 下面 安装upx-ucl :sudo apt install upx-ucl</span><br><span class="line">压缩 ： upx-ucl -9 main.go</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li>go编译exe程序<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGO_ENABLED&#x3D;0 GOOS&#x3D;windows GOARCH&#x3D;amd64 go build  -ldflags &quot;-s -w&quot; -a -v -o createtest.exe -trimpath main.go </span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line">## linux 交叉编译  windows</span><br><span class="line">1.需要安装gcc-mingw-w64</span><br></pre></td></tr></table></figure>
sudo apt-get install gcc-mingw-w64<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.执行编译</span><br></pre></td></tr></table></figure>
#带黑窗口<br>CGO_ENABLED=1 GOOS=windows GOARCH=amd64 CC=x86_64-w64-mingw32-gcc go build</li>
</ul>
<p>#不带黑窗口<br>CGO_ENABLED=1 GOOS=windows GOARCH=amd64 CC=x86_64-w64-mingw32-gcc go build -ldflags=”-H windowsgui” </p>
<pre><code></code></pre>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>疑难杂症</tag>
      </tags>
  </entry>
  <entry>
    <title>android/ubuntu安装AndroidSDK和NDK</title>
    <url>/2020/11/30/android/ubuntu%E5%AE%89%E8%A3%85AndroidSDK%E5%92%8CNDK/</url>
    <content><![CDATA[<h1 id="安装java"><a href="#安装java" class="headerlink" title="安装java"></a>安装java</h1><p>参考:<br><a href="https://medium.com/@barcelos.ds/install-openjdk-11-lts-in-the-ubuntu-20-04-lts-2c06f17c990" target="_blank" rel="noopener">https://medium.com/@barcelos.ds/install-openjdk-11-lts-in-the-ubuntu-20-04-lts-2c06f17c990</a></p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://adoptopenjdk.net" target="_blank" rel="noopener">https://adoptopenjdk.net</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir ~&#x2F;DevTools</span><br><span class="line">sudo mkdir ~&#x2F;DevTools&#x2F;JDK</span><br><span class="line">sudo tar -zxvf ~&#x2F;下载&#x2F;OpenJDK11U-jdk***tar.gz -C ~&#x2F;DevTools&#x2F;JDK&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="设置JAVA-HOME环境变量"><a href="#设置JAVA-HOME环境变量" class="headerlink" title="设置JAVA_HOME环境变量"></a>设置JAVA_HOME环境变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo  vim ~&#x2F;.profile</span><br><span class="line"></span><br><span class="line">DEV_TOOLS&#x3D;&quot;&#x2F;home&#x2F;$USER&#x2F;DevTools&quot;</span><br><span class="line">JAVA_HOME&#x3D;&quot;$DEV_TOOLS&#x2F;JDK&#x2F;jdk-11.0.7+10&quot;</span><br><span class="line">export JAVA_HOME</span><br><span class="line">PATH&#x3D;&quot;$JAVA_HOME&#x2F;bin:$PATH&quot;</span><br><span class="line"></span><br><span class="line">source ~&#x2F;.profile</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#JRE</span><br><span class="line">java --version</span><br><span class="line"></span><br><span class="line">#JDK</span><br><span class="line">javac --version</span><br></pre></td></tr></table></figure>


<h1 id="安装Android-SDK"><a href="#安装Android-SDK" class="headerlink" title="安装Android SDK"></a>安装Android SDK</h1><p>参考:<br><a href="https://medium.com/@barcelos.ds/install-android-sdk-in-the-ubuntu-20-04-lts-without-android-studio-1b629924d6c5" target="_blank" rel="noopener">https://medium.com/@barcelos.ds/install-android-sdk-in-the-ubuntu-20-04-lts-without-android-studio-1b629924d6c5</a></p>
<h2 id="下载命令行工具"><a href="#下载命令行工具" class="headerlink" title="下载命令行工具"></a>下载命令行工具</h2><p>网址：<a href="https://developer.android.com/studio" target="_blank" rel="noopener">https://developer.android.com/studio</a><br><img src="/2020/11/30/android/ubuntu%E5%AE%89%E8%A3%85AndroidSDK%E5%92%8CNDK/command-tools.png" alt></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir ~&#x2F;DevTools</span><br><span class="line">sudo mkdir -P ~&#x2F;DevTools&#x2F;Android&#x2F;cmdline-tools&#x2F;latest</span><br></pre></td></tr></table></figure>

<h2 id="解压放至于-DevTools-Android-cmdline-tools-latest"><a href="#解压放至于-DevTools-Android-cmdline-tools-latest" class="headerlink" title="解压放至于  ~/DevTools/Android/cmdline-tools/latest"></a>解压放至于  ~/DevTools/Android/cmdline-tools/latest</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="设置ANDROID-HOME环境变量"><a href="#设置ANDROID-HOME环境变量" class="headerlink" title="设置ANDROID_HOME环境变量"></a>设置ANDROID_HOME环境变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo  vim ~&#x2F;.profile</span><br><span class="line"></span><br><span class="line">DEV_TOOLS&#x3D;&quot;&#x2F;home&#x2F;$USER&#x2F;DevTools&quot;</span><br><span class="line">JAVA_HOME&#x3D;&quot;$DEV_TOOLS&#x2F;JDK&#x2F;jdk-11.0.7+10&quot;</span><br><span class="line">ANDROID_HOME&#x3D;&quot;$DEV_TOOLS&#x2F;Android&quot;</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export ANDROID_HOME</span><br><span class="line">PATH&#x3D;&quot;$JAVA_HOME&#x2F;bin:$ANDROID_HOME&#x2F;cmdline-tools&#x2F;latest&#x2F;bin:$ANDROID_HOME&#x2F;platform-tools:$PATH&quot;</span><br><span class="line"></span><br><span class="line">source ~&#x2F;.profile</span><br></pre></td></tr></table></figure>

<h2 id="Install-Platform-for-Android-29"><a href="#Install-Platform-for-Android-29" class="headerlink" title="Install Platform for Android 29"></a>Install Platform for Android 29</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sdkmanager &quot;platform-tools&quot; &quot;platforms;android-29&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Install-Build-Tools-for-Android-29"><a href="#Install-Build-Tools-for-Android-29" class="headerlink" title="Install Build Tools for Android 29"></a>Install Build Tools for Android 29</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sdkmanager &quot;build-tools&quot; &quot;build-tools;29.0.3&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Accept-Android-Licenses"><a href="#Accept-Android-Licenses" class="headerlink" title="Accept Android Licenses"></a>Accept Android Licenses</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sdkmanager --licenses</span><br></pre></td></tr></table></figure>

<h2 id="Update-Android-Packages-when-necessary"><a href="#Update-Android-Packages-when-necessary" class="headerlink" title="Update Android Packages when necessary:"></a>Update Android Packages when necessary:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sdkmanager --update</span><br></pre></td></tr></table></figure>

<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sdkmanager --version</span><br><span class="line">sdkmanager --list</span><br></pre></td></tr></table></figure>

<h1 id="安装NDK"><a href="#安装NDK" class="headerlink" title="安装NDK"></a>安装NDK</h1><h2 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a>官网下载</h2><p><a href="https://developer.android.com/ndk/downloads/index.html" target="_blank" rel="noopener">https://developer.android.com/ndk/downloads/index.html</a></p>
<h2 id="解压到-DevTools-Android"><a href="#解压到-DevTools-Android" class="headerlink" title="解压到 ~/DevTools/Android"></a>解压到 ~/DevTools/Android</h2><h2 id="设置ANDROID-NDK"><a href="#设置ANDROID-NDK" class="headerlink" title="设置ANDROID_NDK"></a>设置ANDROID_NDK</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo  vim ~&#x2F;.profile</span><br><span class="line"></span><br><span class="line">DEV_TOOLS&#x3D;&quot;&#x2F;home&#x2F;$USER&#x2F;DevTools&quot;</span><br><span class="line">JAVA_HOME&#x3D;&quot;$DEV_TOOLS&#x2F;JDK&#x2F;jdk-11.0.9.1+1&quot;</span><br><span class="line">ANDROID_HOME&#x3D;&quot;$DEV_TOOLS&#x2F;Android&quot;</span><br><span class="line"></span><br><span class="line">export JAVA_HOME</span><br><span class="line">export ANDROID_HOME</span><br><span class="line">export ANDROID_NDK&#x3D;$ANDROID_HOME&#x2F;android-ndk-r21b</span><br><span class="line"></span><br><span class="line">export GOPATH&#x3D;&#x2F;home&#x2F;yu&#x2F;go</span><br><span class="line">export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin:$GOPATH&#x2F;bin:$JAVA_HOME&#x2F;bin:$ANDROID_HOME&#x2F;cmdline-tools&#x2F;latest&#x2F;bin:$ANDROID_HOME&#x2F;platform-tools:$ANDROID_NDK</span><br><span class="line">export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go</span><br><span class="line">export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn</span><br><span class="line"></span><br><span class="line">source ~&#x2F;.profile</span><br></pre></td></tr></table></figure>

<h2 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ndk-build -v</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>docker/mysql</title>
    <url>/2020/11/12/docker/mysql/</url>
    <content><![CDATA[<h1 id="docker-安装mysql"><a href="#docker-安装mysql" class="headerlink" title="docker 安装mysql"></a>docker 安装mysql</h1><h2 id="单机版"><a href="#单机版" class="headerlink" title="单机版"></a>单机版</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it -d -p 3306:3306 --name docker_mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456  --restart&#x3D;always  mysql</span><br></pre></td></tr></table></figure>

<p>docker run -it -d -p 33063:3306 –name mysql5.6.47-1 -e MYSQL_ROOT_PASSWORD=123456  –restart=always  mysql:5.6.47 </p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker-install-ware</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>docker/zookeeper</title>
    <url>/2020/10/23/docker/zookeeper/</url>
    <content><![CDATA[<h1 id="docker-安装zookeeper"><a href="#docker-安装zookeeper" class="headerlink" title="docker 安装zookeeper"></a>docker 安装zookeeper</h1><h2 id="单机版"><a href="#单机版" class="headerlink" title="单机版"></a>单机版</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 2181:2181 --name some-zookeeper --restart&#x3D;always zookeeper</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker-install-ware</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>docker/kafak</title>
    <url>/2020/10/23/docker/kafak/</url>
    <content><![CDATA[<h1 id="docker-安装kafak"><a href="#docker-安装kafak" class="headerlink" title="docker 安装kafak"></a>docker 安装kafak</h1><h2 id="单机版"><a href="#单机版" class="headerlink" title="单机版"></a>单机版</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 2181:2181 -p 9092:9092 --env ADVERTISED_HOST&#x3D;192.168.11.36 --env ADVERTISED_PORT&#x3D;9092 -d spotify&#x2F;kafka</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker-install-ware</tag>
        <tag>kafak</tag>
      </tags>
  </entry>
  <entry>
    <title>docker/consul</title>
    <url>/2020/10/23/docker/consul/</url>
    <content><![CDATA[<h1 id="docker-安装consul"><a href="#docker-安装consul" class="headerlink" title="docker 安装consul"></a>docker 安装consul</h1><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8500 http 端口，用于 http 接口和 web ui</span><br><span class="line">8300 server rpc 端口，同一数据中心 consul server 之间通过该端口通信</span><br><span class="line">8301 serf lan 端口，同一数据中心 consul client 通过该端口通信</span><br><span class="line">8302 serf wan 端口，不同数据中心 consul server 通过该端口通信</span><br><span class="line">8600 dns 端口，用于服务发现</span><br><span class="line">-bbostrap-expect 2: 集群至少两台服务器，才能选举集群leader</span><br><span class="line">-ui：运行 web 控制台</span><br><span class="line">-bind： 监听网口，0.0.0.0 表示所有网口，如果不指定默认为127.0.0.1，则无法和容器通信</span><br><span class="line">-client ： 限制某些网口可以访问</span><br></pre></td></tr></table></figure>

<h2 id="单机版"><a href="#单机版" class="headerlink" title="单机版"></a>单机版</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name consul -d -p 8500:8500 -p 8300:8300 -p 8301:8301 -p 8302:8302 -p 8600:8600 consul agent -server -bootstrap-expect 1 -ui -bind&#x3D;0.0.0.0 -client&#x3D;0.0.0.0</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker-install-ware</tag>
        <tag>consul</tag>
      </tags>
  </entry>
  <entry>
    <title>docker/redis</title>
    <url>/2020/10/23/docker/redis/</url>
    <content><![CDATA[<h1 id="docker-安装redis"><a href="#docker-安装redis" class="headerlink" title="docker 安装redis"></a>docker 安装redis</h1><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>appendonly 是否开启数据持久化</li>
<li>requirepass 用户名密码 默认:不使用<h2 id="单机版"><a href="#单机版" class="headerlink" title="单机版"></a>单机版</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -d --restart&#x3D;always -v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;redis&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf  redis:latest redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf --appendonly yes --requirepass &quot;123456&quot;</span><br></pre></td></tr></table></figure>

<h2 id="主从版"><a href="#主从版" class="headerlink" title="主从版"></a>主从版</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -d --restart&#x3D;always -v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;redis&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf  redis:latest redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf --appendonly yes --requirepass &quot;123456&quot;</span><br><span class="line">docker run --name redis -p 6380:6379 -d --restart&#x3D;always -v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;redis&#x2F;redis-slave.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf  redis:latest redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf --appendonly yes --requirepass &quot;123456&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker-install-ware</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>go/设计模式(golang版本)</title>
    <url>/2020/10/19/go/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(golang%E7%89%88%E6%9C%AC)/</url>
    <content><![CDATA[<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>go 语言没有构造函数一说，所以一般会定义NewXXX函数来初始化相关类。 NewXXX 函数返回接口时就是简单工厂模式，也就是说Golang的一般推荐做法就是简单工厂。</p>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>工厂方法模式使用子类的方式延迟生成对象到子类中实现。<br>Go中不存在继承 所以使用匿名组合来实现<br>使用单独工厂接口是构造目标接口，</p>
]]></content>
  </entry>
  <entry>
    <title>photography/构图</title>
    <url>/2020/09/22/photography/%E6%9E%84%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="点构图"><a href="#点构图" class="headerlink" title="点构图"></a>点构图</h1><h2 id="中心点构图"><a href="#中心点构图" class="headerlink" title="中心点构图"></a>中心点构图</h2><p>画面主体放在中心点<br><img src="/2020/09/22/photography/%E6%9E%84%E5%9B%BE/%E4%B8%AD%E5%BF%83%E7%82%B9%E6%9E%84%E5%9B%BE.png" alt></p>
<h2 id="三分点构图"><a href="#三分点构图" class="headerlink" title="三分点构图"></a>三分点构图</h2><p>画面主体放在三分点<br>注意事项：有时会让画面不平衡，可以平衡画面<br><img src="/2020/09/22/photography/%E6%9E%84%E5%9B%BE/%E4%B8%89%E5%88%86%E7%82%B9%E6%9E%84%E5%9B%BE.png" alt></p>
<h1 id="线构图"><a href="#线构图" class="headerlink" title="线构图"></a>线构图</h1><h2 id="对称线构图"><a href="#对称线构图" class="headerlink" title="对称线构图"></a>对称线构图</h2><p>沿画面的水平或垂直居中线构图<br>常用于对称的物体，水面，对称建筑等<br><img src="/2020/09/22/photography/%E6%9E%84%E5%9B%BE/%E5%AF%B9%E7%A7%B0%E6%9E%84%E5%9B%BE.png" alt></p>
<h2 id="三分线构图"><a href="#三分线构图" class="headerlink" title="三分线构图"></a>三分线构图</h2><p>画面的水平或垂直元素，安排在三分线上<br>注意事项：水平三分线构图要留意强调的部分，垂直三分线构图拍摄人像注意人物朝向<br><img src="/2020/09/22/photography/%E6%9E%84%E5%9B%BE/%E4%B8%89%E5%88%86%E7%BA%BF%E6%9E%84%E5%9B%BE.png" alt></p>
<h2 id="对角线构图"><a href="#对角线构图" class="headerlink" title="对角线构图"></a>对角线构图</h2><p>利用照片对角线进行构图<br>注意事项：建议把画面主体聚焦在三分点上<br><img src="/2020/09/22/photography/%E6%9E%84%E5%9B%BE/%E5%AF%B9%E8%A7%92%E7%BA%BF%E6%9E%84%E5%9B%BE.png" alt></p>
<h2 id="曲线构图"><a href="#曲线构图" class="headerlink" title="曲线构图"></a>曲线构图</h2><p>利用自然存在的曲线或者人为制造的曲线进行构图<br><img src="/2020/09/22/photography/%E6%9E%84%E5%9B%BE/%E6%9B%B2%E7%BA%BF%E6%9E%84%E5%9B%BE.png" alt></p>
<h2 id="引导线构图"><a href="#引导线构图" class="headerlink" title="引导线构图"></a>引导线构图</h2><p>利用画面中的线条，把观众的目光引导到画面主体上<br>注意事项：引导到的主体建议处于画面中心点或者三分点<br><img src="/2020/09/22/photography/%E6%9E%84%E5%9B%BE/%E5%BC%95%E5%AF%BC%E7%BA%BF%E6%9E%84%E5%9B%BE.png" alt></p>
<h2 id="黄金分割构图"><a href="#黄金分割构图" class="headerlink" title="黄金分割构图"></a>黄金分割构图</h2><h1 id="面构图"><a href="#面构图" class="headerlink" title="面构图"></a>面构图</h1><h2 id="前景构图"><a href="#前景构图" class="headerlink" title="前景构图"></a>前景构图</h2><p>在画面中加入前景<br>注意事项：前景和画面主题有一定联系<br><img src="/2020/09/22/photography/%E6%9E%84%E5%9B%BE/%E5%89%8D%E6%99%AF%E6%9E%84%E5%9B%BE1.png" alt></p>
<h2 id="框架构图"><a href="#框架构图" class="headerlink" title="框架构图"></a>框架构图</h2><p>把例如门、窗等框架作为了一种前景<br><img src="/2020/09/22/photography/%E6%9E%84%E5%9B%BE/%E6%A1%86%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt></p>
<h2 id="填充构图"><a href="#填充构图" class="headerlink" title="填充构图"></a>填充构图</h2><p>让画面主体尽量填充满整个画面</p>
<h2 id="留白构图"><a href="#留白构图" class="headerlink" title="留白构图"></a>留白构图</h2><p>在画面中尽可能留白，做画面减法</p>
<h2 id="重复构图"><a href="#重复构图" class="headerlink" title="重复构图"></a>重复构图</h2><p>当画面中有比较多重复元素时，把画面中的元素进行重复排列<br>注意事项：重复构图中的元素排列最好基于某一种排列逻辑</p>
<h2 id="对比构图"><a href="#对比构图" class="headerlink" title="对比构图"></a>对比构图</h2><p>在重复的元素中运用某一种方式（颜色、动静、光影等）突出其中的某一个元素</p>
]]></content>
  </entry>
  <entry>
    <title>linux/ubuntu 安装各种软件</title>
    <url>/2020/09/21/linux/ubuntu%20%E5%AE%89%E8%A3%85%E5%90%84%E7%A7%8D%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h3><h4 id="deb包"><a href="#deb包" class="headerlink" title="deb包"></a>deb包</h4><p><a href="http://www.ubuntuchrome.com/" target="_blank" rel="noopener">http://www.ubuntuchrome.com/</a></p>
<h4 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo wget http://www.linuxidc.com/files/repo/google-chrome.list -P /etc/apt/sources.list.d/</span><br><span class="line">wget -q -O - https://dl.google.com/linux/linux_signing_key.pub  | sudo apt-key add -</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y google-chrome-stable</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb https://dl.yarnpkg.com/debian/ stable main"</span> | sudo tee /etc/apt/sources.list.d/yarn.list</span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install yarn</span><br></pre></td></tr></table></figure>
<h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install npm</span><br><span class="line"></span><br><span class="line">sudo npm install -g n <span class="comment">#通过n模块安装指定的nodejs</span></span><br><span class="line">sudo n stable <span class="comment">#安装官方稳定版本</span></span><br></pre></td></tr></table></figure>

<h3 id="pavucontrol-解决机箱前置耳机没声音"><a href="#pavucontrol-解决机箱前置耳机没声音" class="headerlink" title="pavucontrol(解决机箱前置耳机没声音)"></a>pavucontrol(解决机箱前置耳机没声音)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> sudo apt-get install pavucontrol</span><br><span class="line"><span class="comment"># 选择配置-》模拟立体声双工</span></span><br><span class="line"><span class="comment"># 输出设备-》模拟耳机</span></span><br></pre></td></tr></table></figure>

<h3 id="composer"><a href="#composer" class="headerlink" title="composer"></a>composer</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install composer </span><br><span class="line"></span><br><span class="line">composer config -g repo.packagist composer https://packagist.laravel-china.org <span class="comment">#laravel-china 社区镜像</span></span><br></pre></td></tr></table></figure>

<h3 id="lnmp"><a href="#lnmp" class="headerlink" title="lnmp"></a>lnmp</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libcurl4-gnutls-dev <span class="comment">#ubuntu18.04下先安这个curl扩展,不然php 中curl 请求https会报502</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://lnmp.org/auto.html 这里可以生成无人值守安装命令</span></span><br><span class="line">wget http://soft.vpser.net/lnmp/lnmp1.5.tar.gz -cO lnmp1.5.tar.gz &amp;&amp; tar zxf lnmp1.5.tar.gz &amp;&amp; <span class="built_in">cd</span> lnmp1.5 &amp;&amp; LNMP_Auto=<span class="string">"y"</span> DBSelect=<span class="string">"4"</span> DB_Root_Password=<span class="string">"root"</span> InstallInnodb=<span class="string">"y"</span> PHPSelect=<span class="string">"8"</span> SelectMalloc=<span class="string">"1"</span> ./install.sh lnmp</span><br></pre></td></tr></table></figure>
<h3 id="xx-net"><a href="#xx-net" class="headerlink" title="xx_net"></a>xx_net</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span> &amp;&amp; https://github.com/XX-net/XX-Net.git</span><br><span class="line">sudo apt-get install miredo <span class="comment">#开启ipv6</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://crxdl.com/" target="_blank" rel="noopener">需要的crx</a></p>
</blockquote>
<h4 id="ubuntu终端使用xx-net"><a href="#ubuntu终端使用xx-net" class="headerlink" title="ubuntu终端使用xx_net"></a>ubuntu终端使用xx_net</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo  apt install privoxy</span><br><span class="line"></span><br><span class="line">#XX-Net默认的端口是8087，对https代理  ,XX-Net默认的端口是8087，对http代理</span><br><span class="line">export https_proxy&#x3D;127.0.0.1:8087</span><br><span class="line">export http_proxy&#x3D;127.0.0.1:8087 </span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">curl https:&#x2F;&#x2F;www.google.com</span><br></pre></td></tr></table></figure>


<h3 id="Tim"><a href="#Tim" class="headerlink" title="Tim"></a>Tim</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/ &amp;&amp; sudo git <span class="built_in">clone</span> https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git &amp;&amp; <span class="built_in">cd</span> deepin-wine-for-ubuntu &amp;&amp; ./install.sh</span><br><span class="line">sudo apt-get install -f <span class="comment"># 如果提示依赖,执行这个</span></span><br><span class="line">wget https://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.office/deepin.com.qq.office_2.0.0deepin4_i386.deb   <span class="comment">#tim</span></span><br></pre></td></tr></table></figure>

<h3 id="supervisor-进程管理工具"><a href="#supervisor-进程管理工具" class="headerlink" title="supervisor(进程管理工具)"></a>supervisor(进程管理工具)</h3><p>Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install supervisor</span><br></pre></td></tr></table></figure>

<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version 	<span class="comment">#输出</span></span><br><span class="line">Command <span class="string">'java'</span> not found, but can be installed with:</span><br><span class="line">sudo apt install default-jre            </span><br><span class="line">sudo apt install openjdk-11-jre-headless</span><br><span class="line">sudo apt install openjdk-8-jre-headless </span><br><span class="line"></span><br><span class="line">sudo apt install default-jre  <span class="comment">#安装默认版本的java,ubuntu 默认安装的是java10.0.2</span></span><br></pre></td></tr></table></figure>

<h3 id="jmeter-apache压测工具"><a href="#jmeter-apache压测工具" class="headerlink" title="jmeter (apache压测工具)"></a>jmeter (apache压测工具)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install jmeter</span><br></pre></td></tr></table></figure>
<h3 id="系统托盘"><a href="#系统托盘" class="headerlink" title="系统托盘"></a>系统托盘</h3><p>安装 Gnome Shell 插件：TopIcons Plus</p>
<h3 id="golang-环境安装"><a href="#golang-环境安装" class="headerlink" title="golang 环境安装"></a>golang 环境安装</h3><p>1.到<a href="https://golang.org/dl/" target="_blank" rel="noopener">官网</a>下载最新的golang包，需要翻墙</p>
<p>2.将包解压到/usr/local下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tar -C /usr/<span class="built_in">local</span> -xzf go1.11.4.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
<p>3.将go执行命令放到环境变量中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim  ~/.profile</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span><br><span class="line"><span class="built_in">export</span> GOROOT=/usr/<span class="built_in">local</span>/go</span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.profile</span><br></pre></td></tr></table></figure>
<p>4.go version 测试是否安装成功</p>
<h3 id="protoc-安装"><a href="#protoc-安装" class="headerlink" title="protoc 安装"></a>protoc 安装</h3><ol>
<li>下载protoc包<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;releases&#x2F;tag&#x2F;v3.11.4</span><br></pre></td></tr></table></figure></li>
<li>解压<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo unzip protoc-3.11.4-linux-x86_64.zip -d &#x2F;usr&#x2F;local&#x2F;</span><br></pre></td></tr></table></figure></li>
<li>protoc-gen-go 编译插件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get -u github.com&#x2F;golang&#x2F;protobuf&#x2F;protoc-gen-go</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>protoc –go_out=plugins=grpc:. route_guide.proto</p>
</blockquote>
<h3 id="Wireshark-抓包工具"><a href="#Wireshark-抓包工具" class="headerlink" title="Wireshark 抓包工具"></a>Wireshark 抓包工具</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:wireshark-dev&#x2F;stable </span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt -y install wireshark</span><br></pre></td></tr></table></figure>

<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h4 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install docker.io</span><br><span class="line">sudo gpasswd -a $USER docker </span><br><span class="line">newgrp docker</span><br></pre></td></tr></table></figure>
<h4 id="更换docker远程镜像"><a href="#更换docker远程镜像" class="headerlink" title="更换docker远程镜像"></a>更换docker远程镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://9lrfffi7.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>

<h4 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo curl -L --fail https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.23.1&#x2F;run.sh -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br><span class="line">sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>

<h4 id="docker-machine"><a href="#docker-machine" class="headerlink" title="docker-machine"></a>docker-machine</h4><p><a href="https://docs.docker.com/machine/install-machine/" target="_blank" rel="noopener">官方网站</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base&#x3D;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;machine&#x2F;releases&#x2F;download&#x2F;v0.16.0 &amp;&amp;</span><br><span class="line">  curl -L $base&#x2F;docker-machine-$(uname -s)-$(uname -m) &gt;&#x2F;tmp&#x2F;docker-machine &amp;&amp;</span><br><span class="line">  sudo mv &#x2F;tmp&#x2F;docker-machine &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-machine &amp;&amp;</span><br><span class="line">  chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-machine</span><br></pre></td></tr></table></figure>

<h4 id="mysql-workbench"><a href="#mysql-workbench" class="headerlink" title="mysql-workbench"></a>mysql-workbench</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-workbench</span><br></pre></td></tr></table></figure>


<h2 id="安装nps-内网穿透"><a href="#安装nps-内网穿透" class="headerlink" title="安装nps 内网穿透"></a>安装nps 内网穿透</h2><ol>
<li>安装内网穿透服务端<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;nps &amp;&amp; &#x2F;usr&#x2F;local&#x2F;nps  &amp;&amp; wget https:&#x2F;&#x2F;github.com&#x2F;ehang-io&#x2F;nps&#x2F;releases&#x2F;download&#x2F;v0.26.8&#x2F;linux_amd64_server.tar.gz</span><br><span class="line">tar -zxf linux_amd64_server.tar.gz</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>photography/摄影入门</title>
    <url>/2020/09/21/photography/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="摄影"><a href="#摄影" class="headerlink" title="摄影"></a>摄影</h1><p>摄影是光与影的艺术<br>摄影的基础是控制光</p>
<h1 id="曝光"><a href="#曝光" class="headerlink" title="曝光"></a>曝光</h1><ul>
<li>照片过暗，曝光不足</li>
<li>照片过亮，曝光过度</li>
<li>照片细节指的是影像有质感，细节，明暗合理</li>
<li>亮有细节，暗有层次（亮处不能过曝，暗处不能漆黑一片）</li>
</ul>
<h2 id="曝光量受那些因素的影响"><a href="#曝光量受那些因素的影响" class="headerlink" title="曝光量受那些因素的影响"></a>曝光量受那些因素的影响</h2><ul>
<li>光圈 （大光圈，进光量大）</li>
<li>快门 （快门越慢，进光量大）</li>
<li>ISO (感光原件，感知光线的能力)</li>
</ul>
<h2 id="光圈-f"><a href="#光圈-f" class="headerlink" title="光圈(f)"></a>光圈(f)</h2><h3 id="影响进光量"><a href="#影响进光量" class="headerlink" title="影响进光量"></a>影响进光量</h3><p>光圈是一个用来控制进光量的装置，它通常在镜头内，单位大小f值常用f3.5、f5.6、f8、f11、f16、f22等系数，f值代表的是光圈的厚度，f值越小曝光量<br>越大，f值越大曝光量越小<br>单位: f3.5  </p>
<h3 id="影响景深的变化"><a href="#影响景深的变化" class="headerlink" title="影响景深的变化"></a>影响景深的变化</h3><p>大光圈拍摄景深浅，主体清晰背景模糊<br>小光圈拍摄景深长，主体和背景都很清晰  </p>
<h2 id="快门"><a href="#快门" class="headerlink" title="快门"></a>快门</h2><p>快门是控制进光时间的一个装置，开的越久，进来的光线越多<br>单位: 1/125秒  </p>
<ul>
<li>高快门凝固瞬间  </li>
<li>慢快门记录轨迹</li>
</ul>
<h3 id="曝光是如何控制的"><a href="#曝光是如何控制的" class="headerlink" title="曝光是如何控制的"></a>曝光是如何控制的</h3><p>快门越慢，时间越长，进光越多<br>慢快门需要三脚架支撑，手会抖</p>
<h2 id="ISO"><a href="#ISO" class="headerlink" title="ISO"></a>ISO</h2><p>ISO感光度是衡量传统相机所使用胶片感光速度标准的国际统一指标，其反应了胶片感光时的能力，而对于数码相机来说，其实不使用胶片，而是通过感光器件<br>CCD或CMOS以及相关的电子线路感应入射强弱。<br>感光度越高，感光能力越强，画质越粗糙，噪点多<br>感光度越低，感光能力弱，画质越细腻。<br>ISO越高，画质越差，噪点越多<br>当光圈快门没有办法控制进光量的时候，适当提高ISO,来增加照片的亮度。</p>
<h2 id="拍摄模式（曝光模式）"><a href="#拍摄模式（曝光模式）" class="headerlink" title="拍摄模式（曝光模式）"></a>拍摄模式（曝光模式）</h2><ul>
<li>M档–手动曝光模式</li>
<li>A（AV）档–光圈曝光模式，也叫光圈优先模式，指的是光圈可以人为手动控制，而快门相机会自动计算</li>
<li>S（TV）档–快门曝光模式，也叫快门优先模式，指的是快门可以人为手动控制，而光圈相机会自动计算</li>
<li>P档–自动曝光模式</li>
<li>A+档–全自动曝光模式<blockquote>
<p>除开以上几种外，一般称为傻瓜模式，由程序自动控制的模式。</p>
</blockquote>
</li>
</ul>
<p>光圈、快门、ISO共同决定一张影像相对正常的曝光，共同影响照片的曝光</p>
<h1 id="相机镜头的概念"><a href="#相机镜头的概念" class="headerlink" title="相机镜头的概念"></a>相机镜头的概念</h1><h2 id="按成像质量可以和方便性"><a href="#按成像质量可以和方便性" class="headerlink" title="按成像质量可以和方便性"></a>按成像质量可以和方便性</h2><ul>
<li>定焦镜头</li>
<li>变焦镜头</li>
</ul>
<h2 id="焦距"><a href="#焦距" class="headerlink" title="焦距"></a>焦距</h2><p>焦距越大，视角越小，镜头越长，拍摄的范围越小，拍的越远<br>焦距越小，视角越大，镜头越短，拍摄范围越大，拍的越近</p>
<h2 id="按焦距分镜头"><a href="#按焦距分镜头" class="headerlink" title="按焦距分镜头"></a>按焦距分镜头</h2><h3 id="广角-小于24mm"><a href="#广角-小于24mm" class="headerlink" title="广角 小于24mm"></a>广角 小于24mm</h3><p>取景范围大，多用于拍摄风光、建筑等</p>
<h3 id="标准-50mm（45-60）左右"><a href="#标准-50mm（45-60）左右" class="headerlink" title="标准 50mm（45-60）左右"></a>标准 50mm（45-60）左右</h3><p>和人眼的感觉相同适合拍摄标准人像、静物、产品等。</p>
<h3 id="中长焦-70-135mm"><a href="#中长焦-70-135mm" class="headerlink" title="中长焦 70-135mm"></a>中长焦 70-135mm</h3><p>适合拍摄人像</p>
<h3 id="长焦-大于135mm"><a href="#长焦-大于135mm" class="headerlink" title="长焦 大于135mm"></a>长焦 大于135mm</h3><p>取景范围小，适合拍摄动物、体育</p>
<h2 id="镜头的影响"><a href="#镜头的影响" class="headerlink" title="镜头的影响"></a>镜头的影响</h2><p>1.影响视角范围<br>2.影响景深  </p>
<ul>
<li>焦距越长；景深越浅，焦距越短，景深越深；</li>
<li>焦距越长，背景越虚化；焦距越短，背景越清晰</li>
</ul>
<h2 id="对焦模式"><a href="#对焦模式" class="headerlink" title="对焦模式"></a>对焦模式</h2><p>对焦点为成像清晰点</p>
<h3 id="AF（A）-自动对焦"><a href="#AF（A）-自动对焦" class="headerlink" title="AF（A） 自动对焦"></a>AF（A） 自动对焦</h3><p>佳能三种自动对焦模式  </p>
<ul>
<li><p>ONE SHOT (单次对焦模式) 半按快门释放键完成对焦后，若重新构图，对焦主体改变，将进行重新对焦。</p>
</li>
<li><p>AI SERVO（连续对焦模式） 半按快门释放键完成对焦后，若重新构图，对焦主体改变，将进行重新对焦。 有追焦的目的，试用于运动的物体</p>
</li>
<li><p>AI FOCUS (自动智能对焦模式)</p>
<h3 id="MF-M-手动对焦"><a href="#MF-M-手动对焦" class="headerlink" title="MF (M)手动对焦"></a>MF (M)手动对焦</h3><p>可以在任何的光线下按下快门的，也可以说对任何一种情况都能拍摄</p>
</li>
</ul>
<h2 id="单点对焦和区域对焦"><a href="#单点对焦和区域对焦" class="headerlink" title="单点对焦和区域对焦"></a>单点对焦和区域对焦</h2><p>在不知道选择对焦点的时候选择区域对焦</p>
<h3 id="单点对焦"><a href="#单点对焦" class="headerlink" title="单点对焦"></a>单点对焦</h3><p>单点对于个别拍摄比较多，成功率高<br>焦点在人身上，大光圈的情况下，背景虚化，人像清晰。<br>焦点对人眼睛上，</p>
<h2 id="白平衡"><a href="#白平衡" class="headerlink" title="白平衡"></a>白平衡</h2><h2 id="前景色和背景"><a href="#前景色和背景" class="headerlink" title="前景色和背景"></a>前景色和背景</h2><h3 id="前景"><a href="#前景" class="headerlink" title="前景"></a>前景</h3><ul>
<li>加强气氛</li>
<li>增加画面空间层次感</li>
<li>均衡画面</li>
</ul>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li>突出主题</li>
<li>丰富主题的内涵</li>
</ul>
<h1 id="常见摄影题材和摄影技法"><a href="#常见摄影题材和摄影技法" class="headerlink" title="常见摄影题材和摄影技法"></a>常见摄影题材和摄影技法</h1><h2 id="日出、日落"><a href="#日出、日落" class="headerlink" title="日出、日落"></a>日出、日落</h2><ol>
<li>开阔、地势高的地方</li>
</ol>
<h2 id="拍摄瀑布"><a href="#拍摄瀑布" class="headerlink" title="拍摄瀑布"></a>拍摄瀑布</h2><h3 id="使用高速快门（推荐）"><a href="#使用高速快门（推荐）" class="headerlink" title="使用高速快门（推荐）"></a>使用高速快门（推荐）</h3><p>使用高速快门凝结住飞溅的水花和奔流的场景（推荐）</p>
<h3 id="使用慢速快门"><a href="#使用慢速快门" class="headerlink" title="使用慢速快门"></a>使用慢速快门</h3><p>使用慢速快门拍摄雾状的水流和整体的水泻效果<br>使用慢门，需要在光线较弱的情况下使用,例如：<br>1.合适的天气<br>2.滤镜<br>3.低ISO</p>
]]></content>
  </entry>
  <entry>
    <title>algo/力扣-数组和字符串</title>
    <url>/2020/08/18/algo/%E5%8A%9B%E6%89%A3-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="集合、列表、数组"><a href="#集合、列表、数组" class="headerlink" title="集合、列表、数组"></a>集合、列表、数组</h2><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>由一个或多个确定的元素所构成的整体。<br>集合里的元素类型不一定相同<br>集合里的元素没有顺序  </p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>是一种数据项构成的有限序列，即按照一定的线性顺序，排列而成的数据项的集合。<br>列表最常见的表现形式有数组和链表，而我们熟悉的栈和队列则是两种特殊类型的列表。  </p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是列表的实现方式,数组有索引<br>数组中的元素在内存中是连续存储的，且每个元素占用相同大小的内存。</p>
<h3 id="寻找数组中心索引"><a href="#寻找数组中心索引" class="headerlink" title="寻找数组中心索引"></a>寻找数组中心索引</h3><p>给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。<br>我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。<br>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func pivotIndex(nums []int) int &#123;</span><br><span class="line">		total:&#x3D; 0</span><br><span class="line">	for i :&#x3D; 0; i &lt; len(nums); i++ &#123;</span><br><span class="line">		total+&#x3D;nums[i]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	preSum:&#x3D;0</span><br><span class="line">	for i :&#x3D; 0; i &lt; len(nums); i++ &#123;</span><br><span class="line">		if preSum*2 &#x3D;&#x3D; total-nums[i] &#123;</span><br><span class="line">			return i</span><br><span class="line">		&#125;</span><br><span class="line">		preSum+&#x3D;nums[i]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return -1</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>你可以假设数组中无重复元素。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func searchInsert(nums []int, target int) int &#123;</span><br><span class="line"></span><br><span class="line">	l:&#x3D;len(nums)</span><br><span class="line">	if l&#x3D;&#x3D; 0  || target&lt;nums[0]&#123;</span><br><span class="line">		return 0 </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if target&gt;nums[l-1] &#123;</span><br><span class="line">		return l</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for i:&#x3D;0;i&lt;l;i++ &#123;</span><br><span class="line">		if nums[i]&#x3D;&#x3D; target &#123;</span><br><span class="line">			return i</span><br><span class="line">		&#125;</span><br><span class="line">		preI:&#x3D;i-1</span><br><span class="line">		nextI:&#x3D; i+1</span><br><span class="line">		if preI&lt; 0 &#123;</span><br><span class="line">			preI&#x3D;0</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if nextI&gt;l-1 &#123;</span><br><span class="line">			nextI&#x3D;l-1</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if target&gt;&#x3D; nums[preI] &amp;&amp; target&lt;nums[nextI] &#123;</span><br><span class="line">			return i+1</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p>给出一个区间的集合，请合并所有重叠的区间。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func merge(intervals [][]int) [][]int &#123;</span><br><span class="line">    if len(intervals)&#x3D;&#x3D;0 &#123;</span><br><span class="line">        return intervals</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 先排序</span><br><span class="line">    sort.Slice(intervals, func(i,j int) bool&#123;</span><br><span class="line">		return intervals[i][0] &lt; intervals[j][0]</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">    merged :&#x3D; make([][]int, 1)</span><br><span class="line">    index :&#x3D; 0</span><br><span class="line">    for i, k :&#x3D; range intervals &#123;</span><br><span class="line">        if i &#x3D;&#x3D; 0 &#123;</span><br><span class="line">            merged[0] &#x3D; intervals[0]</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if k[0] &lt;&#x3D; merged[index][1] &#123;</span><br><span class="line">            if k[1] &gt; merged[index][1] &#123;</span><br><span class="line">                merged[index][1] &#x3D; k[1]</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            merged &#x3D; append(merged, k)</span><br><span class="line">            index +&#x3D; 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return merged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维数组简介"><a href="#二维数组简介" class="headerlink" title="二维数组简介"></a>二维数组简介</h2><p>可以将二维数据看成矩阵</p>
<h3 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h3><p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。<br>不占用额外内存空间能否做到？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func rotate(matrix [][]int) &#123;</span><br><span class="line"></span><br><span class="line">	n :&#x3D; len(matrix)</span><br><span class="line">	for i :&#x3D; 0; i &lt; n&#x2F;2; i++ &#123;</span><br><span class="line">		for j :&#x3D; i; j &lt;n-1-i; j++ &#123;</span><br><span class="line"></span><br><span class="line">			tmp :&#x3D; matrix[i][j]</span><br><span class="line">			matrix[i][j] &#x3D; matrix[n-1-j][i]</span><br><span class="line">			matrix[n-1-j][i] &#x3D; matrix[n-1-i][n-1-j]</span><br><span class="line">			matrix[n-1-i][n-1-j] &#x3D; matrix[j][n-1-i]</span><br><span class="line">			matrix[j][n-1-i] &#x3D; tmp</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="零矩阵"><a href="#零矩阵" class="headerlink" title="零矩阵"></a>零矩阵</h3><p>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func setZeroes(matrix [][]int)  &#123;</span><br><span class="line">	if len(matrix)&#x3D;&#x3D;0 &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m:&#x3D;len(matrix)</span><br><span class="line">	n:&#x3D;len(matrix[0])</span><br><span class="line"></span><br><span class="line">	needClearI:&#x3D;make(map[int]bool) &#x2F;&#x2F;需要置0的行</span><br><span class="line">	needClearJ:&#x3D;make(map[int]bool) &#x2F;&#x2F;需要置0的列</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	for i:&#x3D;0;i&lt;m;i++ &#123;</span><br><span class="line">		for j:&#x3D;0;j&lt;n;j++ &#123;</span><br><span class="line">			if matrix[i][j]&#x3D;&#x3D; 0 &#123;</span><br><span class="line">				needClearI[i]&#x3D;true</span><br><span class="line">				needClearJ[j]&#x3D;true</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for i:&#x3D;range needClearI &#123;</span><br><span class="line">		for j:&#x3D;0;j&lt;n;j++ &#123;</span><br><span class="line">			matrix[i][j]&#x3D;0</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for j:&#x3D;range needClearJ &#123;</span><br><span class="line">		for i:&#x3D;0;i&lt;m;i++ &#123;</span><br><span class="line">			matrix[i][j]&#x3D;0</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对角线遍历"><a href="#对角线遍历" class="headerlink" title="对角线遍历"></a>对角线遍历</h3><p>给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func findDiagonalOrder(matrix [][]int) []int &#123;</span><br><span class="line">	var (</span><br><span class="line">		res []int</span><br><span class="line">		&#x2F;&#x2F;d存放方向索引</span><br><span class="line">		x, y, d, m, n int</span><br><span class="line"></span><br><span class="line">		already map[[2]int]bool</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	if m &#x3D; len(matrix); m &#x3D;&#x3D; 0 &#123;</span><br><span class="line">		return res</span><br><span class="line">	&#125;</span><br><span class="line">	n &#x3D; len(matrix[0])</span><br><span class="line"></span><br><span class="line">	already &#x3D; make(map[[2]int]bool)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;4个方向, → ↙ ↓ ↗</span><br><span class="line">	dx :&#x3D; []int&#123;0, 1, 1, -1&#125;</span><br><span class="line">	dy :&#x3D; []int&#123;1, -1, 0, 1&#125;</span><br><span class="line"></span><br><span class="line">	for i :&#x3D; 0; i &lt; m*n; i++ &#123;</span><br><span class="line">		&#x2F;&#x2F;当前点</span><br><span class="line">		res &#x3D; append(res, matrix[x][y])</span><br><span class="line">		already[[2]int&#123;x, y&#125;]&#x3D;true</span><br><span class="line"></span><br><span class="line">		if i &#x3D;&#x3D; m*n-1 &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;寻找下一个点</span><br><span class="line">		a:&#x3D;x+dx[d]</span><br><span class="line">		b:&#x3D;y+dy[d]</span><br><span class="line">		for &#123;</span><br><span class="line">			if a &lt; 0 || a &gt;&#x3D; m || b &lt; 0 || b &gt;&#x3D; n || already[[2]int&#123;a, b&#125;] &#x3D;&#x3D; true &#123;</span><br><span class="line">				d &#x3D; (d + 1) % 4</span><br><span class="line"></span><br><span class="line">				a &#x3D; x + dx[d]</span><br><span class="line">				b &#x3D; y + dy[d]</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;找到了</span><br><span class="line">			x&#x3D;a</span><br><span class="line">			y&#x3D;b</span><br><span class="line">			if d&#x3D;&#x3D;0 || d&#x3D;&#x3D; 2 &#123;</span><br><span class="line">				d&#x3D;(d+1)%4</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return res</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串简介"><a href="#字符串简介" class="headerlink" title="字符串简介"></a>字符串简介</h2><p>字符串是由零个或多个字符组成的有限序列。一般记为 s = a1a2…an。它是编程语言中表示文本的数据类型。<br>连接操作:<br>对于不同的编程语言中，字符串可能是可变的，也可能是不可变的。不可变意味着一旦字符串被初始化，你就无法改变它的内容。  </p>
<ul>
<li>在某些语言（如 C ++）中，字符串是可变的。 也就是说，你可以像在数组中那样修改字符串。</li>
<li>在其他一些语言（如 Java、Python）中，字符串是不可变的。  </li>
</ul>
<p>由于字符串是不可变的，因此在连接时首先为新字符串分配足够的空间，复制旧字符串中的内容并附加到新字符串。因此，总时间复杂度将是O(N^2)  </p>
<h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func longestCommonPrefix(strs []string) string &#123;</span><br><span class="line">	l:&#x3D;len(strs)</span><br><span class="line">	if l &#x3D;&#x3D; 0 &#123;</span><br><span class="line">		return &quot;&quot;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if l &#x3D;&#x3D; 1 &#123;</span><br><span class="line">		return strs[0]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	i :&#x3D; 0</span><br><span class="line">	for i &lt; len(strs[0]) &#123;</span><br><span class="line">		simNum:&#x3D;0</span><br><span class="line">		for _, v :&#x3D; range strs &#123;</span><br><span class="line">			if len(v)-1&lt; i  || strs[0][i] !&#x3D; v[i] &#123;</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			simNum ++</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;每个字符串都有这个字符</span><br><span class="line">		if l !&#x3D; simNum &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return strs[0][:i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func longestPalindrome(s string) string &#123;</span><br><span class="line">	&#x2F;&#x2F;从中心扩散算法</span><br><span class="line">	var (</span><br><span class="line">		so    string &#x2F;&#x2F;输出回文长度</span><br><span class="line">		sl    int    &#x2F;&#x2F;字符串长度</span><br><span class="line">		maxL  int    &#x2F;&#x2F;最长回文长度</span><br><span class="line">		start int</span><br><span class="line">		end   int</span><br><span class="line">	)</span><br><span class="line">	sl &#x3D; len(s)</span><br><span class="line"></span><br><span class="line">	if sl &lt; 2 &#123;</span><br><span class="line">		return s</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for i :&#x3D; 0; i &lt; sl; i++ &#123;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;回文索引位置</span><br><span class="line">		if st,ed:&#x3D; palindromeLen(s,i-1, i+1);ed+1-st&gt; maxL &#123;</span><br><span class="line">			maxL&#x3D;ed+1-st</span><br><span class="line">			start&#x3D;st</span><br><span class="line">			end&#x3D;ed+1</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if st,ed:&#x3D; palindromeLen(s,i, i+1);ed+1-st&gt; maxL &#123;</span><br><span class="line">			maxL&#x3D;ed+1-st</span><br><span class="line">			start&#x3D;st</span><br><span class="line">			end&#x3D;ed+1</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	so &#x3D; s[start:end]</span><br><span class="line">	if so &#x3D;&#x3D; &quot;&quot; &#123;</span><br><span class="line">		return string(s[0])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return so</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> func palindromeLen(s string,pre int, next int) (start int,end int) &#123;</span><br><span class="line">	sl:&#x3D;len(s)</span><br><span class="line">	for &#123;</span><br><span class="line"></span><br><span class="line">		if pre &gt;&#x3D; 0 &amp;&amp; next &lt;&#x3D; sl-1 &amp;&amp; s[pre] &#x3D;&#x3D; s[next] &#123;</span><br><span class="line">			start&#x3D;pre</span><br><span class="line">			end&#x3D;next</span><br><span class="line">			pre--</span><br><span class="line">			next++</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		break</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h3><p>给定一个字符串，逐个翻转字符串中的每个单词。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func reverseWords(s string) string &#123;</span><br><span class="line"></span><br><span class="line">	words:&#x3D;[]string&#123;&#125;</span><br><span class="line">	word:&#x3D;&quot;&quot;</span><br><span class="line">	s+&#x3D;&quot; &quot;</span><br><span class="line">	for i:&#x3D;0;i&lt;len(s);i++ &#123;</span><br><span class="line">		&#x2F;&#x2F;一个字符串</span><br><span class="line">		if s[i]!&#x3D; &#39; &#39; &#123;</span><br><span class="line">			word+&#x3D;string(s[i])</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			if len(word) &gt; 0 &#123;</span><br><span class="line">				words&#x3D;append(words,word)</span><br><span class="line">			&#125;</span><br><span class="line">			word&#x3D;&quot;&quot; &#x2F;&#x2F;清空</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;翻转数组</span><br><span class="line">	for i:&#x3D;0;i&lt;len(words)&#x2F;2;i++ &#123;</span><br><span class="line">		j:&#x3D;len(words)-i-1</span><br><span class="line">		words[i],words[j]&#x3D;words[j],words[i]</span><br><span class="line">	&#125;</span><br><span class="line">	return  strings.Join(words,&quot; &quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串匹配算法：KMP"><a href="#字符串匹配算法：KMP" class="headerlink" title="字符串匹配算法：KMP"></a>字符串匹配算法：KMP</h3><p>KMP 算法的好处在于，它可以将时间复杂度降低到 O(m+n)O(m + n)O(m+n)，字符序列越长，该算法的优势越明显。<br>KMP算法可以做到指针不回溯，具体步骤:<br>1.计算模式串的next数组 (next 数组存的是模式串最长公共前后缀的长度)<br>2.利用next数组在指针i移动的时候快速跳跃到模式串的响应位置开始匹配</p>
<h3 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr"></a>实现 strStr</h3><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<h2 id="双指针技巧"><a href="#双指针技巧" class="headerlink" title="双指针技巧"></a>双指针技巧</h2><h3 id="双指针技巧-——-情景一"><a href="#双指针技巧-——-情景一" class="headerlink" title="双指针技巧 —— 情景一"></a>双指针技巧 —— 情景一</h3><p>使用双指针的典型场景之一是你想要 从两端向中间迭代数组。 两个指针的运动方向是相反的</p>
<h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。<br>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func reverseString(s []byte)  &#123;</span><br><span class="line">	l:&#x3D;len(s)</span><br><span class="line">	if l&#x3D;&#x3D; 0 &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	n:&#x3D;l&#x2F;2</span><br><span class="line">	for i:&#x3D;0;i&lt;n;i++ &#123;</span><br><span class="line">		s[i],s[l-1-i]&#x3D;s[l-1-i],s[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组拆分-I"><a href="#数组拆分-I" class="headerlink" title="数组拆分 I"></a>数组拆分 I</h3><p>给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func arrayPairSum(nums []int) int &#123;</span><br><span class="line">	res:&#x3D;0</span><br><span class="line">	&#x2F;&#x2F;排序</span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	for k,v:&#x3D;range nums &#123;</span><br><span class="line">		if k%2&#x3D;&#x3D; 0 &#123;</span><br><span class="line">			res+&#x3D;v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return res</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两数之和-II-输入有序数组"><a href="#两数之和-II-输入有序数组" class="headerlink" title="两数之和 II - 输入有序数组"></a>两数之和 II - 输入有序数组</h3><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。<br>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func twoSum(numbers []int, target int) []int &#123;</span><br><span class="line">	l:&#x3D;len(numbers)</span><br><span class="line">	left:&#x3D;0</span><br><span class="line">	right:&#x3D;l-1</span><br><span class="line"></span><br><span class="line">	for &#123;</span><br><span class="line">		if left &gt;&#x3D; right &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if numbers[left]+numbers[right]&#x3D;&#x3D; target &#123;</span><br><span class="line">			return []int&#123;left+1,right+1&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if numbers[left]+numbers[right]&gt; target &#123;</span><br><span class="line">			right--</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			left++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return []int&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双指针技巧-——-情景二"><a href="#双指针技巧-——-情景二" class="headerlink" title="双指针技巧 —— 情景二"></a>双指针技巧 —— 情景二</h3><p>有时，我们可以使用两个不同步的指针来解决问题，即快慢指针。与情景一不同的是，两个指针的运动方向是相同的，而非相反。<br>解决这类问题的关键是: 确定两个指针的移动策略。<br>有时可能需要在使用双指针技巧之前对数组进行排序，也可能需要运用贪心法则来决定你的运动策略。</p>
<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func removeElement(nums []int, val int) int &#123;</span><br><span class="line">	l :&#x3D; len(nums)</span><br><span class="line">	left :&#x3D; 0 &#x2F;&#x2F;慢指针</span><br><span class="line">	for i :&#x3D; 0; i &lt; l; i++ &#123;</span><br><span class="line">		if nums[i] !&#x3D; val &#123;</span><br><span class="line">			nums[left] &#x3D; nums[i]</span><br><span class="line">			left++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return left</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大连续1的个数"><a href="#最大连续1的个数" class="headerlink" title="最大连续1的个数"></a>最大连续1的个数</h3><p>给定一个二进制数组， 计算其中最大连续1的个数。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;双指针解法</span><br><span class="line">func findMaxConsecutiveOnes(nums []int) int &#123;</span><br><span class="line">	nums&#x3D;append(nums,0)</span><br><span class="line">	l:&#x3D;len(nums)</span><br><span class="line">	left:&#x3D;0</span><br><span class="line">	max:&#x3D;0</span><br><span class="line">	for i:&#x3D;0;i&lt;l;i++ &#123;</span><br><span class="line">		if nums[i]!&#x3D; 1 &#123;</span><br><span class="line">			if i-left&gt; max &#123;</span><br><span class="line">				max&#x3D;i-left</span><br><span class="line">			&#125;</span><br><span class="line">			left&#x3D;i+1 &#x2F;&#x2F;重置指针</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;直接计数， 效率更高</span><br><span class="line">func findMaxConsecutiveOnes3(nums []int) int &#123;</span><br><span class="line">	maxCount :&#x3D; 0</span><br><span class="line">	currentCount :&#x3D; 0</span><br><span class="line"></span><br><span class="line">	for i :&#x3D; range nums &#123;</span><br><span class="line">		num :&#x3D; nums[i]</span><br><span class="line">		if num &#x3D;&#x3D; 1 &#123;</span><br><span class="line">			currentCount++</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			currentCount &#x3D; 0</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if currentCount &gt; maxCount &#123;</span><br><span class="line">			maxCount &#x3D; currentCount</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return maxCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h3><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<p>示例：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func minSubArrayLen(s int, nums []int) int &#123;</span><br><span class="line">	l:&#x3D;len(nums)</span><br><span class="line">	start:&#x3D;0</span><br><span class="line">	end:&#x3D;0</span><br><span class="line">	sum:&#x3D;0</span><br><span class="line">	minL:&#x3D;math.MaxInt32</span><br><span class="line"></span><br><span class="line">	for end&lt; l &#123;</span><br><span class="line">		if nums[end]&gt;&#x3D; s &#123;</span><br><span class="line">			return 1</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;先找到满足条件的位置</span><br><span class="line">		sum+&#x3D;nums[end]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		for sum&gt;&#x3D; s &#123;</span><br><span class="line">			minL&#x3D;min(minL,end-start+1)</span><br><span class="line"></span><br><span class="line">			sum-&#x3D;nums[start]</span><br><span class="line">			start++</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		end++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if minL&#x3D;&#x3D;math.MaxInt32 &#123;</span><br><span class="line">		return 0</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return minL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func min(a int,b int) int &#123;</span><br><span class="line">	if a&gt; b &#123;</span><br><span class="line">		return b</span><br><span class="line">	&#125;</span><br><span class="line">	return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>###　杨辉三角</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func generate(numRows int) [][]int &#123;</span><br><span class="line">	var res [][]int</span><br><span class="line">	for i :&#x3D; 0; i &lt; numRows; i++ &#123;</span><br><span class="line">		arr :&#x3D; make([]int, i+1)</span><br><span class="line">		for j :&#x3D; 0; j &lt;&#x3D; i; j++ &#123;</span><br><span class="line">			if j &#x3D;&#x3D; 0 || j &#x3D;&#x3D; i &#123;</span><br><span class="line">				arr[j] &#x3D; 1</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				arr[j] &#x3D; res[i-1][j-1] + res[i-1][j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		res &#x3D; append(res, arr)</span><br><span class="line">	&#125;</span><br><span class="line">	return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>algo/力扣-初级算法</title>
    <url>/2020/08/10/algo/%E5%8A%9B%E6%89%A3-%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h3><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。  </p>
<p>作答：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func removeDuplicates(nums []int) int &#123;</span><br><span class="line">	if len(nums)&lt;&#x3D; 1 &#123;</span><br><span class="line">		return len(nums)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	j:&#x3D;1</span><br><span class="line">	for i:&#x3D;1;i&lt;len(nums);i++ &#123;</span><br><span class="line">		if nums[i-1]&#x3D;&#x3D;nums[i] &#123;</span><br><span class="line">			continue</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			nums[j]&#x3D;nums[i]</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。  </p>
<p>作答：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func maxProfit(prices []int) int &#123;</span><br><span class="line">    	l:&#x3D;len(prices)</span><br><span class="line"></span><br><span class="line">	earn:&#x3D;0 &#x2F;&#x2F;赚到的钱</span><br><span class="line">	min:&#x3D;-1 &#x2F;&#x2F;当前低点的值</span><br><span class="line">	max:&#x3D;-1</span><br><span class="line">	for i:&#x3D;0;i&lt;l;i++ &#123;</span><br><span class="line">		next:&#x3D;i+1</span><br><span class="line">		pre:&#x3D;i-1</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;解决越界问题</span><br><span class="line">		if next&gt;l-1 &#123;</span><br><span class="line">			next&#x3D;l-1</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if pre&lt; 0 &#123;</span><br><span class="line">			pre&#x3D;0</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if prices[next]&gt;prices[i]&amp;&amp; prices[pre]&gt;&#x3D;prices[i] &#123;</span><br><span class="line">			min&#x3D;prices[i]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if prices[next]&lt;&#x3D;prices[i] &amp;&amp; prices[pre]&lt;prices[i]&#123;</span><br><span class="line"></span><br><span class="line">			max&#x3D;prices[i]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;检查高低点</span><br><span class="line">		if min!&#x3D;-1 &amp;&amp; max !&#x3D;-1 &#123;</span><br><span class="line">			earn+&#x3D;max-min</span><br><span class="line"></span><br><span class="line">			min&#x3D;-1</span><br><span class="line">			max&#x3D;-1</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	return earn</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h3><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func rotate(nums []int, k int)  &#123;</span><br><span class="line">	l:&#x3D;len(nums)</span><br><span class="line">	if l &#x3D;&#x3D; 0 &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	k&#x3D;k%l</span><br><span class="line">	copy(nums,append(nums[l-k:],nums[:l-k]...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a>存在重复元素</h3><p>给定一个整数数组，判断是否存在重复元素。<br>如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func containsDuplicate(nums []int) bool &#123;</span><br><span class="line">    	m:&#x3D;make(map[int]bool)</span><br><span class="line">        for _,v:&#x3D;range nums &#123;</span><br><span class="line">            if _,ok:&#x3D;m[v]; ok &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                m[v]&#x3D; true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return false</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
  </entry>
  <entry>
    <title>elasticsearch/docker安装elasticsearch7.7.0</title>
    <url>/2020/07/30/elasticsearch/docker%E5%AE%89%E8%A3%85elasticsearch7.7.0/</url>
    <content><![CDATA[<h1 id="docker安装elasticsearch7-7-0"><a href="#docker安装elasticsearch7-7-0" class="headerlink" title="docker安装elasticsearch7.7.0"></a>docker安装elasticsearch7.7.0</h1><h2 id="手动版安装"><a href="#手动版安装" class="headerlink" title="手动版安装"></a>手动版安装</h2><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull docker.elastic.co&#x2F;elasticsearch&#x2F;elasticsearch:7.7.0</span><br></pre></td></tr></table></figure>

<h3 id="运行elasticsearch"><a href="#运行elasticsearch" class="headerlink" title="运行elasticsearch"></a>运行elasticsearch</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name&#x3D;elastic770 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type&#x3D;single-node&quot; --network&#x3D;network_172_19 --ip&#x3D;172.19.0.101 -v &#x2F;var&#x2F;docker&#x2F;elastic&#x2F;data:&#x2F;data docker.elastic.co&#x2F;elasticsearch&#x2F;elasticsearch:7.7.0</span><br></pre></td></tr></table></figure>

<h3 id="安装ik分词插件"><a href="#安装ik分词插件" class="headerlink" title="安装ik分词插件"></a>安装ik分词插件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it elastic770 &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">.&#x2F;bin&#x2F;elasticsearch-plugin install https:&#x2F;&#x2F;github.com&#x2F;medcl&#x2F;elasticsearch-analysis-ik&#x2F;releases&#x2F;download&#x2F;v7.7.0&#x2F;elasticsearch-analysis-ik-7.7.0.zip</span><br></pre></td></tr></table></figure>

<h2 id="docker-compose安装"><a href="#docker-compose安装" class="headerlink" title="docker-compose安装"></a>docker-compose安装</h2><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM docker.elastic.co&#x2F;elasticsearch&#x2F;elasticsearch:7.7.0</span><br><span class="line">ENV VERSION&#x3D;7.7.0</span><br><span class="line"></span><br><span class="line"># https:&#x2F;&#x2F;github.com&#x2F;medcl&#x2F;elasticsearch-analysis-ik&#x2F;releases</span><br><span class="line">ADD https:&#x2F;&#x2F;github.com&#x2F;medcl&#x2F;elasticsearch-analysis-ik&#x2F;releases&#x2F;download&#x2F;v$&#123;VERSION&#125;&#x2F;elasticsearch-analysis-ik-$VERSION.zip &#x2F;tmp&#x2F;</span><br><span class="line"></span><br><span class="line">RUN &#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;bin&#x2F;elasticsearch-plugin install -b file:&#x2F;&#x2F;&#x2F;tmp&#x2F;elasticsearch-analysis-ik-$VERSION.zip</span><br><span class="line">RUN rm -rf &#x2F;tmp&#x2F;*</span><br></pre></td></tr></table></figure>

<h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3.5&#39;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">    elastic770:</span><br><span class="line">        build: .&#x2F;</span><br><span class="line">        container_name: elastic770</span><br><span class="line">        hostname: elastic770</span><br><span class="line">        volumes:</span><br><span class="line">        - .&#x2F;data:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data　　#这里将elasticsearch的数据文件映射本地，以保证下次如果删除了容器还有数据</span><br><span class="line">        environment:</span><br><span class="line">        - discovery.type&#x3D;single-node</span><br><span class="line">        ports:</span><br><span class="line">        - &quot;9200:9200&quot;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>micro/微服务手记</title>
    <url>/2020/07/22/micro/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%8B%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>微服务将单体应用系统拆分成多个分而治之的小应用,降低系统整体崩溃的风险性;同时也可根据这些小应用的不同需求调整实体机的性能</p>
<p>微服务主要缺点是将系统复杂化,但对于本身就复杂的系统,微服务受益会很高  </p>
<a id="more"></a>

<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>判定标准,使用微服务后开发和维护变得轻松了,而不是困难  </p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1.化繁为简,分散治理<br>2.服务间松耦合,服务内高内聚<br>3.服务可独立构建/部署/升级,局部更新<br>4.提高系统容错性,减少系统整体崩溃的概率<br>5.易于实现异构系统  </p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1.增加了运维部署的工作量与难度<br>2.增加了系统间调用逻辑的处理难度<br>3.日志更男收集和统计了<br>4.额外引入了一些非业务模块服务</p>
<h1 id="go-micro"><a href="#go-micro" class="headerlink" title="go-micro"></a>go-micro</h1><ul>
<li>服务发现: 支持服务注册与发现,底层支持etcd/consul/k8s</li>
<li>负载均衡: rpc服务间的请求调度均衡策略</li>
<li>同步通信: 基于RPC通信,支持单向/双向流通信模式</li>
<li>异步通信: 提供pub/sub通信模型的接口</li>
<li>高级接口: 比如服务发现,提供调用的接口是一致的</li>
</ul>
]]></content>
      <categories>
        <category>micro</category>
      </categories>
  </entry>
  <entry>
    <title>go/Mastering_Go</title>
    <url>/2020/06/16/go/Mastering_Go/</url>
    <content><![CDATA[<h1 id="第2章-Go内部机制"><a href="#第2章-Go内部机制" class="headerlink" title="第2章 Go内部机制"></a>第2章 Go内部机制</h1><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收是释放掉那些不再使用的内存空间的过程.</p>
<a id="more"></a>


<h2 id="golang-GC算法演变过程"><a href="#golang-GC算法演变过程" class="headerlink" title="golang GC算法演变过程"></a>golang GC算法演变过程</h2><table>
<thead>
<tr>
<th align="center">版本</th>
<th align="center">GC算法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">v1.1</td>
<td align="center">STW(stop the word)</td>
</tr>
<tr>
<td align="center">v1.3</td>
<td align="center">Mark STW,Sweep(标记清除)</td>
</tr>
<tr>
<td align="center">v1.5</td>
<td align="center">三色标记</td>
</tr>
<tr>
<td align="center">v1.8</td>
<td align="center">hybrid write barrier(三色标记基础上加入写屏障)</td>
</tr>
</tbody></table>
<h2 id="标记清除算法-mark-and-sweep"><a href="#标记清除算法-mark-and-sweep" class="headerlink" title="标记清除算法(mark and sweep)"></a>标记清除算法(mark and sweep)</h2><h3 id="主要包含两个步骤"><a href="#主要包含两个步骤" class="headerlink" title="主要包含两个步骤:"></a>主要包含两个步骤:</h3><p>1.找出不可达对象,然后做上标记<br>2.回收标记好的对象</p>
<blockquote>
<p>mark and sweep 算法在执行的时候,需要程序暂停,即stop the world</p>
</blockquote>
<h3 id="标记清除算法存在的问题"><a href="#标记清除算法存在的问题" class="headerlink" title="标记清除算法存在的问题"></a>标记清除算法存在的问题</h3><ul>
<li>stop the world 程序暂停,即程序会出现卡顿</li>
<li>标记需要扫描整个堆(heap)</li>
<li>清楚数据会产生heap碎片</li>
</ul>
<h2 id="三色标记清除算法"><a href="#三色标记清除算法" class="headerlink" title="三色标记清除算法"></a>三色标记清除算法</h2><p>三色标记清除算法背后的首要原则就是它把堆中的对象根据它们的颜色分到不同集合里面，颜色是根据算法进行标记的  </p>
<ul>
<li>黑色集合 指针指向白色集合。</li>
<li>白色集合中的对象允许有指针指向黑色集合,白色集合中的对象就是垃圾回收的候选对象。</li>
<li>灰色集合可能会有指针指向白色集合里的对象。</li>
</ul>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>每次堆中的指针被修改写屏障都会去执行。如果堆中对象的指针被修改，就意味着那个对象现在是可触达的，写屏障会把它标记为灰色并把它放到灰色集合中。<br>修改器 运行写屏障,从而保证黑色集合中没有任何元素的指针去指向白色集合中的元素。<br>写屏障直观作用有两个:<br>1.process新生成的内存对象会被直接标记成灰色<br>2.位于黑色集合中的内存对象引用了一个白色集合中的对象,写屏障会将白色集合的这个对象标记为灰色  </p>
<h3 id="三色标记过程"><a href="#三色标记过程" class="headerlink" title="三色标记过程"></a>三色标记过程</h3><p>1.首先：程序创建的对象都标记为白色。<br><img src="/2020/06/16/go/Mastering_Go/6328562-1021941531ecffc3.png" alt><br>2.gc开始：扫描所有可到达的对象，标记为灰色<br><img src="/2020/06/16/go/Mastering_Go/6328562-9ae46a88a13613ee.png" alt><br>3.从灰色对象中找到其引用对象标记为灰色，把灰色对象本身标记为黑色<br><img src="/2020/06/16/go/Mastering_Go/6328562-21bc289a81b75236.png" alt><br>4.监视对象中的内存修改，并持续上一步的操作，直到灰色标记的对象不存在<br><img src="/2020/06/16/go/Mastering_Go/6328562-e0535bd79c7996e8.png" alt><br>5.此时，gc回收白色对象。<br><img src="/2020/06/16/go/Mastering_Go/6328562-6c9ecb92555f14e2.png" alt><br>6.最后，将所有黑色对象变为白色，并重复以上所有过程。<br><img src="/2020/06/16/go/Mastering_Go/6328562-0c915b27be3f258d.png" alt></p>
<h3 id="gc和用户逻辑如何并行操作"><a href="#gc和用户逻辑如何并行操作" class="headerlink" title="gc和用户逻辑如何并行操作"></a>gc和用户逻辑如何并行操作</h3><p>标记-清除(mark and sweep)算法的STW(stop the world)操作，就是runtime把所有的线程全部冻结掉，所有的线程全部冻结意味着用户逻辑是暂停的。这样所有的对象都不会被修改了，这时候去扫描是绝对安全的。<br>Go如何减短这个过程呢？标记-清除(mark and sweep)算法包含两部分逻辑：标记和清除。<br>我们知道Golang三色标记法中最后只剩下的黑白两种对象，黑色对象是程序恢复后接着使用的对象，如果不碰触黑色对象，只清除白色的对象，肯定不会影响程序逻辑。所以：清除操作和用户逻辑可以并发。<br>标记操作和用户逻辑也是并发的，用户逻辑会时常生成对象或者改变对象的引用，那么标记和用户逻辑如何并发呢？<br><strong>process新生成对象的时候，GC该如何操作呢？不会乱吗？</strong><br>我们看如下图，在此状态下：process程序又新生成了一个对象，我们设想会变成这样：<br><img src="/2020/06/16/go/Mastering_Go/6328562-1306d93ef2c96426.png" alt><br>但是这样显然是不对的，因为按照三色标记法的步骤，这样新生成的对象A最后会被清除掉，这样会影响程序逻辑。<br>Golang为了解决这个问题，引入了写屏障这个机制。<br>写屏障：该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知。<br>通俗的讲：就是在gc跑的过程中，可以监控对象的内存修改，并对对象进行重新标记。(实际上也是超短暂的stw，然后对对象进行标记)<br>在上述情况中，新生成的对象，一律都标位灰色！<br><img src="/2020/06/16/go/Mastering_Go/6328562-75599afe8b517f5c.png" alt><br><strong>那么，灰色或者黑色对象的引用改为白色对象的时候，Golang是该如何操作的？</strong><br>看如下图，一个黑色对象引用了曾经标记的白色对象。<br><img src="/2020/06/16/go/Mastering_Go/6328562-57b2f544aa5ff318.png" alt><br>这时候，写屏障机制被触发，向GC发送信号，GC重新扫描对象并标位灰色。<br><img src="/2020/06/16/go/Mastering_Go/6328562-714367c5511b3cf4.png" alt><br>因此，gc一旦开始，无论是创建对象还是对象的引用改变，都会先变为灰色。</p>
<h3 id="Unsafe-Code"><a href="#Unsafe-Code" class="headerlink" title="Unsafe Code"></a>Unsafe Code</h3><p>Unsafe code是一种绕过go类型安全和内存安全检查的Go代码。</p>
<h3 id="defer-panic-recover"><a href="#defer-panic-recover" class="headerlink" title="defer panic recover"></a>defer panic recover</h3><ul>
<li>defer是一种栈结构,先入后出</li>
<li>panic 会终止Go程序的当前流程开始panicking,根据入栈顺序调用defer,若某个defer中,有recover,则捕获panic,程序回到正常执行流程</li>
<li>recover,在defer函数中直接调用recover才能捕获panic</li>
</ul>
<h1 id="Go基本数据类型"><a href="#Go基本数据类型" class="headerlink" title="Go基本数据类型"></a>Go基本数据类型</h1><h2 id="Go切片"><a href="#Go切片" class="headerlink" title="Go切片"></a>Go切片</h2><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片的底层是数组，这意味着Go为每一个切片创建一个底层数组<br>切片作为函数的形参时是传引用操作，传递的是指向切片的内存地址，这意味着在函数中对切片的任何操作都会在函数结束后体现出来。另外，函数中传递切片要比传递同样元素数量的数组高效，因为Go只是传递指向切片的内存地址，而非拷贝整个切片。  </p>
<h3 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h3><p>GoLang中的切片扩容机制，与切片的数据类型、原本切片的容量、所需要的容量都有关系，比较复杂。对于常见数据类型，在元素数量较少时，大致可以认为扩容是按照翻倍进行的。</p>
<h3 id="大切片问题"><a href="#大切片问题" class="headerlink" title="大切片问题"></a>大切片问题</h3><p>若果存在一个很大的切片,而只需要使用很少的一部分,应当将此部分拷贝出来,否则因为这一小部分,会导致改切片不能被GC回收,典型问题将大文件的内容读到切片中，但是你只是想使用其中一小部分。  </p>
<h3 id="字节切片"><a href="#字节切片" class="headerlink" title="字节切片"></a>字节切片</h3><p>字节切片的操作与其他类型的切片并没有什么区别，但是在输入输出中（网络，文件流等）使用的非常多  </p>
<h3 id="copy-函数"><a href="#copy-函数" class="headerlink" title="copy()函数"></a>copy()函数</h3><p>内建函数copy(dst,src) 会以cap(dst)和cap(src)中的最小值为复制长度。<br>如果目标dst没有容量,则拷贝不到任何内容<br>最新的go版本中(go1.13),copy 已经支持了数组和切片的相互拷贝</p>
<h3 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h3><p>如果你发现你的代码中出现很多多维切片，你就要考虑你的代码设计是否合理并且使用不需要多维切片的更简单的设计。</p>
<h2 id="Go-map"><a href="#Go-map" class="headerlink" title="Go map"></a>Go map</h2><p>与切片与数组相比，map（映射）的功能要强大的多，但是具有灵活性的同时也伴随着性能损耗，实现Go map往往需要更多的处理能力。但是不用担心，Go的内置数据结构是非常高效的，所以当你需要map的时候就尽情地去用吧！</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>const 定义的常量,特别是数字类型,在定义的时候没有明确类型的化,那么该常量的类型在真正被使用的时候才会确定<br>严格来说,常量在编译期间就被确定了,所以定义成常量的值必须是编译器能够确定的值,在程序运行期间,不能修改的值<br>Go可以使用布尔类型、字符串、或者数字类型存储常量的值。<br>代码建议：如果你要用到许多常量，最好将它们定义到同一个包中。  </p>
<h2 id="go指针"><a href="#go指针" class="headerlink" title="go指针"></a>go指针</h2><p>使用指针时，<em>可以获取指针的值，此操作成为指针的解引用，</em>也叫取值操作符；&amp;可以获取非指针变量的地址，叫做取地址操作符。<br>变量=变量内存地址+变量值,以下代码可以很好的体现这个关系:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    var a int</span><br><span class="line">    var b *int</span><br><span class="line"></span><br><span class="line">    a&#x3D;5</span><br><span class="line">    b&#x3D;&amp;a</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;a变量指针:&quot;,&amp;a)</span><br><span class="line">    fmt.Println(&quot;a变量值:&quot;,a)</span><br><span class="line">    fmt.Println(&quot;b变量指针:&quot;,&amp;b)</span><br><span class="line">    fmt.Println(&quot;b变量值:&quot;,b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">a变量指针: 0xc000088010</span><br><span class="line">a变量值: 5</span><br><span class="line">b变量指针: 0xc00008c018</span><br><span class="line">b变量值: 0xc000088010</span><br></pre></td></tr></table></figure>

<h2 id="时间与日期的处理技巧"><a href="#时间与日期的处理技巧" class="headerlink" title="时间与日期的处理技巧"></a>时间与日期的处理技巧</h2><h3 id="解析时间"><a href="#解析时间" class="headerlink" title="解析时间"></a>解析时间</h3><p>time.Parse(layout string,value string)此函数用于字符串解析成golang时间类型,如果时间错误,将不能被解析 </p>
<h1 id="组合类型的使用"><a href="#组合类型的使用" class="headerlink" title="组合类型的使用"></a>组合类型的使用</h1><h2 id="使用new关键字"><a href="#使用new关键字" class="headerlink" title="使用new关键字"></a>使用new关键字</h2><p>new和make最大的区别就是：new返回的是空的内存地址，即没有做初始化。另外，make仅可以用来创建映射，切片和通道，而且并不是返回指针。</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go三色标记</tag>
      </tags>
  </entry>
  <entry>
    <title>http/Http权威指南</title>
    <url>/2020/06/11/http/Http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="第1章-HTTP概述"><a href="#第1章-HTTP概述" class="headerlink" title="第1章 HTTP概述"></a>第1章 HTTP概述</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><h3 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h3><ul>
<li>MIME(Multipurpose Internet Mail Extension,多用途英特网邮件扩展)</li>
<li>Web服务器回味所有的HTTP对象数据附加一个MIME类型，以告知Web浏览器该如何处理该对象</li>
<li>Content-Type:image/jpeg ,“image/jpeg”为MIME类型<a id="more"></a>

</li>
</ul>
<h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><ul>
<li>URI(Uniform Resource Identifier,统一资源标识符)</li>
<li>URI 有两种形式，分别称为URL和URN</li>
</ul>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><ul>
<li>统一资源定位符</li>
<li>URL包含三个部分,协议类型,服务器地址,资源地址</li>
<li>现在,几乎所有的URI都是URL</li>
<li>URL语法 : <scheme>://<user>:<password>@<host>:<port>/<path></path>;<params>?<query>#<frag></frag></query></params></port></host></password></user></scheme></li>
</ul>
<h3 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h3><ul>
<li>URN 统一资源名</li>
<li>URN是作为特定内容的唯一名称使用的,与目前资源所在地无关</li>
<li>P2P下载中使用的磁力链接是URN的一种实现，它可以持久化的标识一个BT资源，资源分布式的存储在P2P网络中，无需中心服务器用户即可找到并下载它。</li>
</ul>
<h2 id="Web的结构组件"><a href="#Web的结构组件" class="headerlink" title="Web的结构组件"></a>Web的结构组件</h2><ul>
<li>代理 位于客户端和服务端之间的HTTP中间实体</li>
<li>缓存 HTTP的仓库,使常用的页面或资源保存在离客户端更近的地方</li>
<li>网关 连接其他应用程序的特殊问web服务器</li>
<li>隧道 对HTTP通信报文进行盲转发的特殊代理</li>
<li>Agent代理 发起自动HTTP请求的半智能Web客户端</li>
</ul>
<h1 id="第3章-HTTP报文"><a href="#第3章-HTTP报文" class="headerlink" title="第3章 HTTP报文"></a>第3章 HTTP报文</h1><h2 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h2><ul>
<li>起始行(start line)</li>
<li>首部(header)</li>
<li>主体(body)</li>
</ul>
<h1 id="第4章-连接管理"><a href="#第4章-连接管理" class="headerlink" title="第4章 连接管理"></a>第4章 连接管理</h1><h2 id="用TCP套接字编程"><a href="#用TCP套接字编程" class="headerlink" title="用TCP套接字编程"></a>用TCP套接字编程</h2><ul>
<li>网络套接字 操作系统提供的操作TCP连接的工具</li>
</ul>
<h3 id="服务端套接字编程流程"><a href="#服务端套接字编程流程" class="headerlink" title="服务端套接字编程流程"></a>服务端套接字编程流程</h3><ol>
<li>创建套接字</li>
<li>绑定端口</li>
<li>监听端口</li>
<li>接收并处理消息</li>
</ol>
<h3 id="客户端套接字编程流程"><a href="#客户端套接字编程流程" class="headerlink" title="客户端套接字编程流程"></a>客户端套接字编程流程</h3><ol>
<li>创建套接字</li>
<li>连接服务端套接字</li>
<li>发送消息</li>
</ol>
<h2 id="性能聚焦区域"><a href="#性能聚焦区域" class="headerlink" title="性能聚焦区域"></a>性能聚焦区域</h2><p>###　TCP相关时延</p>
<ul>
<li>TCP连接建立握手</li>
<li>TCP慢启动拥塞控制</li>
<li>数据聚集的Nagle算法</li>
<li>用于捎带确认的TCP延迟确认算法</li>
<li>TIME_WAIT时延和端口耗尽</li>
</ul>
<h2 id="提高HTTP连接性能的方法"><a href="#提高HTTP连接性能的方法" class="headerlink" title="提高HTTP连接性能的方法"></a>提高HTTP连接性能的方法</h2><p>串行事务处理时延</p>
<ul>
<li>并行连接 通过多条TCP连接发起并发的HTTP请求</li>
<li>持久连接 重用TCP连接,以消除连接及关闭时延</li>
<li>管道化连接 通过共享TCP连接发起并发的HTTP请求</li>
<li>复用连接 交替传送请求和响应报文</li>
</ul>
<h3 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h3><p>打开大量连接会消耗很多内存资源<br>浏览器确实使用了并行连接,但他们会将并行连接的总数限制为一个较小的值(通常是4个). 服务器可以随意关闭来自特定客户端的超量连接</p>
<h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>在HTTP事务处理结束后仍然保持在打开状态的TCP连接被称为持久连接;持久连接会在不同事务之间保持打开状态,直到客户端或服务器决定将其关闭为止</p>
<h3 id="不能被代理转发或缓存响应使用的首部"><a href="#不能被代理转发或缓存响应使用的首部" class="headerlink" title="不能被代理转发或缓存响应使用的首部"></a>不能被代理转发或缓存响应使用的首部</h3><ul>
<li>Connection</li>
<li>Proxy-Authenticate</li>
<li>Proxy-Connection</li>
<li>Transfer-Encoding</li>
<li>Upgrade</li>
</ul>
<h2 id="持久连接-1"><a href="#持久连接-1" class="headerlink" title="持久连接"></a>持久连接</h2><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><p>HTTP/1.0 通过Connection:keep-alive 头部发送持久连接信号 ,服务端响应Connection:keep-alive表示支持持久连接,但是会存在一个盲中继问题<br>盲中继(哑代理)会导致,客户端保持TCP连接,服务端保持TCP连接,他们的TCP连接都是连接在代理上的,代理却什么都不知道</p>
<blockquote>
<p>只是将一个连接转发到另一个连接去,不对Connection首部进行特殊处理</p>
</blockquote>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p>HTTP/1.1使用persistent connection持久连接,改进了HTTP/1.0 中Connection:keep-alive的缺陷,HTTP/1.1中持久连接是默认激活的,要关闭则需要在报文首部显示添加Connection:close关闭持久连接</p>
<h3 id="持久连接的限制"><a href="#持久连接的限制" class="headerlink" title="持久连接的限制"></a>持久连接的限制</h3><ul>
<li>只有当连接上的所有报文都是正确的,自定义报文长度时,也就是说实体部分的长度和相应的Content-length一致,或则是用分块传输编码方式编码的,连接才能持久保持</li>
<li>HTTP/1.1的代理必须能够分别管理与客户端和服务端的持久连接,每个连接都只适用于一跳传输</li>
<li>一个用户客户端对任何服务器或代理最多维持两条持久连接,以防止服务器过载.</li>
</ul>
<h1 id="第5章-Web服务器"><a href="#第5章-Web服务器" class="headerlink" title="第5章 Web服务器"></a>第5章 Web服务器</h1>]]></content>
      <categories>
        <category>http</category>
      </categories>
  </entry>
  <entry>
    <title>linux/计算机原理+操作系统基础+计算机网络面试题</title>
    <url>/2020/06/04/linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80+%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="第二章-计算机主城原理之概述篇"><a href="#第二章-计算机主城原理之概述篇" class="headerlink" title="第二章 计算机主城原理之概述篇"></a>第二章 计算机主城原理之概述篇</h1><ul>
<li>计算机的发展历史大概可以分为几个阶段？每个阶段的计算机分别有什么特点？  <blockquote>
<p>四个阶段：电子管计算机、晶体管计算机、集成电路计算机、超大规模集成电路计算机。  </p>
</blockquote>
</li>
<li>你了解“摩尔定律”吗？“摩尔定律”对现代计算机产生了什么影响？<blockquote>
<p>摩尔定律：摩尔定律是由英特尔（Intel）创始人之一戈登·摩尔（Gordon Moore）提出来的。其内容为：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭示了信息技术进步的速度。尽管这种趋势已经持续了超过半个世纪，摩尔定律仍应该被认为是观测或推测，而不是一个物理或自然法。</p>
</blockquote>
<a id="more"></a>


</li>
</ul>
<ul>
<li>你了解冯诺依曼机吗？你是否可以大概描述冯诺依曼机的基本组成和工作原理？冯诺依曼机相对于之前的计算机有什么重要改进？<blockquote>
<p>冯诺依曼机有五大组成部分：输入设备、输出设备、运算器、存储器、控制器。冯诺依曼机把程序指令和运行数据存储起来，使得计算机从专用电路计算机发展成为通用电路计算机。</p>
</blockquote>
</li>
<li>什么是冯诺依曼瓶颈？冯诺依曼瓶颈对现代计算机产生了什么影响？<blockquote>
<p>冯诺依曼瓶颈指的是存储器和运算器之间的访问速率差异巨大，使得计算机性能无法提升。现代计算机以存储器为核心，根据局部性原理设计了存储器的层次结构，大幅提升计算机性能。</p>
</blockquote>
</li>
<li>你了解程序解释和程序翻译吗？什么是编译型语言，什么是解释型语言呢？<blockquote>
<p>编程语言可以分为解释型语言和编译型语言，程序解释指的是程序代码在运行时，逐行翻译成较低层次的编程语言去执行；程序翻译指的是程序代码在编译阶段提前翻译成较低层次的编程语言逻辑，在运行时直接运行。</p>
</blockquote>
</li>
<li>请你列举十种以上的编程语言，并分别分类他们属于什么类型的语言。<blockquote>
<p>译型语言：C、C++、Go、OC，解释型语言：Php、Python、Javascript、Perl、Lua，翻译+解释型语言：Java、C#、Kotlin等。</p>
</blockquote>
</li>
<li>你了解计算机的层次结构吗？今天的软件和硬件是怎么界定的。<blockquote>
<p>计算机的层次结构划分是为了方便理解计算机的整一个体系，在不同书籍或领域会有不一样的划分，没有绝对的正确。今天的软件、硬件的划分以硬件电路为界限，从涉及硬件电路逻辑往下的都归为硬件，要注意软件和硬件的划分也是与时俱进的，今天的软件很可能明天就变成了硬件，比如以前编写硬件逻辑代码是软件，而随着高级编程语言的出现和成熟，现在编写硬件逻辑代码已经视为硬件部分了。</p>
</blockquote>
</li>
<li>请你尝试说明高级语言、汇编语言和机器语言的区别和联系？<blockquote>
<p>高级语言是方便程序员描述程序逻辑的编程语言，与人类语言接近；汇编语言时方便程序员描述硬件逻辑的编程语言，与底层硬件接近；机器语言时方便计算机理解和运行的编程语言，一般程序员无法理解。</p>
</blockquote>
</li>
<li>CPU的速度一般使用什么做单位？它具有什么物理意义？<blockquote>
<p>赫兹，是国际单位制中频率的单位，它是每秒中的周期性变动重复次数的计量。1Hz = 1/s，即在单位时间内完成振动的次数，单位为赫兹（1赫兹=1次/秒）。</p>
</blockquote>
</li>
<li>网络的速度一般使用什么做单位？<blockquote>
<p>bps，比特率是指每秒传送的比特(bit)数。单位为 bps(Bit Per Second)，比特率越高，每秒传送数据就越多。</p>
</blockquote>
</li>
<li>20世纪80年代以前的计算机是不支持输入中文的，当时的计算机使用的是什么编码集？<blockquote>
<p>ASCII编码集。</p>
</blockquote>
</li>
<li>ASCII编码集占用多少个字节？<blockquote>
<p>ASCII有128个字符，占用7个比特位，扩展ASCII编码机占用8个比特位，一个字节。</p>
</blockquote>
</li>
<li>‘A’, ‘b’, ‘C’对应的ASCII十进制数值分别是多少？<blockquote>
<p>65、98、67。</p>
</blockquote>
</li>
<li>可以使用你熟悉的语言将 72、96、108转换为ASCII码吗？<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var c rune&#x3D;&#39;a&#39; </span><br><span class="line">var i int &#x3D;98</span><br><span class="line">i1:&#x3D;int(c)</span><br><span class="line">fmt.Println(&quot;&#39;a&#39; convert to&quot;,i1)</span><br><span class="line">c1:&#x3D;rune(i)</span><br><span class="line">fmt.Println(&quot;98 convert to&quot;,string(c1))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;string to rune</span><br><span class="line">for _, char :&#x3D; range []rune(&quot;世界你好&quot;) &#123;</span><br><span class="line">    fmt.Println(string(char))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>你知道Unicode编码和UTF-8编码的区别和联系吗？<blockquote>
<p>Unicode全名为：统一码、万国码，是计算机科学领域里的一项业界标准。Unicode标准有不同的编码实现，比如UTF-8、UTF-16、UTF-32，也即是可以有多种规则来实现Unicode标准，比如UTF-8使用的是不定长字节表示Unicode字符，在表示高位Unicode字符时可以自动扩展，UTF-32使用的是定长4个字节表示Unicode字符。</p>
</blockquote>
</li>
<li>假设有10000个汉字，6000个日本字，3000个韩国字，1000个特殊字符，如果让你设计一套通用的编码集，请问每个字至少几个比特位？<blockquote>
<p>10000+6000+3000+1000=20000个字符，最起码使用15个比特位，占2个字节。</p>
</blockquote>
</li>
</ul>
<h1 id="第3章-计算机组成原理之组成篇"><a href="#第3章-计算机组成原理之组成篇" class="headerlink" title="第3章 计算机组成原理之组成篇"></a>第3章 计算机组成原理之组成篇</h1><ul>
<li>计算机的总线就像是计算机的“高速公路”，你是否可以说出总线主要的功能和分类？<blockquote>
<p>总线可以分为：片内总线、系统总线，其中系统总线可以分为数据总线、地址总线、控制总线。</p>
</blockquote>
</li>
<li>什么是总线标准，为什么需要总线标准，现在有哪些常见的总线标准？<blockquote>
<p>总线标准是系统与各模块、模块与模块之间的一个互连的标准界面。总线标准有利于各模块高效使用总线。USB、PCIe等。</p>
</blockquote>
</li>
<li>常说的“IO设备”，“I”、“O”分别是什么的缩写？<blockquote>
<p>Input、Output，输入设备、输出设备。</p>
</blockquote>
</li>
<li>常见的输入设备可以分为什么种类？<blockquote>
<p>字符输入设备（键盘等）、图像输入设备（鼠标、数位板、扫描仪）。</p>
</blockquote>
</li>
<li>常见的输出设备可以分为什么种类？<blockquote>
<p>主要是图像输出设备（显示器），但在计算机远未普及的时候，显示器属于字符输出设备。</p>
</blockquote>
</li>
<li>日常常见的计算机外设（显示器、键盘、鼠标、打印机），分别属于什么设备？<blockquote>
<p>显示器、打印机属于输出设备，键盘、鼠标属于输入设备。</p>
</blockquote>
</li>
<li>输入输出接口一般需要完成什么工作，可以把接口的线路分为什么线路？<blockquote>
<p>数据线、状态线、命令线、地址线。</p>
</blockquote>
</li>
<li>DMA的全称是什么？<blockquote>
<p>DMA：Direct Memory Access，直接内存存取。</p>
</blockquote>
</li>
<li>程序中断和DMA相比，有什么优劣？<blockquote>
<p>程序中断和DMA都是计算机IO和低速设备的交互方式，程序中断方式实现简单，DMA方式效率更高。</p>
</blockquote>
</li>
<li>你是否可以清晰的表述计算机存储器的层次结构？存储器的层次结构是为了解决什么问题的？<blockquote>
<p>存储器的层次结构可以简单划分为：缓存-主存-辅存三个层次，缓存-主存主要是为了解决主存速度不够的问题；主存-辅存主要是为了解决主存容量不足的问题。</p>
</blockquote>
</li>
<li>什么是局部性原理，局部性原理对计算机存储系统的设计产生了什么影响？<blockquote>
<p>局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。</p>
</blockquote>
</li>
<li>计算机存储系统的每一个层次分别有什么特点？<blockquote>
<p>缓存：速度快、位价高；主存：速度适中、位价适中；辅存：速度慢、位价低。</p>
</blockquote>
</li>
<li>计算机的辅助存储器一般是指计算机硬盘，你了解计算机磁盘的物理结构吗？<blockquote>
</blockquote>
</li>
<li>磁盘的调度算法有哪些？分别有什么特点？<blockquote>
<p>先来先服务算法、最短寻道时间优先算法、扫描算法、循环扫描算法。</p>
</blockquote>
</li>
<li>计算机的主存一般是指计算机内存，内存有什么特点？<blockquote>
<p>容量比缓存大、比辅存小，访问速度比缓存慢，比辅存快，主存需要持续通电使用，停电时主存数据将会丢失。</p>
</blockquote>
</li>
<li>请解释概念：主存、辅存、Cache、RAM、ROM？<blockquote>
<p>主存：主存储器，即常说的计算机内存条，辅存：辅助存储器，即常说的磁盘、U盘、光盘、磁带等，Cache：高速缓存，即常说的L1、L2、L3缓存，CPU寄存器等，RAM：随机存取存储器（英语：Random Access Memory，缩写：RAM），ROM：只读存储器（Read Only Memory，缩写：ROM）。</p>
</blockquote>
</li>
<li>什么是字？什么是字块？<blockquote>
<p>字是指存放在一个存储单元中的二进制代码组合；字块是指存储在连续的存储单元中而被看作是一个单元的一组字。</p>
</blockquote>
</li>
<li>计算机的高速缓存一般是指Cache，Cache一般位于计算机的什么硬件设备上？<blockquote>
<p>在CPU上。</p>
</blockquote>
</li>
<li>一般使用什么指标去评估主存-高速缓存的性能？<blockquote>
<p>命中率。</p>
</blockquote>
</li>
<li>命中率是怎么定义的？<br><img src="/2020/06/04/linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80+%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/5e3975ac093e3e8608760255.png" alt></li>
<li>访问效率是怎么定义的？<br><img src="/2020/06/04/linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80+%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/5e3975b70947591b13630515.png" alt></li>
<li>假设CPU执行某段程序共计访问Cache命中4800次，访问主存200次，已知Cache的存取周期是30ns，主存的存取周期是150ns，求Cache-主存系统的平均访问时间和效率，试问该系统的性能提高了多少？<blockquote>
<p>平均访问时间：(480030+150200)/5000=34.8ns，命中率：4800/5000100%=96%，访问效率e：30/34.8100%=86.2%，性能提升：(150-34.8)/150*100%=76.8%。</p>
</blockquote>
</li>
<li>请描述LFU、LRU、FIFO缓存置换算法的过程。<blockquote>
</blockquote>
</li>
<li>计算机的指令一般由操作码和地址码组成，那么计算机指令可以分类为几种类型？<blockquote>
<p>移位操作指令、数据传输指令、控制指令、算术逻辑操作指令。</p>
</blockquote>
</li>
<li>对计算机指令数据的寻址有哪几种方式？<blockquote>
<p>立即寻址、直接寻址、间接寻址。</p>
</blockquote>
</li>
<li>计算机的运算器主要由什么组成？控制器呢？<blockquote>
<p>控制器主要由：程序计数器、时序发生器、指令译码器、寄存器、总线组成。运算器主要由：数据缓冲器、ALU、寄存器、状态字寄存器、总线组成。</p>
</blockquote>
</li>
<li>请简述计算机指令的执行过程。<blockquote>
</blockquote>
</li>
</ul>
<h1 id="第4章-计算机组成原理之计算篇"><a href="#第4章-计算机组成原理之计算篇" class="headerlink" title="第4章 计算机组成原理之计算篇"></a>第4章 计算机组成原理之计算篇</h1><ul>
<li>除了十进制以外，这个世界上常见的还有什么进制？<blockquote>
<p>二进制、八进制、十二进制、二十进制、六十进制。</p>
</blockquote>
</li>
<li>二进制一般使用什么方法转换成十进制？<blockquote>
<p>整数：按权展开法。</p>
</blockquote>
</li>
<li>十进制一般使用什么方法转换成二进制？<blockquote>
<p>整数：重复相除法，小数：重复相乘法。</p>
</blockquote>
</li>
<li>计算机直接使用原码计算有什么缺点？<blockquote>
<p>0有两种表示方法，减法运算复杂。</p>
</blockquote>
</li>
<li>请计算12、124、1023、-1、-127的二进制原码。<blockquote>
<p>12(0b1100)、124(0b1111100)、1023(0b1111111111)、-1(-0b1)、-127(-0b1111111)</p>
</blockquote>
</li>
<li>计算机的补码解决了什么问题？<blockquote>
<p>相比原码的运算过程（特别是减法），补码对于计算机而言运算更加简单。</p>
</blockquote>
</li>
<li>请计算12、124、1023、-1、-127的补码，并将其使用32位定点表示法和32位浮点表示法(1位符号位、8位阶码、23位数值位)表示出来。<blockquote>
</blockquote>
</li>
<li>你是否可以使用代码实现一个通用的计算器，可以将二进制数转换为十进制数，把十进制数转换为二进制数。<blockquote>
</blockquote>
</li>
<li>计算机为了判断运算溢出使用了什么方法？<blockquote>
</blockquote>
</li>
<li>什么是溢出？什么是上溢？什么是下溢？<blockquote>
<p>双符号位判断法。当双符号位不一致表示溢出。</p>
</blockquote>
</li>
<li>对于64位浮点型(double)，一般都是采用最高位为符号位，次高11位为指数位，其次52位为尾数，试求出double型所能表达的最大值和最小值。<blockquote>
<p>溢出即计算机无法表示数值。上溢是指数值绝对值大于表示范围，下溢是指计算机无法提供有效精度表示数值。</p>
</blockquote>
</li>
<li>浮点数相比定点数，有什么优势？有什么不足的地方。<blockquote>
<p>浮点数可以表示更大的数据范围，但是运算耗时更长。</p>
</blockquote>
</li>
<li>浮点数之间做加减法运算需要几个步骤？每个步骤都是必须的吗？为什么？<blockquote>
<p>浮点数加减法需要经过以下几个步骤：对阶、尾数求和、尾数规格化、舍入、溢出判断。对阶是为了使得尾数可以进行运算，阶码不一致尾数运算无效，尾数规格化、舍入是为了正确存储结果，溢出判断是为了判断运算过程是否有误，如果溢出将会发出信号进行溢出处理。</p>
</blockquote>
</li>
<li>x=0.1101^1001, y=0.1011^110，请计算x+y的值，x-y的值。<blockquote>
<p>x+y=0.1110011^1001，x-y=0.1011101^1001。</p>
</blockquote>
</li>
<li>x=0.1101^111, y=-0.1111^1101，请计算x+y的值，x-y的值。<blockquote>
<p>x+y=-0.1110110011^1101，x-y=0.1111001101^1101。</p>
</blockquote>
</li>
</ul>
<h1 id="第6章-操作系统之基础篇"><a href="#第6章-操作系统之基础篇" class="headerlink" title="第6章 操作系统之基础篇"></a>第6章 操作系统之基础篇</h1><ul>
<li>最早的计算机是没有操作系统的，操作系统的诞生解决了什么问题？<blockquote>
<p>操作系统的出现解决了计算机操作难度大、计算机资源利用效率低等问题。</p>
</blockquote>
</li>
<li>什么是批处理操作系统，它有什么特点？<blockquote>
<p>批处理操作系统的特点是批量输入任务，有效提升计算机资源利用率。</p>
</blockquote>
</li>
<li>什么是分时操作系统，它有什么特点？<blockquote>
<p>分时操作系统是指分时复用计算机资源的操作系统，可以多个用户使用一台计算机，多个程序分时共享计算机资源。</p>
</blockquote>
</li>
<li>操作系统主要功能是什么？<blockquote>
<p>操作系统统一的管理着计算机资源；操作系统实现了对计算机资源的抽象；操作系统提供了用户与计算机之间操作的接口。</p>
</blockquote>
</li>
<li>操作系统实现了对计算机资源的抽象，这里面的计算机资源主要包括什么？<blockquote>
<p>存储资源 、网络资源、计算资源等。</p>
</blockquote>
</li>
<li>操作系统提供了用户与计算机之间的接口，使得用户可以通过操作系统操作计算机，这个接口主要有几种形式？<blockquote>
<p>系统调用、命令行、图形窗口、应用程序等。</p>
</blockquote>
</li>
<li>什么是并行？什么是并发？并行和并发有什么区别和联系？<blockquote>
<p>并行是指两个或多个事件可以在同一个时刻发生；并发是指两个或多个事件可以在同一个时间间隔发生。</p>
</blockquote>
</li>
<li>操作系统的共享性对用户来说表现为什么？<blockquote>
<p>操作系统的共享性表现为计算机资源可以同时提供给多个用户、多道程序使用。</p>
</blockquote>
</li>
<li>对于计算机资源的共享，有哪两种形式？<blockquote>
<p>互斥共享、同时共享。</p>
</blockquote>
</li>
<li>什么是操作系统的虚拟性？<blockquote>
<p>操作系统的虚拟性是指操作系统可以把计算机的物理实体转变为若干个逻辑实体以提供多个用户、多道程序使用。</p>
</blockquote>
</li>
<li>什么是操作系统的异步性？它对我们的编程有什么实际意义？<blockquote>
<p>操作系统的异步性是指是指进程以不可预知的速度向前推进。内存中的每个进程何时执行,何时暂停,以怎样的速度向前推进,每道程序总共需要多少时间才能完成等，都是不可预知的。</p>
</blockquote>
</li>
<li>什么是操作系统的进程，操作系统的进程解决了什么问题？<blockquote>
<p>进程是操作系统进行计算机资源分配和调度的基本单位。有了进程，用户的逻辑程序才能够在操作系统中独立、正常的执行；并使得计算机资源可以高效利用。</p>
</blockquote>
</li>
<li>进程在计算机中是以什么形式存在的？<blockquote>
<p>进程在计算机中表现为一片存储空间，包含进程状态、进程优先级、程序计数器、内存指针、上下文数据、IO状态信息等一系列数据。</p>
</blockquote>
</li>
<li>PCB的全称是什么？它有什么作用？<blockquote>
<p>PCB的全称是进程控制快(Process Control Block)，PCB是系统中存放进程的管理和控制信息的数据结构，有了PCB，操作系统才可以控制进程的运行。</p>
</blockquote>
</li>
<li>什么是线程，线程与进程的关系和区别？<blockquote>
<p>线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
</blockquote>
</li>
<li>进程的五状态主要是哪五状态？你了解进程的生命周期吗？<blockquote>
<p>创建状态、就绪状态、阻塞状态、执行状态、终止状态。</p>
</blockquote>
</li>
<li>什么是生产者-消费者问题，你能够编程实现吗？<blockquote>
</blockquote>
</li>
<li>什么是哲学家进餐问题，你能够编程实现吗？<blockquote>
</blockquote>
</li>
<li>进程间同步一般有哪些方法，线程间同步呢？<blockquote>
<p>进程间同步的方法有：信号量、共享内存、消息队列、Unix域套接字等，线程间同步的方法有：互斥量、自旋锁、读写锁、条件变量的等方法。</p>
</blockquote>
</li>
<li>对于Linux来说，什么是前台进程、什么是后台进程、什么是守护进程？<blockquote>
<p>前台进程是指正在运行并且占用终端的进程；后台进程是指不占用终端的进程；守护进程是指一类特殊的后台进程，随系统引导而启动。</p>
</blockquote>
</li>
<li>进程的调度算法可以分为两大类，抢占式调度和非抢占式调度，对于抢占式调度，主要有什么算法？<blockquote>
<p>先来先服务调度算法、短进程优先调度算法、高优先权优先调度算法、时间片轮转调度算法。</p>
</blockquote>
</li>
<li>死锁的危害重大，什么是死锁，死锁是怎么产生的？<blockquote>
<p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。</p>
</blockquote>
</li>
<li>为了避免死锁，操作系统使用了什么算法？你了解这个算法的过程吗？<blockquote>
<p>银行家算法。</p>
</blockquote>
</li>
<li>什么是段？什么是页？什么是段页式存储管理？<blockquote>
<p>段是指连续不等长的一片内存，页是指连续等长的一片内存，段页式存储管理是将用户程序分成若干个段，再把每个段分成若干个页的内存管理方式。</p>
</blockquote>
</li>
<li>虚拟内存是什么？从根本上来说，虚拟内存解决了什么问题？<blockquote>
<p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>
</blockquote>
</li>
<li>虚拟内存有哪些的置换算法？<blockquote>
<p>FIFO算法、LRU算法、LFU算法</p>
</blockquote>
</li>
<li>请简述Buddy算法分配内存和回收内存的过程？<blockquote>
</blockquote>
</li>
<li>在Buddy算法里面，什么是Buddy（伙伴）？<blockquote>
<p>Buddy指的是两片内存连续、大小一样的内存片段。</p>
</blockquote>
</li>
<li>在计算机里面，文件可以分为有结构文件和无结构文件，你可以列举常见的有结构文件和无结构文件吗？<blockquote>
<p>有结构文件比如：Excel文件、Word文件、PDF文件、JPG文件等；无结构文件比如：exe文件、so文件、dll文件等。</p>
</blockquote>
</li>
<li>当为文件分配辅存空间时，一般有什么分配方式？<blockquote>
<p>连续分配、链接分配、索引分配。</p>
</blockquote>
</li>
<li>FAT文件系统对应的是辅存的哪种空间分配方式？<blockquote>
<p>链接分配方式。</p>
</blockquote>
</li>
<li>ext文件系统对应的是辅存的哪种空间分配方式？<blockquote>
<p>索引分配方式。</p>
</blockquote>
</li>
<li>在辅存中，一般使用什么样的数据结构来管理存储空间？<blockquote>
<p>位示图。</p>
</blockquote>
</li>
<li>文件目录树有什么作用？<blockquote>
<p>文件目录树使得任何一个文件或文件夹都有唯一的路径。</p>
</blockquote>
</li>
<li>文件描述信息包含哪些数据？<blockquote>
<p>文件标识符、文件类型、文件权限、文件长度、文件状态、索引节点等信息。</p>
</blockquote>
</li>
<li>Linux文件有哪几种类型？<blockquote>
<p>套接字文件、普通文件、目录文件、符号链接文件、设备文件、FIFO文件。</p>
</blockquote>
</li>
<li>ext文件系统可以看做是由一个Boot Sector和若干个Block Group组成，你能简要的描述Block Group由什么组成吗？<blockquote>
<p>一个Block Group由Super Block、Inode Bitmap、Block Bitmap、Inode Table、Data Block组成。</p>
</blockquote>
</li>
<li>什么是文件的Inode，Inode存储了文件的什么信息？<blockquote>
<p>每个文件或者文件夹都有一个Inode，Inode可以理解为是文件或文件夹的“身份证”，Inode存储着文件索引节点编号、文件类型、文件权限、文件物理地址的关键信息</p>
</blockquote>
</li>
<li>什么是SPOOLing技术？计算机中常说的“脱机”是什么意思？<blockquote>
<p>SPOOLing技术是关于慢速字符设备如何与计算机主机交换信息的一种技术，它利用高速共享设备将低速的独享设备模拟为高速的共享设备，使得逻辑上系统为每一个用户都分配了一台独立的高速独享设备。</p>
</blockquote>
</li>
</ul>
<h1 id="第9章-计算机网络之概述篇"><a href="#第9章-计算机网络之概述篇" class="headerlink" title="第9章 计算机网络之概述篇"></a>第9章 计算机网络之概述篇</h1><ul>
<li>计算机网络的七层模型从顶往下分别是什么？请按顺序列举出来。<blockquote>
<p>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p>
</blockquote>
</li>
<li>现在开发者更喜欢使用TCP/IP四层模型来划分计算机网络，为什么TCP/IP四层模型会取代OSI七层模型被广泛使用？<blockquote>
</blockquote>
</li>
<li>ARP协议、RARP协议属于计算机网络的哪一个层次？<blockquote>
<p>数据链路层。</p>
</blockquote>
</li>
<li>IP协议、ICMP协议属于计算机网络的哪一个层次？<blockquote>
<p>网络层。</p>
</blockquote>
</li>
<li>传输层最重要的两个协议是什么？<blockquote>
<p>TCP协议、UDP协议。</p>
</blockquote>
</li>
<li>常见的应用层协议有HTTP协议、FTP协议等，你还能列举一些常见的应用层协议吗？<blockquote>
<p>HTTP、FTP、SMTP、DNS、POP3、Telnet、TFTP、DHCP等。</p>
</blockquote>
</li>
<li>路由器工作在计算机网络的哪几个层次？<blockquote>
<p>物理层、数据链路层、网络层。</p>
</blockquote>
</li>
<li>现代网络设备互联的两种模式分别是什么？他们有什么特点？<blockquote>
<p>客户-服务端模式、对等连接模式。客户-服务端模式由服务端提供网络服务，客户端使用服务，常常表现为一个服务端，多个客户端的连接模式。对等连接模式不分客户端和服务端，只要两个主机都运行了对等连接软件（P2P软件），它们就可以进行平等的、对等连接通信。</p>
</blockquote>
</li>
<li>时延是判断计算机网络质量的重要标准，网络时延由哪几个部分组成？<blockquote>
<p>网络时延可以划分成发送时延、传播时延、排队时延、处理时延几个部分。</p>
</blockquote>
</li>
<li>物理层主要的作用是什么？<blockquote>
<p>物理层主要的作用是连接不同的网络设备并在网络设备之间传输比特流。</p>
</blockquote>
</li>
<li>请列举物理层常见的传输介质。<blockquote>
<p>有线传输（铜线、光纤），无线传输。</p>
</blockquote>
</li>
<li>什么是信道，什么是单工信道、半双工信道、全双工信道？<blockquote>
<p>什么是信道，什么是单工信道、半双工信道、全双工信道？信道是往一个方向传送信息的媒体，单工信道指的是只能发送或者接收的信道，半双工信道指的是双方都能发送和接收信息但是不能同时发送或同时接收的信道，全双工信道指的是双方可以自由发送和接收信息的信道。</p>
</blockquote>
</li>
<li>数据链路层的三个重要功能分别是什么？<blockquote>
<p>封装成帧、透明传输、差错检测。</p>
</blockquote>
</li>
<li>物理层只负责比特流的传输，这些数据在数据链路层称为什么？<blockquote>
<p>数据帧。</p>
</blockquote>
</li>
<li>为了界定区分一个单独的数据帧，数据链路层通常会做什么操作？<blockquote>
<p>在数据的头部和尾部加入特殊比特位。</p>
</blockquote>
</li>
<li>假设有数据00100101需要传输，目标机器接收到的数据为10100100，请问使用奇偶校验码是否可以检测出错误？<blockquote>
<p>不能，因为奇偶校验位只能检测单个比特位出现的错误。</p>
</blockquote>
</li>
<li>假设有数据1101011011需要传输，采用CRC的生成多项式为P(X)=X^4+X+1，请计算添加了CRC校验码之后的数据。<blockquote>
<p>多项式位串为：10011，模二除法得到余数1110，所以得到结果11010110111110。</p>
</blockquote>
</li>
<li>什么是MAC地址？如何查看本机的MAC地址？MAC地址有什么作用？<blockquote>
<p>MAC地址也称为物理地址、硬件地址，通过在windows系统下输入命令ipconfig可以查看网络设备的MAC地址，MAC地址使用48个比特位标记一个物理设备。</p>
</blockquote>
</li>
<li>请简述以太网的工作过程。MAC地址在其中起到了什么作用？<blockquote>
<p>以太网协议通过MAC地址和硬件接口的映射关系了解到通过具体哪个接口把数据发送给下一跳。</p>
</blockquote>
</li>
</ul>
<h1 id="第10章-计算机网络之网络层篇"><a href="#第10章-计算机网络之网络层篇" class="headerlink" title="第10章 计算机网络之网络层篇"></a>第10章 计算机网络之网络层篇</h1><ul>
<li>什么是IP地址，IP地址有什么特征？IP地址和MAC地址有什么区别和联系？<blockquote>
<p>IP地址是唯一标记互联网中计算机的标识，IP地址共占用4个字节，使用点分十进制表示。IP地址和MAC地址都是一种标识，IP地址标记网络中的计算机，MAC地址标记网络硬件设备。</p>
</blockquote>
</li>
<li>IP报文由IP头部和IP数据两个部分组成，IP头部一般占用多少个字节？<blockquote>
<p>IP头部一般占用20个字节。</p>
</blockquote>
</li>
<li>请简述IP头部包含哪些数据？<blockquote>
</blockquote>
</li>
<li>IP头部的TTL数据有什么作用？<blockquote>
<p>TTL占用一个字节，TTL表示IP数据包在网络中的寿命，当TTL为0时，网络设备将丢弃这个报文。</p>
</blockquote>
</li>
<li>网络层是怎么界定区分一个IP报文的？<blockquote>
<p>IP协议头部有个字段为报文总长度，占用16个比特位，网络层根据这个字段划分报文。</p>
</blockquote>
</li>
<li>路由表是网络层重要的数据结构，路由表有什么作用？<blockquote>
<p>路由表存储着目的地址和下一跳地址的映射关系，路由表是网络层可以正常工作的重要数据结构。</p>
</blockquote>
</li>
<li>ARP协议有什么作用？如何清理本机的ARP缓存？<blockquote>
<p>ARP协议全称是地址解析协议，即ARP（Address Resolution Protocol）。ARP协议可以将IP地址翻译成物理地址。在Windows系统下使用arp -d命令就可以清楚arp缓存。</p>
</blockquote>
</li>
<li>ARP协议的设计有一定的缺陷，请通过搜索引擎自行搜索了解利用ARP漏洞攻击的方法。<blockquote>
</blockquote>
</li>
<li>IP地址一共4Bytes，32bits，理论上可以表示多少个IP？<blockquote>
<p>理论上可以表示2的32次方个IP。</p>
</blockquote>
</li>
<li>为了科学的使用IP地址，早期的科学家把IP地址划分为A、B、C三类IP地址，这些IP地址有什么特点？<blockquote>
<p>IP地址可以分为网络号和主机号两个部分，A类地址网络号为8位，主机号为24位；B类地址网络号为16位，主机号为16位；C类地址网络号为24位，主机号为8位。</p>
</blockquote>
</li>
<li>A类地址理论上可以有多少个子网，每个子网理论上有多少个主机号？<blockquote>
<p>A类地址网络号为8位，其首位为0，故理论上可以表示2的7次方个网络，主机号为24位，每个子网可以有2的24次方个主机</p>
</blockquote>
</li>
<li>请列举特殊的网络号和特殊的主机号。<blockquote>
<p>主机号全0、主机号全1的IP地址为特殊的主机号，不可分配。</p>
</blockquote>
</li>
<li>如何计算一个IP的网络号是什么？<blockquote>
<p>使用子网掩码和IP地址进行按位与运算就可得到IP地址对应的网络号。</p>
</blockquote>
</li>
<li>一个网络的掩码是255.255.255.248，请问这个网络可以连接多少台主机？<blockquote>
<p>这个网络的主机号只有3位，最多可以表示8个主机，减去全0、全1两个特殊主机号，一共可以连接6台主机。</p>
</blockquote>
</li>
<li>网络地址转换技术(NAT)解决了什么问题？<blockquote>
<p>NAT技术解决网络IP地址不够用的问题。</p>
</blockquote>
</li>
<li>NAT技术的实现原理。<blockquote>
<p>NAT技术在网络设备中通过维护一个映射表，通过映射表可以将外部地址转换为内部地址。</p>
</blockquote>
</li>
<li>ICMP报文和IP报文一样，也是由头部和数据两个部分组成，请简述ICMP报文的头部字段。<blockquote>
<p>ICMP报文的头部字段由三个部分组成，分别是8位类型、8位代码和16位校验和。</p>
</blockquote>
</li>
<li>ICMP报文和IP报文由什么关系？ICMP报文是怎么样传输的。<blockquote>
<p>ICMP协议和IP协议虽然同为网络层协议，但是ICMP是不能单独传输的，ICMP报文需要传输时作为IP报文的数据进行传输。</p>
</blockquote>
</li>
<li>常见的利用ICMP协议的计算机应用有ping和traceroute，请简述这两个应用的功能，以及这两个应用是怎么利用ICMP协议完成工作的。<blockquote>
</blockquote>
</li>
<li>网络层路由可以抽象成一个图算法问题，按照网络的大小可以分为内部网关协议和外部网关协议，请列举与网络路由相关的算法。<blockquote>
<p>距离矢量算法、Dijkstra（迪杰斯特拉）算法。</p>
</blockquote>
</li>
<li>请简述RIP协议的过程。<blockquote>
</blockquote>
</li>
<li>RIP协议有什么优点和缺点？<blockquote>
<p>RIP协议具备着实现简单、开销小等优点，但是RIP协议本身的缺陷限制了网络的规模，并且在RIP协议中坏消息传的慢，更新收敛时间长， 这也使得RIP协议整体性能较差。</p>
</blockquote>
</li>
<li>请简述OSPF协议的过程，OSPF协议中起到重要的算法是什么算法？<blockquote>
<p>Dijkstra（迪杰斯特拉）算法。</p>
</blockquote>
</li>
<li>OSPF协议有什么优点和缺点？<blockquote>
<p>OSPF协议解决了RIP协议的问题，对整个网络有一定的“全局观”，但是OSPF协议本身较为复杂，实现开销较大。</p>
</blockquote>
</li>
<li>网络层有了RIP协议和OSPF协议，为什么还需要BGP协议？BGP协议解决了什么问题？<blockquote>
<p>BGP协议全称为边际网关协议(Border Gateway Protocol)，BGP协议是因为计算机网络中人为因素的复杂性而提出的，在实际网络环境中，数据的传输还受政治、安全等方面的影响。</p>
</blockquote>
</li>
</ul>
<h1 id="第11章-计算机网络之传输层"><a href="#第11章-计算机网络之传输层" class="headerlink" title="第11章 计算机网络之传输层"></a>第11章 计算机网络之传输层</h1><ul>
<li>传输层主要工作在什么地方？<blockquote>
<p>传输层主要工作在终端设备（手机、计算机、笔记本、平板电脑等）上。</p>
</blockquote>
</li>
<li>传输层最重要的两个协议是什么？<blockquote>
<p>TCP协议和UDP协议。</p>
</blockquote>
</li>
<li>端口是什么，端口有什么作用？端口在协议中一般占用几个字节？<blockquote>
<p>端口是为了标记不同的使用网络的进程，端口使用16个比特为表示。</p>
</blockquote>
</li>
<li>UDP协议的中文全称是什么？UDP协议有什么特点？请分点说明。<blockquote>
<p>UDP全称是用户数据报协议(User Datagram Protocol)，UDP是一个非常简单的传输层协议，他不能保证可靠的交付数据。</p>
</blockquote>
</li>
<li>UDP的报文和IP报文一样，也是由头部和数据两个部分组成，请绘制UDP头部的结构图。<blockquote>
</blockquote>
</li>
<li>TCP协议的中文全称是什么？TCP协议有什么特点？请分点说明。<blockquote>
<p>TCP全称是传输控制协议(Transmission Control Protocol)，TCp是面向连接的协议，TCP协议可以提供可靠的数据传输服务。</p>
</blockquote>
</li>
<li>TCP的报文和UDP、IP报文一样，也是由头部和数据两个部分组成，请绘制TCP头部的结构图。<blockquote>
</blockquote>
</li>
<li>TCP报文头部的序号和确认号都占据4个字节，序号有什么用？确认号呢？<blockquote>
<p>序号用于传输数据的编号，在TCP报文中一个字节一个序号。确认号表示期待收到的数据的首字节序号。</p>
</blockquote>
</li>
<li>TCP报文头部的数据偏移字段有什么用？他和TCP报文的结构有什么关系？<blockquote>
<p>数据偏移字段表示传输数据偏移TCP首部的距离，如果TCP报文中包含可选数据，则数据偏移字段起作用。</p>
</blockquote>
</li>
<li>TCP报文头部的标记占用6个比特位，每个比特位的值可以为1或0，他们分别有什么意义？<blockquote>
<p>6个比特位分别是URG、ACK、PSH、RST、SYN、FIN，URG表示紧急报文、ACK表示确认报文、PSH表示该报文尽快交付应用层、RST表示重置报文，重新建立连接、SYN表示连接请求报文、FIN表示释放连接报文。</p>
</blockquote>
</li>
<li>TCP报文头部的窗口占用2个字节，窗口字段有什么作用？<blockquote>
<p>窗口指明允许对方发送的数据量，用于控制TCP连接中数据传输的速率。</p>
</blockquote>
</li>
<li>TCP协议一个重要的特点是可靠传输，可靠传输是怎么实现的？请简要描述可靠传输的基本原理。<blockquote>
<p>可靠传输依赖于超时重传，即接收方需要发送确认消息给发送方，如果一定时间内发送方没有收到确认消息，则认为消息没有到达接收方，重新发送数据。</p>
</blockquote>
</li>
<li>TCP协议的流量控制和TCP报文头部的什么字段有关系？流量控制具体是怎么工作的？请简要描述流量控制的主要过程。<blockquote>
<p>TCP的流量控制和TCP头部的窗口字段有关系，流量控制根据TCP报文中窗口的大小来进行数据的传输，当窗口较大时，增加数据发送速度，当窗口较小时，降低数据发送速度。</p>
</blockquote>
</li>
<li>TCP协议具备拥塞控制的功能，拥塞控制和流量控制有什么区别？拥塞控制是怎么实现的？<blockquote>
<p>拥塞控制和流量控制是不一样的，流量控制强调TCP连接双方的发送-接收速率，拥塞控制强调网络环境的状态，TCP连接的发送方可以感知网络环境的状态并做出反应。发送端使用慢启动算法、拥塞避免算法、快重传算法、快恢复方法。</p>
</blockquote>
</li>
<li>TCP协议的三次握手是非常重要的知识点，TCP协议的三次握手和TCP报文头部的哪些字段有关系？<blockquote>
<p>序号、确认号、TCP标记ACK、SYN、FIN。</p>
</blockquote>
</li>
<li>请简述TCP协议三次握手的过程。<blockquote>
</blockquote>
</li>
<li>TCP协议的三次握手是TCP建立可靠通信的基础，请问为什么TCP连接建立的过程叫做三次握手，请陈述三次握手的必要性，两次握手为什么不行？<blockquote>
<p>两次握手不能保证连接正确建立，TCP被连接的一端有可能响应失效的请求报文而无法确认。</p>
</blockquote>
</li>
<li>TCP协议的四次挥手是非常重要的知识点，TCP协议的四次挥手和TCP报文头部的哪些字段有关系？<blockquote>
<p>序号、确认号、TCP标记ACK、SYN、FIN。</p>
</blockquote>
</li>
<li>请简述TCP协议四次挥手的过程，并说明清楚每一次挥手后，双方进入的状态。<blockquote>
</blockquote>
</li>
<li>TCP连接释放的过程中有一个重要概念叫做2MSL，什么是2MSL，它有什么作用？<blockquote>
<p>MSL指的是最长报文段寿命(Max Segment Lifetime)，2MSL保证ACK报文可以正确到达对方。</p>
</blockquote>
</li>
<li>TCP协议有四个重要的定时器，分别是什么定时器？请简述这些定时器的作用。<blockquote>
<p>超时定时器、坚持定时器、时间等待计时器、保活计时器。</p>
</blockquote>
</li>
<li>什么是套接字？你了解套接字的编程吗？请使用套接字实现一个简单的C/S通信工具。<blockquote>
<p>套接字是TCP连接双方的IP:端口对</p>
</blockquote>
</li>
</ul>
<h1 id="第12章-计算机网络之应用层篇"><a href="#第12章-计算机网络之应用层篇" class="headerlink" title="第12章 计算机网络之应用层篇"></a>第12章 计算机网络之应用层篇</h1><ul>
<li>应用层相对于其他层，是面向用户的一层，应用层协议主要解决了什么问题？<blockquote>
<p>应用层是七层OSI模型的第七层。应用层直接和应用程序接口并提供常见的网络应用服务。</p>
</blockquote>
</li>
<li>请列举5个以上的应用层协议。<blockquote>
<p>HTTP、FTP、SMTP、DNS、POP3、Telnet、TFTP、DHCP等。</p>
</blockquote>
</li>
<li>什么是域名？为什么需要域名？<blockquote>
<p>域名是指由一串用点分隔的名字组成的网络上上某一台计算机或计算机组的名称。域名主要是为了解决IP地址难以记忆而发明的。</p>
</blockquote>
</li>
<li>把域名解析成IP地址的服务叫做什么服务？它有什么特点。<blockquote>
<p>把域名解析成IP地址的服务叫做DNS服务，DNS服务呈树状结构。</p>
</blockquote>
</li>
<li>DHCP协议是应用层中重要的一个协议，DHCP协议主要干了什么工作？<blockquote>
<p>DHCP（动态主机配置协议）是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。</p>
</blockquote>
</li>
<li>HTTP协议是广泛使用的一个协议，也是最重要的应用层协议之一，HTTP协议解决了什么问题？<blockquote>
<p>HTTP（超文本传输协议）是一个基于C/S架构进行通信的网络协议，HTTP协议是互联网数据通信的基础。HTTP规范了客户端请求的格式和服务端回应的格式。</p>
</blockquote>
</li>
<li>HTTP地址有什么特点，一个完整的HTTP地址由哪几个部分组成？<blockquote>
<p>HTTP协议的地址由以下几个部分组成：http(s)://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p>
</blockquote>
</li>
<li>HTTP协议中常用的HTTP请求方法有什么？他们分别表示什么意思。<blockquote>
<p>GET、POST、DELETE、UPDATE等，GET方法通常表示从服务端获取数据、POST方法通常表示往服务端提交数据、DELETE方法通常表示删除服务端资源、UPDATE方法通常表示更新服务端资源</p>
</blockquote>
</li>
<li>HTTP服务的状态码由3位十进制数组成，主要可以分成几类呢？<blockquote>
<p><img src="/2020/06/04/linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80+%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/5e3977c5095f8b7910140335.png" alt></p>
</blockquote>
</li>
<li>一个浏览器在请求服务器时，拿到了404状态码的回应，请问是什么意思？<blockquote>
<p>404状态码为客户端错误状态码，表示客户端所请求的资源不存在。</p>
</blockquote>
</li>
<li>一个浏览器在请求服务器时，拿到了502状态码的回应，请问是什么意思？<blockquote>
<p>502状态码为服务端错误状态码，表示服务端网关网络错误。</p>
</blockquote>
</li>
<li>请简述HTTP请求报文的主要结构。<blockquote>
<p>HTTP请求报文由以下几个部分组成：请求行、请求头、请求内容三个部分组成，请求行包含请求方法、请求地址和HTTP协议版本。</p>
</blockquote>
</li>
<li>请简述HTTP应答报文的主要结构。<blockquote>
<p>HTTP应答报文由以下几个部分组成：应答行、应答头、应答内容三个部分组成，应答行包含HTTP协议版本、状态码、状态说明。</p>
</blockquote>
</li>
<li>什么是缓存，什么是Web缓存？<blockquote>
<p>缓存是指比一般存储更快的存储。Web缓存是为了加快客户端访问速度而设计的缓存，主要存储Web数据，当缓存命中时，可以有效加快客户端访问速度。</p>
</blockquote>
</li>
<li>Web代理在生成环境中应用非常广泛，一般使用Nginx来完成代理，请问什么是Web代理，Web代理有什么作用？<blockquote>
<p>Nginx可以提供反向代理服务，代理指的是在客户端和服务端之间设置代理中间人，Web代理可以提供隐匿源站IP、屏蔽后端网络拓扑，负载均衡等功能。</p>
</blockquote>
</li>
<li>什么是CDN，什么是爬虫？搜索引擎的本质是什么？<blockquote>
<p>CDN全称是Content Delivery Network，即内容分发网络。爬虫指的是按照一定规则在互联网中自动抓取信息的程序，搜索引擎本质就是爬虫。</p>
</blockquote>
</li>
<li>HTTPS是安全的HTTP协议，HTTPS应用了密码学的知识，其中就包括对称加密和非对称加密，请问什么是对称加密，什么是非对称加密？<blockquote>
<p>对称加密指的是加密和解密使用同样的密钥，非对称加密指的是加密和解密使用不一样的密钥。</p>
</blockquote>
</li>
<li>SSL为现代Web应用的安全作出了重要的贡献，请简述SSL握手的主要过程。<blockquote>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux习题</tag>
      </tags>
  </entry>
  <entry>
    <title>go/grpc笔记</title>
    <url>/2020/05/28/go/grpc%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="grpc笔记"><a href="#grpc笔记" class="headerlink" title="grpc笔记"></a>grpc笔记</h1><h2 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h2><h3 id="protoc-语言编译工具安装"><a href="#protoc-语言编译工具安装" class="headerlink" title="protoc 语言编译工具安装"></a>protoc 语言编译工具安装</h3><p>1.下载protoc包 <a href="https://github.com/protocolbuffers/protobuf/releases/tag/v3.11.4" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/releases/tag/v3.11.4</a><br>2.解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo unzip protoc-3.11.4-linux-x86_64.zip -d &#x2F;usr&#x2F;local&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="protoc-gen-go-go语言插件安装"><a href="#protoc-gen-go-go语言插件安装" class="headerlink" title="protoc-gen-go go语言插件安装"></a>protoc-gen-go go语言插件安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get -u github.com&#x2F;golang&#x2F;protobuf&#x2F;protoc-gen-go</span><br></pre></td></tr></table></figure>
<a id="more"></a>


<h3 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h3><p>Protobuf的protoc编译器是通过插件机制实现对不同语言的支持。比如protoc命令出现–xxx_out格式的参数，那么protoc将首先查询是否有内置的xxx插件，如果没有内置的xxx插件那么将继续查询当前系统中是否存在protoc-gen-xxx命名的可执行程序，最终通过查询到的插件生成代码。对于Go语言的protoc-gen-go插件来说，里面又实现了一层静态插件系统。比如protoc-gen-go内置了一个gRPC插件，用户可以通过–go_out=plugins=grpc参数来生成gRPC相关代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protoc --go_out&#x3D;plugins&#x3D;grpc:. route_guide.proto</span><br></pre></td></tr></table></figure>


<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="什么是grpc"><a href="#什么是grpc" class="headerlink" title="什么是grpc"></a>什么是grpc</h3><p>在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。<br><img src="/2020/05/28/go/grpc%E7%AC%94%E8%AE%B0/grpc_concept_diagram_00.png" alt></p>
<h3 id="使用-protocol-buffers"><a href="#使用-protocol-buffers" class="headerlink" title="使用 protocol buffers"></a>使用 protocol buffers</h3><p>gRPC 默认使用 protocol buffers，这是 Google 开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如 JSON）</p>
<h3 id="grpc服务定义"><a href="#grpc服务定义" class="headerlink" title="grpc服务定义"></a>grpc服务定义</h3><p>gRPC允许定义四类服务方法  </p>
<ul>
<li>单项 RPC，即客户端发送一个请求给服务端，从服务端获取一个应答，就像一次普通的函数调用。</li>
<li>服务端流式 RPC，即客户端发送一个请求给服务端，可获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止。</li>
<li>客户端流式 RPC，即客户端用提供的一个数据流写入并发送一系列消息给服务端。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答。</li>
<li>双向流式 RPC，即两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务端能按其希望的任意顺序读写，例如：服务端可以在写应答前等待所有的客户端消息，或者它可以先读一个消息再写一个消息，或者是读写相结合的其他方式。每个数据流里消息的顺序会被保持。</li>
</ul>
<h2 id="安全认证"><a href="#安全认证" class="headerlink" title="安全认证"></a>安全认证</h2><p>为了保障gRPC通信不被第三方监听篡改或伪造，我们可以对服务器启动TLS加密特性。  </p>
<h3 id="用以下命令为服务器和客户端分别生成私钥和证书"><a href="#用以下命令为服务器和客户端分别生成私钥和证书" class="headerlink" title="用以下命令为服务器和客户端分别生成私钥和证书"></a>用以下命令为服务器和客户端分别生成私钥和证书</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openssl genrsa -out server.key 2048</span><br><span class="line">$ openssl req -new -x509 -days 3650 \</span><br><span class="line">    -subj &quot;&#x2F;C&#x3D;GB&#x2F;L&#x3D;China&#x2F;O&#x3D;grpc-server&#x2F;CN&#x3D;server.grpc.io&quot; \</span><br><span class="line">    -key server.key -out server.crt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ openssl genrsa -out client.key 2048</span><br><span class="line">$ openssl req -new -x509 -days 3650 \</span><br><span class="line">    -subj &quot;&#x2F;C&#x3D;GB&#x2F;L&#x3D;China&#x2F;O&#x3D;grpc-client&#x2F;CN&#x3D;client.grpc.io&quot; \</span><br><span class="line">    -key client.key -out client.crt</span><br></pre></td></tr></table></figure>
<p>以上命令将生成server.key、server.crt、client.key和client.crt四个文件。其中以.key为后缀名的是私钥文件，需要妥善保管。以.crt为后缀名是证书文件，也可以简单理解为公钥文件，并不需要秘密保存。在subj参数中的/CN=server.grpc.io表示服务器的名字为server.grpc.io，在验证服务器的证书时需要用到该信息。</p>
<p>有了证书之后，我们就可以在启动gRPC服务时传入证书选项参数：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    creds, err :&#x3D; credentials.NewServerTLSFromFile(&quot;server.crt&quot;, &quot;server.key&quot;)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server :&#x3D; grpc.NewServer(grpc.Creds(creds))</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中credentials.NewServerTLSFromFile函数是从文件为服务器构造证书对象，然后通过grpc.Creds(creds)函数将证书包装为选项后作为参数传入grpc.NewServer函数。</p>
<p>客户端基于服务器的证书和服务器名字就可以对服务器进行验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    creds, err :&#x3D; credentials.NewClientTLSFromFile(</span><br><span class="line">        &quot;server.crt&quot;, &quot;server.grpc.io&quot;,</span><br><span class="line">    )</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    conn, err :&#x3D; grpc.Dial(&quot;localhost:5000&quot;,</span><br><span class="line">        grpc.WithTransportCredentials(creds),</span><br><span class="line">    )</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    defer conn.Close()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中redentials.NewClientTLSFromFile是构造客户端用的证书对象，第一个参数是服务器的证书文件，第二个参数是签发证书的服务器的名字。然后通过grpc.WithTransportCredentials(creds)将证书对象转为参数选项传人grpc.Dial函数。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="http://doc.oschina.net/grpc?t=60133" target="_blank" rel="noopener">grpc文档</a></li>
<li><a href="https://chai2010.cn/advanced-go-programming-book/" target="_blank" rel="noopener">Go语言高级编程</a></li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>go/go高级编程笔记</title>
    <url>/2020/05/08/go/go%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a href="https://chai2010.cn/advanced-go-programming-book/" target="_blank" rel="noopener">go语言高级编程</a></p>
<h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><h2 id="函数、方法和接口"><a href="#函数、方法和接口" class="headerlink" title="函数、方法和接口"></a>函数、方法和接口</h2><ul>
<li>init不是普通函数，可以定义有多个，所以也不能被其它函数调用</li>
<li>如果某个init函数内部用go关键字启动了新的goroutine的话，新的goroutine只有在进入main.main函数之后才可能被执行到。</li>
<li>每种类型对应的方法必须和类型的定义在同一个包中<a id="more"></a>


</li>
</ul>
<h2 id="面向并发的内存模型"><a href="#面向并发的内存模型" class="headerlink" title="面向并发的内存模型"></a>面向并发的内存模型</h2><ul>
<li>go基于CSP(通信顺序进程)模型实现并发,并且Goroutine之间可共享内存</li>
<li>Goroutine和系统线程不是等价的,一般系统线程占用一个固定大小的栈(2MB),Goroutine以一个大约2kb的栈启动,并且可以动态伸缩,最大可达1G的栈空间</li>
<li>Goroutine采用的是半抢占式的协作调度,只有在当前Goroutine发生阻塞时才会发生调度</li>
<li>初始化顺序 同包内(const &gt; var &gt; init),如果一个包内有多个init函数,会根据文件名顺序进行调用</li>
<li>可通过带缓存的channel,控制Goroutine的并发数量</li>
<li>顺序一致性内存模型 Go语言中，同一个Goroutine线程内部，顺序一致性内存模型是得到保证的。但是不同的Goroutine之间，并不满足顺序一致性内存模型<blockquote>
<p>如果在一个Goroutine中顺序执行a = 1; b = 2;两个语句，虽然在当前的Goroutine中可以认为a = 1;语句先于b = 2;语句执行，但是在另一个Goroutine中b = 2;语句可能会先于a = 1;语句执行，甚至在另一个Goroutine中无法看到它们的变化（可能始终在寄存器中）</p>
</blockquote>
</li>
</ul>
<h2 id="常见并发模式"><a href="#常见并发模式" class="headerlink" title="常见并发模式"></a>常见并发模式</h2><p>不要通过共享内存来通信,而应通过通信来共享内存</p>
<ul>
<li>等待N个线程完成后再进行下一步同步操作,可以使用sync.WaitGroup来实现</li>
<li>生产者消费者模型</li>
<li>发布订阅模型</li>
<li>控制并发数</li>
<li>赢者为王 通过适当开启一些冗余的线程，尝试用不同途径去解决同样的问题，最终以赢者为王的方式提升了程序的相应性能。</li>
<li>素数筛</li>
<li>并发的安全退出</li>
<li>通过Context包,实现Goroutine安全退出</li>
</ul>
<h1 id="第5章-Go和Web"><a href="#第5章-Go和Web" class="headerlink" title="第5章 Go和Web"></a>第5章 Go和Web</h1><h2 id="哪些事情适合在中间件中做"><a href="#哪些事情适合在中间件中做" class="headerlink" title="哪些事情适合在中间件中做"></a>哪些事情适合在中间件中做</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compress.go</span><br><span class="line">  &#x3D;&gt; 对http的响应体进行压缩处理</span><br><span class="line">heartbeat.go</span><br><span class="line">  &#x3D;&gt; 设置一个特殊的路由，例如&#x2F;ping，&#x2F;healthcheck，用来给负载均衡一类的前置服务进行探活</span><br><span class="line">logger.go</span><br><span class="line">  &#x3D;&gt; 打印请求处理处理日志，例如请求处理时间，请求路由</span><br><span class="line">profiler.go</span><br><span class="line">  &#x3D;&gt; 挂载pprof需要的路由，如&#96;&#x2F;pprof&#96;、&#96;&#x2F;pprof&#x2F;trace&#96;到系统中</span><br><span class="line">realip.go</span><br><span class="line">  &#x3D;&gt; 从请求头中读取X-Forwarded-For和X-Real-IP，将http.Request中的RemoteAddr修改为得到的RealIP</span><br><span class="line">requestid.go</span><br><span class="line">  &#x3D;&gt; 为本次请求生成单独的requestid，可一路透传，用来生成分布式调用链路，也可用于在日志中串连单次请求的所有逻辑</span><br><span class="line">timeout.go</span><br><span class="line">  &#x3D;&gt; 用context.Timeout设置超时时间，并将其通过http.Request一路透传下去</span><br><span class="line">throttler.go</span><br><span class="line">  &#x3D;&gt; 通过定长大小的channel存储token，并通过这些token对接口进行限流</span><br></pre></td></tr></table></figure>

<h2 id="常见的流量限制手段"><a href="#常见的流量限制手段" class="headerlink" title="常见的流量限制手段"></a>常见的流量限制手段</h2><p>1.漏桶是指我们有一个一直装满了水的桶，每过固定的一段时间即向外漏一滴水。如果你接到了这滴水，那么你就可以继续服务请求，如果没有接到，那么就需要等待下一滴水。  </p>
<p>2.令牌桶则是指匀速向桶中添加令牌，服务请求时需要从桶中获取令牌，令牌的数目可以按照需要消耗的资源进行相应的调整。如果没有令牌，可以选择等待，或者放弃。  </p>
<p>实际应用中令牌桶应用较为广泛，开源界流行的限流器大多数都是基于令牌桶思想的。并且在此基础上进行了一定程度的扩充，比如github.com/juju/ratelimit  </p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title>redis/一站式学习redis从入门到高可用分布式实践</title>
    <url>/2020/04/01/redis/%E4%B8%80%E7%AB%99%E5%BC%8F%E5%AD%A6%E4%B9%A0redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="第1章到第3章"><a href="#第1章到第3章" class="headerlink" title="第1章到第3章"></a>第1章到第3章</h1><h2 id="redis-特性"><a href="#redis-特性" class="headerlink" title="redis 特性"></a>redis 特性</h2><ul>
<li>速度快</li>
<li>持久化</li>
<li>多种数据结构</li>
<li>支持多种编程语言</li>
<li>功能丰富</li>
<li>简单</li>
<li>主从复制</li>
<li>高可用,分布式<a id="more"></a>

</li>
</ul>
<h2 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h2><ul>
<li>keys *: 列出所有的key ,不建议线上使用</li>
<li>dbsize :统计所有的key数量</li>
<li>exists :检查某个key是否存在</li>
<li>del: 删除某个key</li>
<li>expire key seconds :key 在seconds秒后过期</li>
<li>ttl key :查询key剩余的过期时间</li>
<li>persist key:去掉key的过期时间</li>
<li>type key :返回key的类型</li>
<li>info memory: 占用内存</li>
<li>config get : 获取当前生效的配置</li>
<li>flushall :清空数据库</li>
</ul>
<h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><ul>
<li>一次只运行长慢的命令</li>
<li>拒绝长（慢）的命令</li>
</ul>
<h1 id="第4章-Redis持久化的取舍与选择"><a href="#第4章-Redis持久化的取舍与选择" class="headerlink" title="第4章 Redis持久化的取舍与选择"></a>第4章 Redis持久化的取舍与选择</h1><h2 id="持久化的作用"><a href="#持久化的作用" class="headerlink" title="持久化的作用"></a>持久化的作用</h2><h3 id="什么是持久化"><a href="#什么是持久化" class="headerlink" title="什么是持久化"></a>什么是持久化</h3><p>redis所有数据保持在内存中，对数据的更新将异步的保存到磁盘上  </p>
<h3 id="持久化的实现方式"><a href="#持久化的实现方式" class="headerlink" title="持久化的实现方式"></a>持久化的实现方式</h3><h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p>在某个时间将数据进行完全的拷贝  </p>
<ul>
<li>Mysql Dump</li>
<li>Redis RDB</li>
</ul>
<h4 id="写日志"><a href="#写日志" class="headerlink" title="写日志"></a>写日志</h4><p>记录命令日志  </p>
<ul>
<li>Mysql Binlog</li>
<li>Hbase Hlog</li>
<li>Redis AOF</li>
</ul>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><h3 id="什么是RDB"><a href="#什么是RDB" class="headerlink" title="什么是RDB"></a>什么是RDB</h3><ul>
<li>二进制文件</li>
<li>复制媒介</li>
</ul>
<h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><h4 id="主要三种触发方式"><a href="#主要三种触发方式" class="headerlink" title="主要三种触发方式"></a>主要三种触发方式</h4><h5 id="save-同步"><a href="#save-同步" class="headerlink" title="save (同步)　"></a>save (同步)　</h5><ul>
<li>命令执行过程中redis处于阻塞状态</li>
<li>文件策略，如存在老的RDB文件，新替换老</li>
<li>O(N)</li>
</ul>
<h5 id="bgsave-异步"><a href="#bgsave-异步" class="headerlink" title="bgsave (异步)"></a>bgsave (异步)</h5><ul>
<li>bgsave 命令执行的时候redis 会fork出一个子进程，由这个子进程去执行RDB文件的生成</li>
</ul>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">save</th>
<th align="left">bgsave</th>
</tr>
</thead>
<tbody><tr>
<td align="left">IO类型</td>
<td align="left">同步</td>
<td align="left">异步</td>
</tr>
<tr>
<td align="left">阻塞</td>
<td align="left">是</td>
<td align="left">是（阻塞发生在fork）,fork的过程很快</td>
</tr>
<tr>
<td align="left">复杂度</td>
<td align="left">O(n)</td>
<td align="left">O(n)</td>
</tr>
<tr>
<td align="left">优点</td>
<td align="left">不会消耗额外内存</td>
<td align="left">不阻塞客户端命令</td>
</tr>
<tr>
<td align="left">缺点</td>
<td align="left">阻塞客户端命令</td>
<td align="left">需要fork,消耗内存</td>
</tr>
</tbody></table>
<h5 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h5><table>
<thead>
<tr>
<th align="left">配置</th>
<th align="left">seconds</th>
<th align="left">changes</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">save</td>
<td align="left">900</td>
<td align="left">1</td>
<td align="left">900秒内发生1次数据变动，执行bgsave</td>
</tr>
<tr>
<td align="left">save</td>
<td align="left">300</td>
<td align="left">10</td>
<td align="left">300秒内发生10次数据变动，执行bgsave</td>
</tr>
<tr>
<td align="left">save</td>
<td align="left">60</td>
<td align="left">10000</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">以上条件满足任一条件都会执行bgsave</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>1.redis默认配置文件 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir .&#x2F;</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure>
<p>2.redis推荐配置  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dbfilename dump-$&#123;port&#125;.rdb</span><br><span class="line">dir &#x2F;bigdiskpath </span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure>

<h4 id="不容忽视的方式"><a href="#不容忽视的方式" class="headerlink" title="不容忽视的方式"></a>不容忽视的方式</h4><ul>
<li>全量复制</li>
<li>debug reload</li>
<li>shutdown </li>
</ul>
<h3 id="RDB-总结"><a href="#RDB-总结" class="headerlink" title="RDB 总结"></a>RDB 总结</h3><ul>
<li>RDB是Redis内存到硬盘的快照，用于持久化</li>
<li>save通常会阻塞redis</li>
<li>bgsave不会阻塞redis,但会fork新进程</li>
<li>save自动配置满足任一就会被执行</li>
<li>有些触发机制不容忽视</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><h3 id="RDB的问题"><a href="#RDB的问题" class="headerlink" title="RDB的问题"></a>RDB的问题</h3><ul>
<li>耗时、耗性能</li>
<li>不可控、容易丢失数据</li>
</ul>
<h3 id="什么是AOF"><a href="#什么是AOF" class="headerlink" title="什么是AOF"></a>什么是AOF</h3><p>日志原理，每执行一条命令，都会写入到aof文件中<br>具体过程：  </p>
<ol>
<li>写命令刷新到缓冲区</li>
<li>缓冲区的命令会根据一定的策略fsync到硬盘的AOF文件中    </li>
</ol>
<h3 id="AOF三种策略"><a href="#AOF三种策略" class="headerlink" title="AOF三种策略"></a>AOF三种策略</h3><ul>
<li>always : 每执行一条命令就会执行fsync</li>
<li>everysec （默认值）: 每秒写入到硬盘中</li>
<li>no : 根据操作系统的策略决定的<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">always</th>
<th align="left">everysec</th>
<th align="left">no</th>
</tr>
</thead>
<tbody><tr>
<td align="left">优点</td>
<td align="left">不丢失数据</td>
<td align="left">每秒一次fsync丢1秒数据</td>
<td align="left">不用管</td>
</tr>
<tr>
<td align="left">缺点</td>
<td align="left">IO开销大一般的sata盘只有几百TPS</td>
<td align="left">丢1秒数据</td>
<td align="left">不可控</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><h4 id="为什么要进行AOF重写"><a href="#为什么要进行AOF重写" class="headerlink" title="为什么要进行AOF重写"></a>为什么要进行AOF重写</h4><p>把过期的、没有用的、重复的、 以及一些可以优化的命令进行化简</p>
<ul>
<li>减少磁盘的占用量</li>
<li>加速恢复速度</li>
</ul>
<h4 id="AOF重写实现的两种方式"><a href="#AOF重写实现的两种方式" class="headerlink" title="AOF重写实现的两种方式"></a>AOF重写实现的两种方式</h4><h5 id="bgrewriteaof"><a href="#bgrewriteaof" class="headerlink" title="bgrewriteaof"></a>bgrewriteaof</h5><h5 id="AOF重写配置"><a href="#AOF重写配置" class="headerlink" title="AOF重写配置"></a>AOF重写配置</h5><table>
<thead>
<tr>
<th align="left">配置名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">auto-aof-rewrite-min-size</td>
<td align="left">AOF文件重写需要的尺寸</td>
</tr>
<tr>
<td align="left">auto-aof-rewrite-percentage</td>
<td align="left">AOF文件增长率（(aof_current_size-aof_base_size)/aof_base_size）</td>
</tr>
</tbody></table>
<p>以上两个条件同时满足才会触发aof自动重写</p>
<table>
<thead>
<tr>
<th align="left">统计名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">aof_current_size</td>
<td align="left">AOF当前尺寸（单位：字节）</td>
</tr>
<tr>
<td align="left">aof_base_size</td>
<td align="left">AOF上次启动和重写的尺寸（单位：字节）</td>
</tr>
</tbody></table>
<h3 id="AOF-配置"><a href="#AOF-配置" class="headerlink" title="AOF 配置"></a>AOF 配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly-$&#123;port&#125;.aof&quot;</span><br><span class="line">appendfsync everysec</span><br><span class="line">dir &#x2F;bigdiskpath</span><br><span class="line">no-appendfsync-on-rewrite yes  # 在进行aof重写的时候，不进行aof操作</span><br><span class="line">auto-aof-rewrite-min-size 100</span><br><span class="line">auto-aof-rewrite-percentage 64mb</span><br></pre></td></tr></table></figure>

<h2 id="RDB和AOF的选择"><a href="#RDB和AOF的选择" class="headerlink" title="RDB和AOF的选择"></a>RDB和AOF的选择</h2><h3 id="RDB与AOF比较"><a href="#RDB与AOF比较" class="headerlink" title="RDB与AOF比较"></a>RDB与AOF比较</h3><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">RDB</th>
<th align="left">AOF</th>
</tr>
</thead>
<tbody><tr>
<td align="left">启动优先级</td>
<td align="left">低</td>
<td align="left">高</td>
</tr>
<tr>
<td align="left">体积</td>
<td align="left">小</td>
<td align="left">大</td>
</tr>
<tr>
<td align="left">恢复速度</td>
<td align="left">块</td>
<td align="left">慢</td>
</tr>
<tr>
<td align="left">数据安全</td>
<td align="left">丢数据</td>
<td align="left">根据策略决定</td>
</tr>
<tr>
<td align="left">轻重</td>
<td align="left">重</td>
<td align="left">轻</td>
</tr>
</tbody></table>
<h3 id="RDB最佳策略"><a href="#RDB最佳策略" class="headerlink" title="RDB最佳策略"></a>RDB最佳策略</h3><ul>
<li><p>“关”<br>在主从进行全量复制的时候会生成RDB文件，所以关是关不绝对的</p>
</li>
<li><p>集中管理<br>在固定的时间点进行备份的时候可以用</p>
</li>
<li><p>主、从<br>一定要开的情况下建议主关，从开</p>
</li>
</ul>
<h3 id="AOF最佳策略"><a href="#AOF最佳策略" class="headerlink" title="AOF最佳策略"></a>AOF最佳策略</h3><ul>
<li><p>开<br>redis作为存储的时候建议开启<br>redis作为缓存的时候可以不开启</p>
</li>
<li><p>AOF重写集中管理<br>避免单机多部署的时候aof重写集中发生，占满内存</p>
</li>
<li><p>aof重写策略推荐everysec<br>只会丢失1s的数据，不会频繁将buffer中的数据fsync到硬盘</p>
</li>
</ul>
<h3 id="最佳策略"><a href="#最佳策略" class="headerlink" title="最佳策略"></a>最佳策略</h3><ul>
<li>小分片</li>
<li>缓存或存储</li>
<li>监控（硬盘、内存、负载、网络）</li>
<li>足够的内存</li>
</ul>
<h1 id="第5章-常见持久化开发运维问题"><a href="#第5章-常见持久化开发运维问题" class="headerlink" title="第5章 常见持久化开发运维问题"></a>第5章 常见持久化开发运维问题</h1><h2 id="fork操作"><a href="#fork操作" class="headerlink" title="fork操作"></a>fork操作</h2><ul>
<li>同步操作</li>
<li>与内存量息息相关：内存越大、耗时越长（与机器类型有关）</li>
<li>info:last_fork_usec</li>
</ul>
<h3 id="改善fork"><a href="#改善fork" class="headerlink" title="改善fork"></a>改善fork</h3><ul>
<li>优先使用物理机或者高效支持fork操作的虚拟化技术</li>
<li>控制Redis实例最大可用内存：maxmemory</li>
<li>合理配置Linux内存分配策略：vm.overcommit_memory=1</li>
<li>降低fork频率：例如放宽AOF重写自动触发机制，不必要的全量复制</li>
</ul>
<h2 id="进程外开销"><a href="#进程外开销" class="headerlink" title="进程外开销"></a>进程外开销</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul>
<li>开销 RDB和AOF文件生成，属于CPU密集型</li>
<li>优化 不做CPU绑定，不和CPU密集型部署</li>
</ul>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><ul>
<li>开销 fork内存开销，copy-on-write</li>
<li>优化 echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</li>
</ul>
<h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><ul>
<li>开销： AOF和RDB文件写入，可以结合iostat,iotop分析</li>
<li>优化<br>不要和高硬盘负载服务器部署一起，存储服务、消息队列等<br>no-appendfsync-on-rewrite=yes<br>根据写入量决定磁盘类型 例如ssd<br>单机多实例持久化文件目录可以考虑分盘</li>
</ul>
<h2 id="AOF追加阻塞"><a href="#AOF追加阻塞" class="headerlink" title="AOF追加阻塞"></a>AOF追加阻塞</h2><h2 id="单机多部署实例"><a href="#单机多部署实例" class="headerlink" title="单机多部署实例"></a>单机多部署实例</h2><h1 id="第6章-Redis主从复制原理以及优化"><a href="#第6章-Redis主从复制原理以及优化" class="headerlink" title="第6章 Redis主从复制原理以及优化"></a>第6章 Redis主从复制原理以及优化</h1><h2 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h2><h3 id="单机有什么问题？"><a href="#单机有什么问题？" class="headerlink" title="单机有什么问题？"></a>单机有什么问题？</h3><ul>
<li>机器故障</li>
<li>容量瓶颈</li>
<li>QPS瓶颈 </li>
</ul>
<h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><ul>
<li>数据副本</li>
<li>扩展读性能</li>
</ul>
<h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><ul>
<li>一个master可以有多个slave</li>
<li>一个slave只能有一个master</li>
<li>数据流向是单向的，master到slave</li>
</ul>
<h2 id="复制的配置"><a href="#复制的配置" class="headerlink" title="复制的配置"></a>复制的配置</h2><h3 id="replicaof-命令"><a href="#replicaof-命令" class="headerlink" title="replicaof 命令"></a>replicaof 命令</h3><ul>
<li>replicaof 127.0.0.1 6379 </li>
<li>replicaof no one<blockquote>
<p>任何一个节点成为从节点的时候，都会将自身节点的数据进行清除</p>
</blockquote>
</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">replicaof ip port</span><br><span class="line">replica-read-only yes</span><br></pre></td></tr></table></figure>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><table>
<thead>
<tr>
<th align="left">方式</th>
<th align="left">命令</th>
<th align="left">配置</th>
</tr>
</thead>
<tbody><tr>
<td align="left">优点</td>
<td align="left">无需重启</td>
<td align="left">统一配置</td>
</tr>
<tr>
<td align="left">缺点</td>
<td align="left">不便于管理</td>
<td align="left">需要重启</td>
</tr>
</tbody></table>
<h2 id="全量复制和部分复制"><a href="#全量复制和部分复制" class="headerlink" title="全量复制和部分复制"></a>全量复制和部分复制</h2><h3 id="全量复制过程"><a href="#全量复制过程" class="headerlink" title="全量复制过程"></a>全量复制过程</h3><ol>
<li>slave: psync ? -1</li>
<li>master: FULLRESYNC {runId} {offset}</li>
<li>slave: save masterInfo</li>
<li>master: 执行bgsave 生成rdb文件,send RDB to slave</li>
<li>master: send buffer </li>
<li>slave: flush old data</li>
<li>slave: load RDB</li>
</ol>
<h3 id="全量复制开销"><a href="#全量复制开销" class="headerlink" title="全量复制开销"></a>全量复制开销</h3><ol>
<li>bgsave时间</li>
<li>RDB文件网络传输</li>
<li>从节点清空数据时间</li>
<li>从节点加载RDB时间</li>
<li>可能的AOF重写时间</li>
</ol>
<h3 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h3><p>部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施；<br>如果出现网络闪断或者命令丢失等异常情况时，从节点会向主节点要求补发丢失的命令数据，如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点</p>
<h2 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h2><h3 id="slave-故障"><a href="#slave-故障" class="headerlink" title="slave 故障"></a>slave 故障</h3><h3 id="master-故障"><a href="#master-故障" class="headerlink" title="master 故障"></a>master 故障</h3><h2 id="开发运维常见问题"><a href="#开发运维常见问题" class="headerlink" title="开发运维常见问题"></a>开发运维常见问题</h2><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><ol>
<li>读流量分摊到节点</li>
<li>可能遇到的问题  </li>
</ol>
<ul>
<li>复制数据延迟</li>
<li>读到过期的数据</li>
<li>从节点故障</li>
</ul>
<h3 id="配置不一致"><a href="#配置不一致" class="headerlink" title="配置不一致"></a>配置不一致</h3><ol>
<li>例如maxmemory不一致：丢失数据<h3 id="主从配置不一致"><a href="#主从配置不一致" class="headerlink" title="主从配置不一致"></a>主从配置不一致</h3><h3 id="规避全量复制"><a href="#规避全量复制" class="headerlink" title="规避全量复制"></a>规避全量复制</h3></li>
<li>第一次全量复制  </li>
</ol>
<ul>
<li>第一次不可避免</li>
<li>小主节点、低峰</li>
</ul>
<ol start="2">
<li>节点运行ID不匹配</li>
</ol>
<ul>
<li>主节点重启（运行ID变化）</li>
<li>故障转移，列如哨兵或集群</li>
</ul>
<ol start="3">
<li>复制积压缓冲区不足</li>
</ol>
<ul>
<li>网络中断，部分复制无法满足</li>
<li>增大复制缓冲区配置rel_backlog_size, 网络“增强”，默认为1M,可以配置成10M</li>
</ul>
<h3 id="规避复制风暴"><a href="#规避复制风暴" class="headerlink" title="规避复制风暴"></a>规避复制风暴</h3><ol>
<li>单节点复制风暴  </li>
</ol>
<ul>
<li>问题： 主节点重启，多从节点复制</li>
<li>解决： 更换复制拓扑</li>
</ul>
<ol start="2">
<li>单机器复制风暴</li>
</ol>
<ul>
<li>机器宕机后，大量全量复制</li>
<li>主节点分散多机器</li>
</ul>
<h1 id="第7章-Redis-sentine-哨兵"><a href="#第7章-Redis-sentine-哨兵" class="headerlink" title="第7章 Redis sentine (哨兵)"></a>第7章 Redis sentine (哨兵)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis Sentinel为Redis提供了很高的可用性，在实践中，这意味着你可以部署一个可以解决非人为干预导致节点故障的Redis集群系统。Redis Sentinel还提供了其他的功能：如监控，通知和客户端配置服务的提供方。下面列出来了Redis Sentinel的功能列表：  </p>
<ul>
<li>监控：Sentinel能够监控master节点或slave节点是否处于按照预期工作的状态。</li>
<li>通知：Sentinel能够通过api通知系统管理原，其他的计算机程序，Redis实例运行过程中发生了错误。</li>
<li>自动故障转移：如果Redis的master节点出现问题，Sentinel能够启动一个故障转移处理，该处理会将一个slave节点提升为master节点，其他的slave节点则会自动配置成新的master节点的slave节点，如果原来的master重新正常启动后，也会成为该新Master的slave节点。</li>
<li>客户端配置提供者：Sentinel可作为客户端服务发现的一个权威来源，客户端通过连接到Sentinel来请求当前的Redis Master节点，如果Master节点发生故障，Sentinel将会提供新的master地址。</li>
</ul>
<p>Redis Sentinel 是一个分布式系统， 你可以在架构中运行多个 Sentinel 进程，这些进程通过相互通讯来判断一个主服务器是否断线，以及是否应该执行故障转移。<br>在配置Redis Sentinel时，至少需要有1个Master和1个Slave。当Master失效后,Redis Sentinel会报出失效警告，并使用投票协议（agreement protocols）<br>来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器，并提供读写服务;当失效的Master恢复后，Redis Sentinel会自动识别，<br>将Master自动转换为Slave并完成数据同步。通过Redis Sentinel可以实现Redis零手工干预并且短时间内进行M-S切换，减少业务影响时间。  </p>
<p>虽然 Redis Sentinel 释出为一个单独的可执行文件 redis-sentinel ， 但实际上它只是一个运行在特殊模式下的 Redis 服务器， 你可以在启动一个普通 Redis 服务器时通过给定 –sentinel 选项来启动 Redis Sentinel。</p>
<h2 id="主从复制高可用的问题"><a href="#主从复制高可用的问题" class="headerlink" title="主从复制高可用的问题"></a>主从复制高可用的问题</h2><ul>
<li>手动故障转移</li>
<li>写能力和存储能力受限</li>
</ul>
<h2 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h2><p>sentinel 主要作用是监控、故障转移、通知<br>一个sentinel可以监控多套master,slave</p>
<h3 id="Redis-Sentinel故障转移"><a href="#Redis-Sentinel故障转移" class="headerlink" title="Redis Sentinel故障转移"></a>Redis Sentinel故障转移</h3><ol>
<li>多个sentinel发现并确认master有问题</li>
<li>选举出一个sentinel作为领导</li>
<li>选出一个slave作为master</li>
<li>通知其余slave成为新的master的slave</li>
<li>通知客户端主从变化</li>
</ol>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p>sentinel默认监听节点是26379</p>
<ol>
<li>配置开启主从节点</li>
<li>配置开启sentinel监控节点（sentinel是特殊的redis）</li>
<li>实际应该是多台机器</li>
<li>详细配置节点</li>
</ol>
<h3 id="redis-master节点配置"><a href="#redis-master节点配置" class="headerlink" title="redis master节点配置"></a>redis master节点配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 7000</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis-7000.pid</span><br><span class="line">logfile &quot;7000.log&quot;</span><br><span class="line">dir &quot;&#x2F;data&quot;</span><br></pre></td></tr></table></figure>
<h3 id="redis-slave1节点配置"><a href="#redis-slave1节点配置" class="headerlink" title="redis slave1节点配置"></a>redis slave1节点配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 7001</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis-7001.pid</span><br><span class="line">logfile &quot;7001.log&quot;</span><br><span class="line">dir &quot;&#x2F;data&quot;</span><br><span class="line">replicaof 127.0.0.1 7000</span><br></pre></td></tr></table></figure>

<h3 id="redis-sentinel主要配置"><a href="#redis-sentinel主要配置" class="headerlink" title="redis sentinel主要配置"></a>redis sentinel主要配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port $&#123;port&#125;</span><br><span class="line">dir &quot;&#x2F;data&quot;</span><br><span class="line">logfile &quot;$&#123;port&#125;.log&quot;</span><br><span class="line"># 设置判定mymaster 失效的monitor 个数 </span><br><span class="line">sentinel monitor mymaster 127.0.0.1 7000 2 </span><br><span class="line">sentinel down-after-millseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure>
<h2 id="sentinel中的3个定时任务"><a href="#sentinel中的3个定时任务" class="headerlink" title="sentinel中的3个定时任务"></a>sentinel中的3个定时任务</h2><h3 id="每10秒每个sentinel对master和slave-执行info"><a href="#每10秒每个sentinel对master和slave-执行info" class="headerlink" title="每10秒每个sentinel对master和slave 执行info"></a>每10秒每个sentinel对master和slave 执行info</h3><ul>
<li>发现slave节点</li>
<li>确认主从关系<h3 id="每两秒每个sentinel通过master节点的channel交换信息（pub-sub）"><a href="#每两秒每个sentinel通过master节点的channel交换信息（pub-sub）" class="headerlink" title="每两秒每个sentinel通过master节点的channel交换信息（pub/sub）"></a>每两秒每个sentinel通过master节点的channel交换信息（pub/sub）</h3></li>
<li>通过 <em>sentinel</em>:hello 频道交换信息</li>
<li>交换对节点的“看法”和自身信息</li>
</ul>
<h3 id="每1秒每个sentinel对其他sentinel和redis进ping"><a href="#每1秒每个sentinel对其他sentinel和redis进ping" class="headerlink" title="每1秒每个sentinel对其他sentinel和redis进ping"></a>每1秒每个sentinel对其他sentinel和redis进ping</h3><ul>
<li>心跳检测，失败判定依据</li>
</ul>
<h2 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h2><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h2 id="常见开发运维问题"><a href="#常见开发运维问题" class="headerlink" title="常见开发运维问题"></a>常见开发运维问题</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Redis Sentinel 的Sentinel节点数应该大于等于3且最好为奇数</li>
<li>Redis Sentinel 中的数据节点与普通数据节点没有区别</li>
<li>客户端初始化时连接的是Sentinel节点集合，不再是具体的Redis节点，但Sentinel只是配置中心而不是代理</li>
<li>Redis Sentinel 通过三个定时任务实现了Sentinel节点对于主节点、从节点、其余Sentinel节点的监控</li>
<li>Redis Sentinel 在对节点做失败判定时分为主观下线和客观下线</li>
<li>看懂Redis Sentinel 故障转移日志对于Redis Sentinel以及排查问题非常有帮助</li>
<li>Redis Sentinel 实现读写分离高可用可以依赖Sentinel节点的消息通知，获取Redis数据节点的状态变化</li>
</ul>
<h1 id="第8章-Redis-Cluster"><a href="#第8章-Redis-Cluster" class="headerlink" title="第8章 Redis Cluster"></a>第8章 Redis Cluster</h1><h2 id="数据分布概论"><a href="#数据分布概论" class="headerlink" title="数据分布概论"></a>数据分布概论</h2><h3 id="数据分布对比"><a href="#数据分布对比" class="headerlink" title="数据分布对比"></a>数据分布对比</h3><table>
<thead>
<tr>
<th align="left">分布方式</th>
<th align="left">特点</th>
<th align="left">典型产品</th>
</tr>
</thead>
<tbody><tr>
<td align="left">哈希分布</td>
<td align="left">数据分散度高键值分布业务无关，无法顺序访问，支持批量操作</td>
<td align="left">一致性哈希Memcache,Redis cluster,其他缓存产品</td>
</tr>
<tr>
<td align="left">顺序分布</td>
<td align="left">数据分散度易倾斜，键值业务相关，可顺序访问，支持批量操作</td>
<td align="left">BigTable HBase</td>
</tr>
</tbody></table>
<h3 id="哈希分布方式"><a href="#哈希分布方式" class="headerlink" title="哈希分布方式"></a>哈希分布方式</h3><h4 id="节点取余分区"><a href="#节点取余分区" class="headerlink" title="节点取余分区"></a>节点取余分区</h4><ul>
<li>客户端分片：哈希+取余</li>
<li>节点伸缩： 数据节点变化，导致数据迁移</li>
<li>迁移数量和添加节点数量有关：建议翻倍扩容<h4 id="一致性哈希分区"><a href="#一致性哈希分区" class="headerlink" title="一致性哈希分区"></a>一致性哈希分区</h4></li>
<li>客户端分片：哈希+顺时针（优化取余）</li>
<li>节点伸缩： 只影响临近节点，但是还是有数据迁移</li>
<li>翻倍伸缩： 保证最小迁移数据和负载均衡</li>
</ul>
<h4 id="虚拟槽分区"><a href="#虚拟槽分区" class="headerlink" title="虚拟槽分区"></a>虚拟槽分区</h4><ul>
<li>预设虚拟槽：每个槽映射一个数据子集，一般比节点数大</li>
<li>良好的哈希函数：例如CRC16</li>
<li>服务端管理节点、槽、数据 例如：Redis Cluster</li>
</ul>
<h2 id="Cluster节点主要配置"><a href="#Cluster节点主要配置" class="headerlink" title="Cluster节点主要配置"></a>Cluster节点主要配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster-enabled yes</span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line">cluster-config-file &quot;nodes.conf&quot;</span><br><span class="line">cluster-require-full-coverage yes</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title>linux/常用命令和问题</title>
    <url>/2020/04/01/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h1><ul>
<li>cat mysql.conf | grep -v “#” | grep -v “^$” 查看未被注释掉的行 </li>
</ul>
<h1 id="生成随机密码"><a href="#生成随机密码" class="headerlink" title="生成随机密码"></a>生成随机密码</h1><p>date +%s |sha256sum |base64 |head -c 10 ;echo</p>
<h1 id="检查端口状态"><a href="#检查端口状态" class="headerlink" title="检查端口状态"></a>检查端口状态</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -Aaln | grep 9090</span><br></pre></td></tr></table></figure>

<h1 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup .&#x2F;lwyfront &gt;&#x2F;dev&#x2F;null 2&gt;log &amp;</span><br></pre></td></tr></table></figure>

<h1 id="ubuntu-变更默认执行环境dash-gt-bash"><a href="#ubuntu-变更默认执行环境dash-gt-bash" class="headerlink" title="ubuntu 变更默认执行环境dash =&gt; bash"></a>ubuntu 变更默认执行环境dash =&gt; bash</h1><p>在安装华为seo-client(vpn)时候遇到的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg-reconfigure dash #选否</span><br><span class="line">ll &#x2F;bin&#x2F;sh #查看</span><br></pre></td></tr></table></figure>

<h1 id="sshpass-命令行带密码登录"><a href="#sshpass-命令行带密码登录" class="headerlink" title="sshpass 命令行带密码登录"></a>sshpass 命令行带密码登录</h1><p>配置自定义命令，实现快速登录服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sshpass -p &quot;XXX&quot; ssh user@IP</span><br></pre></td></tr></table></figure>

<h1 id="ubuntu解压windows生成的zip文件时乱码问题"><a href="#ubuntu解压windows生成的zip文件时乱码问题" class="headerlink" title="ubuntu解压windows生成的zip文件时乱码问题"></a>ubuntu解压windows生成的zip文件时乱码问题</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip -O CP936 xxx.zip</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>linux/计算机原理+操作系统基础+计算机网络(慕课网)</title>
    <url>/2020/04/01/linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80+%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(%E6%85%95%E8%AF%BE%E7%BD%91)/</url>
    <content><![CDATA[<p>计算机组成原理、操作系统、计算机网络</p>
<a id="more"></a>

<h1 id="第一章-计算机组成原理之概述篇"><a href="#第一章-计算机组成原理之概述篇" class="headerlink" title="第一章 计算机组成原理之概述篇"></a>第一章 计算机组成原理之概述篇</h1><h2 id="计算机发展历史"><a href="#计算机发展历史" class="headerlink" title="计算机发展历史"></a>计算机发展历史</h2><h3 id="计算机发展路程"><a href="#计算机发展路程" class="headerlink" title="计算机发展路程"></a>计算机发展路程</h3><ol>
<li>电子管计算机</li>
<li>晶体管计算机</li>
<li>集成电路计算机</li>
<li>超大规模集成电路计算机</li>
</ol>
<h3 id="未来可能出现的计算机"><a href="#未来可能出现的计算机" class="headerlink" title="未来可能出现的计算机"></a>未来可能出现的计算机</h3><ol>
<li>生物计算机</li>
<li>量子计算机</li>
</ol>
<h3 id="微型计算机的发展"><a href="#微型计算机的发展" class="headerlink" title="微型计算机的发展"></a>微型计算机的发展</h3><ol>
<li>单核cpu,受限于性能,计算频率突破2GHz </li>
<li>多核cpu ,Intel酷睿系列可达到16核cpu ,Intel至强系列56核cpu<blockquote>
<p>摩尔定律：价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍</p>
</blockquote>
</li>
</ol>
<h2 id="计算机的分类"><a href="#计算机的分类" class="headerlink" title="计算机的分类"></a>计算机的分类</h2><h3 id="超级计算机"><a href="#超级计算机" class="headerlink" title="超级计算机"></a>超级计算机</h3><ul>
<li>功能最强、运算速度最快、存储容量最大的计算机</li>
<li>多用于国际高科技领域和尖端技术研究</li>
<li>运算速度需要达到1Tlop/s=每秒一万亿次浮点运算</li>
</ul>
<h3 id="大型计算机"><a href="#大型计算机" class="headerlink" title="大型计算机"></a>大型计算机</h3><ul>
<li>又称大型机、大型主机、主机等</li>
<li>具有高性能，可处理大量数据与复杂的运算</li>
<li>在大型计算机市场领域，IBM占据着很大的份额</li>
</ul>
<h3 id="迷你计算机（服务器）"><a href="#迷你计算机（服务器）" class="headerlink" title="迷你计算机（服务器）"></a>迷你计算机（服务器）</h3><ul>
<li>也称为小型机，普通服务器</li>
<li>不需要特殊的空调场所</li>
<li>具备不错的算力，可以完成较复杂的运算</li>
</ul>
<h3 id="工作站"><a href="#工作站" class="headerlink" title="工作站"></a>工作站</h3><ul>
<li>高端的通用微型计算机，提供比个人计算机更强大的性能</li>
<li>类似于普通台式电脑，体积较大，但性能强劲</li>
</ul>
<h3 id="微型计算机"><a href="#微型计算机" class="headerlink" title="微型计算机"></a>微型计算机</h3><ul>
<li>又称为个人计算机，是最普通的一类计算机</li>
<li>台式机、笔记本电脑、一体机</li>
</ul>
<h2 id="计算机的体系与结构"><a href="#计算机的体系与结构" class="headerlink" title="计算机的体系与结构"></a>计算机的体系与结构</h2><h3 id="冯洛伊曼体系"><a href="#冯洛伊曼体系" class="headerlink" title="冯洛伊曼体系"></a>冯洛伊曼体系</h3><p>将程序指令和数据一起存储的计算机设计概念结构（1.存储程序指令 2.设计通用电路）</p>
<blockquote>
<p>冯洛伊曼瓶颈 cpu和存储器速率之间的问题无法调和（cpu经常空转等待数据传输）</p>
</blockquote>
<h4 id="冯洛伊曼体系结构"><a href="#冯洛伊曼体系结构" class="headerlink" title="冯洛伊曼体系结构"></a>冯洛伊曼体系结构</h4><ul>
<li>必须有一个存储器</li>
<li>必须有一个控制器</li>
<li>必须有一个运算器</li>
<li>必须有输入设备</li>
<li>必须有输出设备<blockquote>
<p>cpu=控制器+运算器</p>
</blockquote>
</li>
</ul>
<h4 id="冯洛伊曼体系工作原理"><a href="#冯洛伊曼体系工作原理" class="headerlink" title="冯洛伊曼体系工作原理"></a>冯洛伊曼体系工作原理</h4><ul>
<li>能够把需要的程序和数据送至计算机中</li>
<li>能够长期记忆程序、数据、中间结果、及最终运算结果的能力</li>
<li>能够具备算术、逻辑运算和数据传送等数据加工处理的能力</li>
<li>能够按照要求处理结果输出给用户</li>
</ul>
<h3 id="现代计算机的结构"><a href="#现代计算机的结构" class="headerlink" title="现代计算机的结构"></a>现代计算机的结构</h3><ul>
<li>必须有一个存储器</li>
<li>必须有一个控制器</li>
<li>必须有一个运算器</li>
<li>必须有输入设备</li>
<li>必须有输出设备</li>
</ul>
<p>cpu=控制器+运算器+存储器</p>
<p>现代计算机结构可以理解为主要以存储器为核心</p>
<p>存储器包括:磁带、硬盘、内存、cpu的寄存器 </p>
<h2 id="计算机的层次与编程语言"><a href="#计算机的层次与编程语言" class="headerlink" title="计算机的层次与编程语言"></a>计算机的层次与编程语言</h2><h3 id="程序翻译和程序解释"><a href="#程序翻译和程序解释" class="headerlink" title="程序翻译和程序解释"></a>程序翻译和程序解释</h3><ul>
<li>计算机执行的命令都是L0</li>
<li>翻译过程生成新的L0程序，解释过程不生成新的L0程序（编译器）</li>
<li>解释过程由L0编写的解释器去解释L1程序 （解释器）</li>
</ul>
<h3 id="计算机的层次结构"><a href="#计算机的层次结构" class="headerlink" title="计算机的层次结构"></a>计算机的层次结构</h3><ul>
<li>应用层 （虚拟机器）</li>
<li>高级语言层 （虚拟机器）</li>
<li>汇编语言层 （虚拟机器）</li>
<li>操作系统层 （虚拟机器 连接虚拟机器与实际机器）</li>
<li>传统机器层 （实际机器）</li>
<li>微程序机器层 （实际机器）</li>
<li>硬件逻辑层 （实际机器）</li>
</ul>
<h2 id="计算机的计量单位"><a href="#计算机的计量单位" class="headerlink" title="计算机的计量单位"></a>计算机的计量单位</h2><h3 id="容量单位"><a href="#容量单位" class="headerlink" title="容量单位"></a>容量单位</h3><p>bit Byte KB MB GB TB PB EB （8bit=1Byte）</p>
<h3 id="速度单位"><a href="#速度单位" class="headerlink" title="速度单位"></a>速度单位</h3><ul>
<li>网络常用单位为Mbps</li>
<li>100M/s=100Mbps=100Mbit/s 100Mbit/s=(100/8)MB/s=12.5MB/s</li>
</ul>
<h3 id="CPU速度"><a href="#CPU速度" class="headerlink" title="CPU速度"></a>CPU速度</h3><ul>
<li>CPU速度一般体现为CPU的时钟频率</li>
<li>CPU的时钟频率的单位一般为赫兹Hz</li>
<li>主流CPU的时钟频率都在2GHz以上</li>
<li>CPU时钟频率指每秒钟高低电频切换（0和1）的频率<blockquote>
<p>Hz是秒分之1  每秒钟的周期性变动重复次数的计量（振动频率）</p>
</blockquote>
</li>
</ul>
<h2 id="计算机编码集"><a href="#计算机编码集" class="headerlink" title="计算机编码集"></a>计算机编码集</h2><ul>
<li>ASCII 编码集（7个bit表示）</li>
<li>ASCII 扩展编码集（8个bit标识）</li>
<li>GB2312 （中文编码，不符合国际ISO标准，以字节byte标识）</li>
<li>GBK （中文编码集，支持中、韩、日文，符合估计ISO标准，以字节byte标识）</li>
<li>UTF-*（统一码，支持所有的语言，其中utf-8,8代表以字节为单位进行标识）</li>
</ul>
<h3 id="中文编码集"><a href="#中文编码集" class="headerlink" title="中文编码集"></a>中文编码集</h3><ul>
<li>中国大陆的Windows系统默认使用GBK编码</li>
<li>编程推荐使用UTF-8编码</li>
</ul>
<h1 id="第二章-计算机组成原理之组成篇"><a href="#第二章-计算机组成原理之组成篇" class="headerlink" title="第二章 计算机组成原理之组成篇"></a>第二章 计算机组成原理之组成篇</h1><h2 id="计算机总线"><a href="#计算机总线" class="headerlink" title="计算机总线"></a>计算机总线</h2><h3 id="总线的概述"><a href="#总线的概述" class="headerlink" title="总线的概述"></a>总线的概述</h3><ul>
<li>提供了对外连接的接口</li>
<li>不同设备可以通过USB（通用串行总线）接口进行连接</li>
<li>连接的标准，促使外围设备接口的统一</li>
</ul>
<h3 id="总线分类"><a href="#总线分类" class="headerlink" title="总线分类"></a>总线分类</h3><h4 id="片内总线"><a href="#片内总线" class="headerlink" title="片内总线"></a>片内总线</h4><ul>
<li>芯片内部的总线</li>
<li>寄存器与寄存器之间</li>
<li>寄存器与控制器、运算器之间</li>
</ul>
<h4 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h4><h5 id="数据总线-一般与CPU位数相同（32位，64位）"><a href="#数据总线-一般与CPU位数相同（32位，64位）" class="headerlink" title="数据总线 一般与CPU位数相同（32位，64位）"></a>数据总线 一般与CPU位数相同（32位，64位）</h5><ul>
<li>双向传输各个部件的数据信息</li>
<li>数据总线的位数（总线宽度）是数据总线的重要参数</li>
</ul>
<h5 id="地址总线-地址总线位数-n-寻址范围：0-2的n次方"><a href="#地址总线-地址总线位数-n-寻址范围：0-2的n次方" class="headerlink" title="地址总线 地址总线位数=n 寻址范围：0-2的n次方"></a>地址总线 地址总线位数=n 寻址范围：0-2的n次方</h5><ul>
<li>指定源数据或目的数据在内存中的地址</li>
<li>地址总线的位数与存储单元有关<h5 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h5></li>
<li>控制总线是用来发出各种控制信号的传输线</li>
<li>控制信号经由控制总线从一个组件发给另一个组件</li>
<li>控制总线可以见识不同组件之间的状态（就绪、未就绪）</li>
</ul>
<h3 id="总线的仲裁"><a href="#总线的仲裁" class="headerlink" title="总线的仲裁"></a>总线的仲裁</h3><p>为了解决总线使用权的冲突问题，总线仲裁的方法：</p>
<h4 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h4><ul>
<li>好处 电路复杂度低，仲裁方式简单</li>
<li>坏处 优先级低的设备难以获得总线使用权</li>
<li>坏处 对电路故障铭感<h4 id="计时器定时查询"><a href="#计时器定时查询" class="headerlink" title="计时器定时查询"></a>计时器定时查询</h4></li>
<li>仲裁控制器对设备编号并使用计数器累计计数</li>
<li>接收到仲裁信号后，往所有设备发出计数值</li>
<li>计数值与设备编号一致则获得总线使用权<h4 id="独立请求"><a href="#独立请求" class="headerlink" title="独立请求"></a>独立请求</h4></li>
<li>每个设备均有总线独立连接仲裁器</li>
<li>设备可单独向仲裁器发送请求和接受请求</li>
<li>当同时收到多个请求信号，仲裁器有权按优先级分配使用权<blockquote>
<p>好处：响应速度快，优先顺序可动态改变 ；设备连线多，总线控制复杂</p>
</blockquote>
</li>
</ul>
<h2 id="计算机输入输出设备"><a href="#计算机输入输出设备" class="headerlink" title="计算机输入输出设备"></a>计算机输入输出设备</h2><h3 id="常见输入输出设备"><a href="#常见输入输出设备" class="headerlink" title="常见输入输出设备"></a>常见输入输出设备</h3><h4 id="字符输入设备"><a href="#字符输入设备" class="headerlink" title="字符输入设备"></a>字符输入设备</h4><ul>
<li>键盘</li>
<li>扫描仪 将图形信息转换为数字信号<h4 id="图像输出设备"><a href="#图像输出设备" class="headerlink" title="图像输出设备"></a>图像输出设备</h4></li>
<li>显示器</li>
<li>打印机</li>
<li>投影仪</li>
</ul>
<h3 id="输入输出接口的通用设计"><a href="#输入输出接口的通用设计" class="headerlink" title="输入输出接口的通用设计"></a>输入输出接口的通用设计</h3><ul>
<li>数据线</li>
<li>状态线</li>
<li>命令线</li>
<li>设备选择线</li>
</ul>
<h3 id="CPU与IO设备的通信"><a href="#CPU与IO设备的通信" class="headerlink" title="CPU与IO设备的通信"></a>CPU与IO设备的通信</h3><h4 id="程序中断"><a href="#程序中断" class="headerlink" title="程序中断"></a>程序中断</h4><ul>
<li>提供低速设备通知CPU的一种异步的方式</li>
<li>CPU可以高速运转同时兼顾低速设备的响应<h4 id="DMA-直接存储器访问"><a href="#DMA-直接存储器访问" class="headerlink" title="DMA(直接存储器访问)"></a>DMA(直接存储器访问)</h4></li>
<li>DMA直接连接主存和IO设备</li>
<li>当主存与IO设备交换信息时，不需要中断CPU</li>
<li>可以提高CPU的效率</li>
</ul>
<h2 id="计算机存储器概览"><a href="#计算机存储器概览" class="headerlink" title="计算机存储器概览"></a>计算机存储器概览</h2><h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><h4 id="按存储介质分类"><a href="#按存储介质分类" class="headerlink" title="按存储介质分类"></a>按存储介质分类</h4><h5 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h5><ul>
<li>内存</li>
<li>U盘</li>
<li>固态硬盘<h5 id="磁存储器"><a href="#磁存储器" class="headerlink" title="磁存储器"></a>磁存储器</h5></li>
<li>磁带</li>
<li>磁盘</li>
</ul>
<h4 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a>按存取方式分类</h4><h5 id="随机存储器（RAM）"><a href="#随机存储器（RAM）" class="headerlink" title="随机存储器（RAM）"></a>随机存储器（RAM）</h5><ul>
<li>随机读取</li>
<li>与位置无关<h5 id="串行存储器"><a href="#串行存储器" class="headerlink" title="串行存储器"></a>串行存储器</h5></li>
<li>与位置有关</li>
<li>按顺序查找<h5 id="只读存储器（ROM）"><a href="#只读存储器（ROM）" class="headerlink" title="只读存储器（ROM）"></a>只读存储器（ROM）</h5></li>
<li>只读不写</li>
</ul>
<h2 id="计算机的主存存储器和辅助存储器"><a href="#计算机的主存存储器和辅助存储器" class="headerlink" title="计算机的主存存储器和辅助存储器"></a>计算机的主存存储器和辅助存储器</h2><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><ul>
<li>缓存（CPU寄存器）</li>
<li>主存（内存）<ul>
<li>RAM （随机存取存储器：Random Access Memory）</li>
<li>RAM通过电容存储数据，必须隔一段时间刷新一次</li>
<li>如果掉电，那么一段时间后将丢失所有数据</li>
</ul>
</li>
<li>辅存（硬盘）<ul>
<li>先来先服务算法</li>
<li>最短寻道时间优先</li>
<li>扫描算法（电梯算法）</li>
<li>循环扫描算法</li>
</ul>
</li>
</ul>
<h3 id="cpu-gt-缓存-gt-主存-gt-辅存-（cpu可直接和主存交换数据）"><a href="#cpu-gt-缓存-gt-主存-gt-辅存-（cpu可直接和主存交换数据）" class="headerlink" title="cpu-&gt;缓存-&gt;主存-&gt;辅存 （cpu可直接和主存交换数据）"></a>cpu-&gt;缓存-&gt;主存-&gt;辅存 （cpu可直接和主存交换数据）</h3><ul>
<li>原理：局部性原理</li>
<li>实现：在CPU与主存之间增加一层速度快（容量小）的Cache</li>
<li>目的：解决CPU与主存速度不匹配的问题</li>
</ul>
<h2 id="计算机的高速缓存"><a href="#计算机的高速缓存" class="headerlink" title="计算机的高速缓存"></a>计算机的高速缓存</h2><h3 id="高速缓存的工作原理"><a href="#高速缓存的工作原理" class="headerlink" title="高速缓存的工作原理"></a>高速缓存的工作原理</h3><ul>
<li>cpu需要的数据在缓存里,从缓存读取</li>
<li>cpu需要的数据不在缓存里,从主存读取 </li>
</ul>
<h4 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h4><ul>
<li>字 是指存放在一个存储单元中的二进制代码组合，一个字有32位</li>
<li>字块 存储在连续存储单元中而被看作是一个单元的一组字<blockquote>
<p>命中率是衡量缓存的重要性指标 命中效率计算</p>
</blockquote>
</li>
</ul>
<p>字的地址包含两个部分:前m位指定字块的地址,后b位指定字在字块中的地址</p>
<h4 id="高速缓存的替换策略"><a href="#高速缓存的替换策略" class="headerlink" title="高速缓存的替换策略"></a>高速缓存的替换策略</h4><ul>
<li>随机算法</li>
<li>先进先出算法（FIFO） 类似于先进先出队列</li>
<li>最不经常使用算法（LFU） 需要额外的字块记录字块使用频率</li>
<li>最近最少使用算法（LRU）</li>
</ul>
<h2 id="计算机的指令系统"><a href="#计算机的指令系统" class="headerlink" title="计算机的指令系统"></a>计算机的指令系统</h2><h3 id="机器指令的形式"><a href="#机器指令的形式" class="headerlink" title="机器指令的形式"></a>机器指令的形式</h3><ul>
<li>机器指令主要由两部分组成：操作码、地址码</li>
<li>操作码指明指令所要完成的动作</li>
<li>操作码的位数反映了机器的操作种类</li>
<li>地址码直接给出操作数或者操作数的地址</li>
<li>分三地址指令、二地址指令、一地址指令、零地址指令</li>
</ul>
<h3 id="机器指令的操作类型"><a href="#机器指令的操作类型" class="headerlink" title="机器指令的操作类型"></a>机器指令的操作类型</h3><h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><ul>
<li>寄存器之间、寄存器与存储单元、存储单元之间传送</li>
<li>数据读写、交换地址数据、清零置一等操作<h4 id="算术逻辑操作"><a href="#算术逻辑操作" class="headerlink" title="算术逻辑操作"></a>算术逻辑操作</h4></li>
<li>操作数之间的加减乘除运算</li>
<li>操作数的与或非等逻辑位运算<h4 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h4></li>
<li>数据左移（乘2）、数据右移（除2）</li>
<li>完成数据在算术逻辑单元的必要操作<h4 id="控制指令"><a href="#控制指令" class="headerlink" title="控制指令"></a>控制指令</h4></li>
<li>等待指令、停机指令、空操作指令、中断指令等</li>
</ul>
<h3 id="机器指令的寻址方式"><a href="#机器指令的寻址方式" class="headerlink" title="机器指令的寻址方式"></a>机器指令的寻址方式</h3><h4 id="指令寻址方式"><a href="#指令寻址方式" class="headerlink" title="指令寻址方式"></a>指令寻址方式</h4><ul>
<li>顺序寻址</li>
<li>跳跃寻址<h4 id="数据寻址方式"><a href="#数据寻址方式" class="headerlink" title="数据寻址方式"></a>数据寻址方式</h4></li>
<li>立即寻址（操作数直接位于指令当中）（速度快、地址码的位数限制操作数表示范围）</li>
<li>直接寻址（地址码存放的是操作数的地址）（寻址操作数简单、地址码位数限制操作数寻址范围）</li>
<li>间接寻址（地址码存储的是操作数地址的地址）（操作数寻址范围大、速度较慢）</li>
</ul>
<h2 id="计算机的控制器"><a href="#计算机的控制器" class="headerlink" title="计算机的控制器"></a>计算机的控制器</h2><p>控制器是协调和控制计算机运行的</p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul>
<li>程序计数器</li>
<li>时序发生器</li>
<li>指令译码器</li>
<li>各种寄存器（指令寄存器、主地址寄存器、主存数据寄存器、通用寄存器）</li>
<li>总线</li>
</ul>
<h2 id="计算机的运算器"><a href="#计算机的运算器" class="headerlink" title="计算机的运算器"></a>计算机的运算器</h2><p>运算器是用来进行数据运算加工的</p>
<h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><h4 id="数据缓存器"><a href="#数据缓存器" class="headerlink" title="数据缓存器"></a>数据缓存器</h4><ul>
<li>分为输入缓冲和输出缓冲</li>
<li>输入缓冲展示存放外设送过来的数据</li>
<li>输出缓冲展示存放送往外设的数据<h4 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h4></li>
<li>算术逻辑单元，是运算器的主要组成</li>
<li>常见的位运算（左右移，与或非等）</li>
<li>算术运算（加减乘除等）<h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4></li>
<li>用于暂时存放或传送数据或指令</li>
<li>可保存ALU的运算中间结果</li>
<li>容量比一般专用寄存器要大<h4 id="状态字寄存器"><a href="#状态字寄存器" class="headerlink" title="状态字寄存器"></a>状态字寄存器</h4></li>
<li>存放运算状态（条件码、进位、溢出、结果正负等）</li>
<li>存放运算控制信息（调试跟踪标记位、允许中断位等）<h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4></li>
</ul>
<h2 id="计算机指令的执行过程"><a href="#计算机指令的执行过程" class="headerlink" title="计算机指令的执行过程"></a>计算机指令的执行过程</h2><ul>
<li>了解指令的执行过程</li>
<li>对所取出的指令进行分析</li>
<li>执行指令</li>
<li>为下一条指令做准备</li>
</ul>
<h1 id="第三章-计算机组成原理之计算篇"><a href="#第三章-计算机组成原理之计算篇" class="headerlink" title="第三章 计算机组成原理之计算篇"></a>第三章 计算机组成原理之计算篇</h1><h2 id="进制运算的基础"><a href="#进制运算的基础" class="headerlink" title="进制运算的基础"></a>进制运算的基础</h2><ul>
<li>二进制转换成十进制　按权展开法</li>
<li>十进制转换二进制　重复相除法（整数）　重复相乘法（小数）</li>
</ul>
<h2 id="有符号数与无符号数"><a href="#有符号数与无符号数" class="headerlink" title="有符号数与无符号数"></a>有符号数与无符号数</h2><h3 id="原码表示法"><a href="#原码表示法" class="headerlink" title="原码表示法"></a>原码表示法</h3><ul>
<li>使用0表示正数、1表示负数</li>
<li>规定符号位位于数值第一位</li>
<li>表达简单明了，是人类最容易理解的表示法</li>
</ul>
<h3 id="二进制的补码表示法"><a href="#二进制的补码表示法" class="headerlink" title="二进制的补码表示法"></a>二进制的补码表示法</h3><ul>
<li>正数的补码是自己</li>
<li>负数的补码=最大值-负数的绝对值<h3 id="引进补码的目的"><a href="#引进补码的目的" class="headerlink" title="引进补码的目的"></a>引进补码的目的</h3></li>
<li>减法运算复杂，希望找到使用正数替代负数的方法</li>
<li>使用加法代替减法操作，从而消除减法 （在计算补码的过程中，还是使用的减法）</li>
</ul>
<p>负数的反码等于原码除符号位外按位取反</p>
<p>负数的补码等于反码+1</p>
<h3 id="判断溢出"><a href="#判断溢出" class="headerlink" title="判断溢出"></a>判断溢出</h3><ul>
<li>双符号位判断 计算结果双符号不同则为溢出</li>
<li>-B[补]等于B[补]连同符号位按位取反，末位加一    </li>
</ul>
<h3 id="浮点数的加减法运算"><a href="#浮点数的加减法运算" class="headerlink" title="浮点数的加减法运算"></a>浮点数的加减法运算</h3><ol>
<li>对阶</li>
<li>尾数求和</li>
<li>尾数规格化<ul>
<li>需要满足符号位与最高位不一致</li>
<li>通过一般情况下都是左移</li>
<li>双符号位不一致下需要右移（定点运算的溢出情况）</li>
<li>右移的化则需要进行舍入操作</li>
</ul>
</li>
<li>舍入<ul>
<li>0舍1入法（二进制的四舍五入）</li>
</ul>
</li>
<li>溢出判断<ul>
<li>定点运算双符号位不一致则溢出</li>
<li>浮点运算组要通过阶码的双符号位判断是否溢出（如果规格化后，阶码符号位不一致，则认为是溢出）</li>
</ul>
</li>
</ol>
<h1 id="第四章-计算机组成原理实践"><a href="#第四章-计算机组成原理实践" class="headerlink" title="第四章 计算机组成原理实践"></a>第四章 计算机组成原理实践</h1><h2 id="双向链表的原理与实践"><a href="#双向链表的原理与实践" class="headerlink" title="双向链表的原理与实践"></a>双向链表的原理与实践</h2><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><ul>
<li>可以快速找到一个节点的下一个节点</li>
<li>可以快速找到一个节点的上一个节点</li>
<li>可以快速去掉链表中的某一个节点</li>
</ul>
<h1 id="第五章-操作系统之基础篇"><a href="#第五章-操作系统之基础篇" class="headerlink" title="第五章 操作系统之基础篇"></a>第五章 操作系统之基础篇</h1><h2 id="操作系统概览"><a href="#操作系统概览" class="headerlink" title="操作系统概览"></a>操作系统概览</h2><p>管理硬件、提供用户交互的软件系统</p>
<h3 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h3><ul>
<li>操作系统是管理计算机硬件和软件资源的计算机程序</li>
<li>管理配置内存、决定资源供需顺序、控制输入输出设备等</li>
<li>操作系统提供让用户和系统交互的操作界面</li>
</ul>
<h3 id="操作系统的种类"><a href="#操作系统的种类" class="headerlink" title="操作系统的种类"></a>操作系统的种类</h3><ul>
<li>操作系统的种类是多种多样的，不局限于计算机</li>
<li>从手机到超级计算机，操作系统可简单也可复杂</li>
<li>在不同的设备上，操作系统可向用户呈现出多种操作手段</li>
</ul>
<h3 id="操作系统的演进"><a href="#操作系统的演进" class="headerlink" title="操作系统的演进"></a>操作系统的演进</h3><h4 id="无操作系统"><a href="#无操作系统" class="headerlink" title="无操作系统"></a>无操作系统</h4><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><h5 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h5><ul>
<li>多道程序设计是指在计算机内存中同时存放多个程序</li>
<li>多道程序在计算机的管理程序纸箱相互穿插运行<blockquote>
<p>多道程序的管理是炒作系统的重要功能</p>
</blockquote>
<h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4></li>
</ul>
<h3 id="操作系统的五大功能"><a href="#操作系统的五大功能" class="headerlink" title="操作系统的五大功能"></a>操作系统的五大功能</h3><ul>
<li>进程管理</li>
<li>存储管理</li>
<li>作业管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
<h3 id="操作系统的基本功能"><a href="#操作系统的基本功能" class="headerlink" title="操作系统的基本功能"></a>操作系统的基本功能</h3><h4 id="统一管理者计算机资源"><a href="#统一管理者计算机资源" class="headerlink" title="统一管理者计算机资源"></a>统一管理者计算机资源</h4><p>处理器资源、IO设备资源、存储器资源、文件资源</p>
<h4 id="操作系统实现了对计算机资源的抽象"><a href="#操作系统实现了对计算机资源的抽象" class="headerlink" title="操作系统实现了对计算机资源的抽象"></a>操作系统实现了对计算机资源的抽象</h4><ul>
<li>用户无需面向硬件接口编程</li>
<li>IO设备管理软件，提供读写接口</li>
<li>文件管理软件，提供操作文件接口<h4 id="操作系统提供了用户与计算机之间的接口"><a href="#操作系统提供了用户与计算机之间的接口" class="headerlink" title="操作系统提供了用户与计算机之间的接口"></a>操作系统提供了用户与计算机之间的接口</h4></li>
<li>图像窗口形式</li>
<li>命令形式</li>
<li>系统调用形式</li>
</ul>
<h3 id="操作系统相关概念"><a href="#操作系统相关概念" class="headerlink" title="操作系统相关概念"></a>操作系统相关概念</h3><h4 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h4><ul>
<li>并行是指两个或多个事件可以在同一时刻发生</li>
<li>并发是指两个或多个事件可以在同一时间间隔发生<h4 id="共享性"><a href="#共享性" class="headerlink" title="共享性"></a>共享性</h4></li>
<li>共享性表现为操作系统中的资源可供多个并发的程序共同使用</li>
<li>这个共同使用的形式称之为资源共享</li>
<li>多个程序可以同时使用主存资源</li>
<li>资源共享根据属性可分为两种方式<ul>
<li>互斥共享形式<ul>
<li>当资源被程序A占用时，其他想使用的话只能等待</li>
<li>只有进程A使用完以后，其他进程才可以使用该资源</li>
</ul>
</li>
<li>同时访问形式<ul>
<li>某种资源在一段时间内并发地被多个程序访问</li>
<li>这种“同时”是宏观的，从宏观去看该资源可以被同时访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="虚拟性"><a href="#虚拟性" class="headerlink" title="虚拟性"></a>虚拟性</h4><ul>
<li><p>虚拟性表现为把一个物理实体转变为若干个逻辑实体</p>
</li>
<li><p>物理实体是真实存在的，逻辑实体是虚拟的</p>
</li>
<li><p>虚拟的技术主要有 时分复用技术 和 空分复用技术</p>
<ul>
<li><p>时分复用技术</p>
<ul>
<li><p>资源在时间上进行复用，不同程序并发使用</p>
</li>
<li><p>多道程序分时使用计算机的硬件资源</p>
</li>
<li><p>提高资源的利用率</p>
<blockquote>
<p>虚拟处理器技术（借助多道程序设计技术，为每个程序建立进程，多个程序分时复用处理器）</p>
</blockquote>
<blockquote>
<p>虚拟设备技术（物理设备虚拟为过个逻辑设备，每个程序占用一个逻辑设备，多个程序通过逻辑设备并发访问）    </p>
</blockquote>
</li>
</ul>
</li>
<li><p>空分复用技术</p>
<ul>
<li><p>空分复用技术用来实现虚拟磁盘、虚拟内存等</p>
</li>
<li><p>提高资源的利用率，提升编程效率</p>
<blockquote>
<p>虚拟磁盘技术 （物理磁盘虚拟为逻辑磁盘，C、D、E等逻辑盘，使用起来更加安全、方便）</p>
</blockquote>
<blockquote>
<p>虚拟内存技术（在逻辑上扩大程序的存储容量，使用比实际内存更大的容量，大大提升编程效率）</p>
</blockquote>
<h4 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h4></li>
</ul>
</li>
</ul>
</li>
<li><p>在多道程序环境下，允许多个进程并发执行</p>
</li>
<li><p>进程在使用资源时可能需要等待或者放弃</p>
</li>
<li><p>进程的执行并不是一气呵成的，而是以走走停停的形式推进</p>
</li>
</ul>
<h2 id="进程管理之进程实体"><a href="#进程管理之进程实体" class="headerlink" title="进程管理之进程实体"></a>进程管理之进程实体</h2><h3 id="为什么需要进程？"><a href="#为什么需要进程？" class="headerlink" title="为什么需要进程？"></a>为什么需要进程？</h3><ul>
<li>进程是系统进行资源分配和调度的基本单位</li>
<li>进程作为程序独立运行的载体保障程序正常运行</li>
<li>进程的存在使得操作系统资源的利用率大幅提升</li>
</ul>
<h3 id="进程的实体"><a href="#进程的实体" class="headerlink" title="进程的实体"></a>进程的实体</h3><ul>
<li>标识符 （标识符唯一标记一个进程，用于区别其他进程）</li>
<li>状态 （标记进程的进程状态，如：运行态）</li>
<li>优先级</li>
<li>程序计数器（进程即将被执行的下一条指令的地址）</li>
<li>内存指针（程序代码、进程数据相关指针）</li>
<li>上下文数据 （进程执行时处理器存储的数据）</li>
<li>IO状态信息（被进程IO操作所占用的文件列表）</li>
<li>记账信息 （使用处理器时间、时钟数总和等）</li>
</ul>
<h3 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h3><ul>
<li>用于描述和控制进程运行的通用数据结构</li>
<li>记录进程当前状态和控制进程运行的全部信息</li>
<li>PCB使得进程是能够独立运行的基本单位</li>
<li>PCB是操作系统进行调度经常被读取的信息</li>
<li>PCB是常驻内存的，存放在系统专门开辟的PCB区域内<blockquote>
<p>PCB通常是系统内存占用区中的一个连续存区，它存放着操作系统用于描述进程情况及控制进程运行所需的全部信息，它使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位或一个能与其他进程并发执行的进程</p>
</blockquote>
</li>
</ul>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><h4 id="进程（Process）"><a href="#进程（Process）" class="headerlink" title="进程（Process）"></a>进程（Process）</h4><h4 id="线程（Thread）"><a href="#线程（Thread）" class="headerlink" title="线程（Thread）"></a>线程（Thread）</h4><ul>
<li>线程是操作系统进行运行调度的最小单位</li>
<li>线程包含在进程之中，是进程中实际运行工作的单位</li>
<li>一个进程可以并发多个线程，每个线程执行不同的任务<blockquote>
<p>线程共享进程的资源</p>
</blockquote>
</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table>
<thead>
<tr>
<th align="center">对比</th>
<th align="center">进程</th>
<th align="center">线程</th>
</tr>
</thead>
<tbody><tr>
<td align="center">资源</td>
<td align="center">资源分配的基本单位</td>
<td align="center">不拥有资源</td>
</tr>
<tr>
<td align="center">调度</td>
<td align="center">独立调度的基本单位</td>
<td align="center">独立调度的最小单位</td>
</tr>
<tr>
<td align="center">系统开销</td>
<td align="center">进程系统开销大</td>
<td align="center">线程系统开销小</td>
</tr>
<tr>
<td align="center">通信</td>
<td align="center">进程IPC</td>
<td align="center">读写同一进程数据通信</td>
</tr>
</tbody></table>
<h2 id="进程的无状态模型"><a href="#进程的无状态模型" class="headerlink" title="进程的无状态模型"></a>进程的无状态模型</h2><h3 id="就绪"><a href="#就绪" class="headerlink" title="就绪"></a>就绪</h3><ul>
<li>当进程被分配到除CPU以外所有必要的资源后</li>
<li>只要再获得CPU的使用权，就可以立即运行</li>
<li>其他资源都准备好、只差CPU资源的状态为就绪状态<blockquote>
<p>就绪队列  多个就绪状态的进程组成就绪队列</p>
</blockquote>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3></li>
<li>进程因某种原因如：其他设备未就绪而无法继续执行</li>
<li>从而放弃CPU的状态称为阻塞状态<blockquote>
<p>阻塞队列  多个阻塞状态的进程组成就绪队列</p>
</blockquote>
</li>
</ul>
<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><ul>
<li>进程获得CPU，其程序正在执行称为执行状态</li>
<li>在单核处理机中，在某个时刻只能有一个进程是处理执行状态</li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul>
<li>创建进程时拥有PCB但其他资源尚未就绪的状态称为创建状态</li>
</ul>
<h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><ul>
<li>系统清理</li>
<li>PCB归还</li>
<li>进程结束有系统清理或则归还PCB的状态称为终止状态</li>
</ul>
<h2 id="进程管理之进程同步"><a href="#进程管理之进程同步" class="headerlink" title="进程管理之进程同步"></a>进程管理之进程同步</h2><ul>
<li>对竞争资源在多进程间进行使用次序的协调</li>
<li>使得并发执行的多个进程间可以有效使用资源和相互合作</li>
</ul>
<h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><p>临界资源指的是一些虽作为共享资源却又无法同时被过个线程共同访问的共享资源。当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制等待占用进程释放<br>该共享资源才可重新竞争使用共享资源</p>
<h3 id="进程间同步原则"><a href="#进程间同步原则" class="headerlink" title="进程间同步原则"></a>进程间同步原则</h3><ul>
<li>空闲让进 （资源无占用，允许使用）</li>
<li>忙则等待 （资源有占用，请求进程等待）</li>
<li>有限等待 （保证有限等待时间能够使用资源）</li>
<li>让权等待 （等待时，进程需要让出CPU）</li>
</ul>
<h3 id="进程间同步的方法"><a href="#进程间同步的方法" class="headerlink" title="进程间同步的方法"></a>进程间同步的方法</h3><ul>
<li>消息队列</li>
<li>共享存储</li>
<li>信号量</li>
</ul>
<h3 id="线程间同步的方法"><a href="#线程间同步的方法" class="headerlink" title="线程间同步的方法"></a>线程间同步的方法</h3><ul>
<li>互斥量</li>
<li>读写锁</li>
<li>自旋锁</li>
<li>条件变量</li>
</ul>
<h2 id="linux进程管理"><a href="#linux进程管理" class="headerlink" title="linux进程管理"></a>linux进程管理</h2><h3 id="进程的类型"><a href="#进程的类型" class="headerlink" title="进程的类型"></a>进程的类型</h3><ul>
<li>前台进程 （具有终端，可以和用户交互的进程）   </li>
<li>后台进程 （后台程序基本上不和用户交互，优先级比前台进程低，将需要执行的命令以 &amp; 符号结束，终端关闭则进程退出）</li>
<li>守护进程 （特殊的守护进程，终端退出，程序也不会终止）</li>
</ul>
<h3 id="进程的标记"><a href="#进程的标记" class="headerlink" title="进程的标记"></a>进程的标记</h3><ul>
<li>进程ID是进程的唯一标记，每个进程拥有不同的ID</li>
<li>进程ID表现为一个非负整数，最大值有操作系统决定</li>
<li>进程父子关系可以通过pstree来查看<blockquote>
<p>操作系统提供fork函数接口创建进程<br>ID为0的进程为idle进程,是系统创建的第一个进程；ID为1的进程为init进程，是0号进程的子进程，完成系统的初始化</p>
</blockquote>
<h3 id="linux下进程管理常用命令"><a href="#linux下进程管理常用命令" class="headerlink" title="linux下进程管理常用命令"></a>linux下进程管理常用命令</h3></li>
<li>top</li>
<li>ps </li>
<li>kill</li>
</ul>
<h2 id="作业管理之进程调度"><a href="#作业管理之进程调度" class="headerlink" title="作业管理之进程调度"></a>作业管理之进程调度</h2><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>进程调度是指计算机通过决策决定那个就绪进程可以获得CPU使用权</p>
<ul>
<li>保留旧进程的运行信息，请出旧进程（收拾包袱）</li>
<li>选择新进程，准备运行环境并分配CPU（新进驻）</li>
</ul>
<h3 id="进程调度的机制"><a href="#进程调度的机制" class="headerlink" title="进程调度的机制"></a>进程调度的机制</h3><h4 id="就绪队列的排队机制"><a href="#就绪队列的排队机制" class="headerlink" title="就绪队列的排队机制"></a>就绪队列的排队机制</h4><p>将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程</p>
<h4 id="选择运行进程的委派机制"><a href="#选择运行进程的委派机制" class="headerlink" title="选择运行进程的委派机制"></a>选择运行进程的委派机制</h4><p>调度程序以一定的策略选择就绪进程，将CPU资源分配给它</p>
<h4 id="新老进程的上下文切换机制"><a href="#新老进程的上下文切换机制" class="headerlink" title="新老进程的上下文切换机制"></a>新老进程的上下文切换机制</h4><p>保存当前进程的上下文信息，装入被委派执行进程的运行上下文</p>
<h3 id="按照调度的方法分类"><a href="#按照调度的方法分类" class="headerlink" title="按照调度的方法分类"></a>按照调度的方法分类</h3><h4 id="非抢占式调度"><a href="#非抢占式调度" class="headerlink" title="非抢占式调度"></a>非抢占式调度</h4><ul>
<li>处理器一旦分配给某个进程，就让该进程一直使用下去</li>
<li>调度程序不以任何原因抢占正在被使用的处理器</li>
<li>直到进程完成工作或因为IO阻塞才会让出处理器</li>
</ul>
<h4 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h4><ul>
<li>允许调度程序以一定的策略暂停当前运行的进程</li>
<li>保存好旧进程的上下文信息，分配处理器给新进程</li>
</ul>
<h4 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h4><table>
<thead>
<tr>
<th align="center">对比</th>
<th align="center">抢占式调度</th>
<th align="center">非抢占式调度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">系统开销</td>
<td align="center">频繁切换，开销大</td>
<td align="center">切换次数少，开销小</td>
</tr>
<tr>
<td align="center">公平性</td>
<td align="center">相对公平</td>
<td align="center">不公平</td>
</tr>
<tr>
<td align="center">应用</td>
<td align="center">通用系统</td>
<td align="center">专用系统</td>
</tr>
</tbody></table>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ul>
<li>先来先服务</li>
<li>短进程优先<ul>
<li>调度程序优先选择就绪队列中估计运行时间最短的进程</li>
<li>短进程优先调度算法不利于长作业进程的执行</li>
</ul>
</li>
<li>高优先权优先<ul>
<li>进程附带优先权，调度程序优先选择权重高的进程</li>
<li>高优先权优先调度算法使得紧迫的任务可以优先处理<blockquote>
<p>前台进程优先于后台进程</p>
</blockquote>
</li>
</ul>
</li>
<li>时间片轮转<ul>
<li>按先来先服务的原则排列就绪进程</li>
<li>每次从队列头部取出待执行进程，分配一个时间片执行</li>
<li>是相对公平的调度算法，但不能保证及时响应用户</li>
</ul>
</li>
</ul>
<h2 id="作业管理之死锁"><a href="#作业管理之死锁" class="headerlink" title="作业管理之死锁"></a>作业管理之死锁</h2><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信儿造成的一种祖塞现象，若无外力作用，他们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，<br>这些永远在互相等待的进程称为死锁进程。</p>
<h3 id="死锁的产生"><a href="#死锁的产生" class="headerlink" title="死锁的产生"></a>死锁的产生</h3><ul>
<li>竞争资源</li>
<li>进程调度顺序不当</li>
</ul>
<h3 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h3><h4 id="互斥条件"><a href="#互斥条件" class="headerlink" title="互斥条件"></a>互斥条件</h4><ul>
<li>进程对资源的使用是排他性的使用</li>
<li>某资源只能由一个进程使用，其他进程需要使用只能等待</li>
</ul>
<h4 id="请求保持条件"><a href="#请求保持条件" class="headerlink" title="请求保持条件"></a>请求保持条件</h4><ul>
<li>进程至少保持一个资源，又提出新的资源请求</li>
<li>新资源被占用，请求被阻塞</li>
<li>被阻塞的进程又不释放自己保持的资源</li>
</ul>
<h4 id="不可剥夺条件"><a href="#不可剥夺条件" class="headerlink" title="不可剥夺条件"></a>不可剥夺条件</h4><ul>
<li>进程获得的资源在未完成使用前不能被剥夺</li>
<li>获得的资源只能有进程自身释放</li>
</ul>
<h4 id="环路等待条件"><a href="#环路等待条件" class="headerlink" title="环路等待条件"></a>环路等待条件</h4><ul>
<li>发生死锁时，必然存在进程-资源环形链</li>
</ul>
<h3 id="死锁的处理"><a href="#死锁的处理" class="headerlink" title="死锁的处理"></a>死锁的处理</h3><h4 id="预防死锁的方法"><a href="#预防死锁的方法" class="headerlink" title="预防死锁的方法"></a>预防死锁的方法</h4><h5 id="摒弃请求保持条件"><a href="#摒弃请求保持条件" class="headerlink" title="摒弃请求保持条件"></a>摒弃请求保持条件</h5><ul>
<li>系统规定进程运行之前，一次性申请所有需要的资源</li>
<li>进程在运行期间不会剔除资源请求，从而摒弃请求保持条件</li>
</ul>
<h5 id="摒弃不可剥夺条件"><a href="#摒弃不可剥夺条件" class="headerlink" title="摒弃不可剥夺条件"></a>摒弃不可剥夺条件</h5><ul>
<li>当一个进程请求新的资源得不到满足时，必须释放占有的资源</li>
<li>进程运行时占有的资源可以被释放，意味着可以被剥夺</li>
</ul>
<h5 id="摒弃环路等待条件"><a href="#摒弃环路等待条件" class="headerlink" title="摒弃环路等待条件"></a>摒弃环路等待条件</h5><ul>
<li>可用资源线性排序，申请必须按照需要递增申请</li>
<li>线性申请不再形成环路，从而摒弃了环路等待条件</li>
</ul>
<h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><ul>
<li>所需资源表</li>
<li>已分配资源表</li>
<li>可分配资源表</li>
</ul>
<p>##存储管理内存分配与回收</p>
<h3 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h3><ul>
<li>确保计算机有足够的内存处理数据</li>
<li>确保程序可以从可用内存中获取一部分内存使用</li>
<li>确保程序可以归还使用后的内存以供其他程序使用</li>
</ul>
<h3 id="内存分配的过程"><a href="#内存分配的过程" class="headerlink" title="内存分配的过程"></a>内存分配的过程</h3><h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><ul>
<li>固定分区分配是支持多道程序的最简单存储分配方式</li>
<li>内存空间被划分为若干个固定大小的区域</li>
<li>每个分区只提供给一个程序使用，互不干扰</li>
</ul>
<h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p>根据进程实际需要，动态分配内存空间</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>动态分区空闲表数据结构</li>
<li>动态分区空闲链数据结构</li>
</ul>
<h3 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h3><h4 id="首次适用算法（FF算法）"><a href="#首次适用算法（FF算法）" class="headerlink" title="首次适用算法（FF算法）"></a>首次适用算法（FF算法）</h4><ul>
<li>分配内存时从开始顺序查找适合内存区</li>
<li>若没有合适的空闲区，则该次分配失败</li>
<li>每次从头部开始，使得头部地址空间不断被划分<h4 id="最佳适应算法（BF算法）"><a href="#最佳适应算法（BF算法）" class="headerlink" title="最佳适应算法（BF算法）"></a>最佳适应算法（BF算法）</h4></li>
<li>最佳适应算法要求空闲区块链表按照容量大小排序</li>
<li>遍历空闲区链表找到最佳合适空闲区<h4 id="快速适应算法（QF算法）"><a href="#快速适应算法（QF算法）" class="headerlink" title="快速适应算法（QF算法）"></a>快速适应算法（QF算法）</h4></li>
<li>快速适应算法要求多个空闲区链表</li>
<li>每个空闲区链表存储一种容量的空闲区</li>
</ul>
<h3 id="内存回收的过程"><a href="#内存回收的过程" class="headerlink" title="内存回收的过程"></a>内存回收的过程</h3><h2 id="存储管理之段页式存储管理"><a href="#存储管理之段页式存储管理" class="headerlink" title="存储管理之段页式存储管理"></a>存储管理之段页式存储管理</h2><h3 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h3><ul>
<li>页面大小应该适中，过大难以分配，过小内存碎片过多</li>
<li>页面大小通常是512b~8k</li>
</ul>
<h3 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h3><ul>
<li>将进程逻辑空间划分成若干段（非等分）   </li>
<li>段的长度由连续逻辑的长度决定</li>
<li>主函数MAIN、子程序段X、子函数Y等</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>段式存储和页式存储都离散地管理了进程的逻辑空间</li>
<li>页是物理单位，段是逻辑单位</li>
<li>分页是为了合理利用空间，分段是满足用户要求</li>
<li>页大小由硬件固定，段长度可动态变化</li>
<li>页表信息是一维的，段表信息是二维的</li>
</ul>
<h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><p>分页可以有效提高内存利用率（虽然说存在页内碎片）；分段可以更好满足用户需求；两者结合，形成段页式存储管理</p>
<ul>
<li>先将逻辑空间按段式管理分成若干段</li>
<li>再把段内空间按页式管理等分成若干页</li>
</ul>
<h2 id="存储管理之虚拟内存"><a href="#存储管理之虚拟内存" class="headerlink" title="存储管理之虚拟内存"></a>存储管理之虚拟内存</h2><h3 id="虚拟内存概述"><a href="#虚拟内存概述" class="headerlink" title="虚拟内存概述"></a>虚拟内存概述</h3><ul>
<li>有些进程实际需要的内存很大，超过物理内存的容量</li>
<li>多道程序设计，使得每个进程可用物理内存更加稀缺</li>
<li>不可能无限增加物理内存，物理内存总有不够的时候</li>
</ul>
<h3 id="程序的局部性原理"><a href="#程序的局部性原理" class="headerlink" title="程序的局部性原理"></a>程序的局部性原理</h3><p>局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中</p>
<ul>
<li>程序运行时，无需全部装入内存，装载部分即可</li>
<li>如果访问页不在内存，则发出缺页中断，发起页面置换</li>
<li>从用户层面看，程序拥有很大的空间，即是虚拟内存<blockquote>
<p>虚拟内存实际是对物理内存的补充，速度接近于内存，成本接近于辅存</p>
</blockquote>
</li>
</ul>
<h3 id="虚拟内存的置换算法"><a href="#虚拟内存的置换算法" class="headerlink" title="虚拟内存的置换算法"></a>虚拟内存的置换算法</h3><ul>
<li>先进先出算法（FIFO）</li>
<li>最不经常使用算法（LFU）</li>
<li>最近最少使用算法（LRU）</li>
</ul>
<blockquote>
<p>替换策略发生在Cache-主存层次、主存-辅存层次；</p>
</blockquote>
<blockquote>
<p>Cache-主存层次的替换策略主要是为了解决速度问题；</p>
</blockquote>
<blockquote>
<p>主存-辅存层次主要是为了解决容量问题</p>
</blockquote>
<h2 id="linux存储管理"><a href="#linux存储管理" class="headerlink" title="linux存储管理"></a>linux存储管理</h2><h3 id="Buddy内存管理算法"><a href="#Buddy内存管理算法" class="headerlink" title="Buddy内存管理算法"></a>Buddy内存管理算法</h3><ul>
<li>Buddy算法是经典的内存管理算法</li>
<li>算法基于计算机处理二进制的优势具有极高的效率</li>
<li>算法主要是为了解决内存外碎片的问题</li>
</ul>
<h3 id="linux交换空间"><a href="#linux交换空间" class="headerlink" title="linux交换空间"></a>linux交换空间</h3><ul>
<li>交换空间（Swap）是磁盘的一个分区</li>
<li>Linux物理内存满时，会把一些内存交换至Swap空间</li>
<li>Swap空间是初始化系统时配置的</li>
<li>冷启动内存依赖</li>
<li>系统睡眠依赖</li>
<li>大进程空间依赖</li>
</ul>
<h3 id="交换空间和虚拟内存比较"><a href="#交换空间和虚拟内存比较" class="headerlink" title="交换空间和虚拟内存比较"></a>交换空间和虚拟内存比较</h3><table>
<thead>
<tr>
<th align="center">交换空间</th>
<th align="center">虚拟内存</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存在于磁盘</td>
<td align="center">存在于磁盘</td>
</tr>
<tr>
<td align="center">与主存发生置换</td>
<td align="center">与主存发生置换</td>
</tr>
<tr>
<td align="center">操作系统概念</td>
<td align="center">进程概念</td>
</tr>
<tr>
<td align="center">解决系统物理内存不足问题</td>
<td align="center">解决进程物理内存不足问题</td>
</tr>
</tbody></table>
<h2 id="操作系统的文件管理"><a href="#操作系统的文件管理" class="headerlink" title="操作系统的文件管理"></a>操作系统的文件管理</h2><h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><h4 id="顺序文件-（存在数据增、删、改、问题）"><a href="#顺序文件-（存在数据增、删、改、问题）" class="headerlink" title="顺序文件 （存在数据增、删、改、问题）"></a>顺序文件 （存在数据增、删、改、问题）</h4><ul>
<li>顺序文件是指顺序存放在存储介质中的文件</li>
<li>磁带的存储特性使得磁带文件只能存储顺序文件</li>
<li>顺序文件是所有逻辑文件当中存储效率最高的<h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4></li>
<li>可变长文件不适合使用顺序文件格式存储</li>
<li>索引文件是为了解决可变长文件存储而发明的一种文件格式</li>
<li>索引文件需要配合索引表完成存储的操作</li>
</ul>
<h3 id="逻辑结构的文件类型"><a href="#逻辑结构的文件类型" class="headerlink" title="逻辑结构的文件类型"></a>逻辑结构的文件类型</h3><h4 id="有结构文件-（文本文件、文档、媒体文件）"><a href="#有结构文件-（文本文件、文档、媒体文件）" class="headerlink" title="有结构文件 （文本文件、文档、媒体文件）"></a>有结构文件 （文本文件、文档、媒体文件）</h4><ul>
<li>文件内容由定长记录和可变长记录组成</li>
<li>定长记录存储文件格式、文件描述等结构化数据项</li>
<li>可变长记录存储文件具体内容<h4 id="无结构文件-（二进制文件、链接库）（exe文件、dll文件、so文件）"><a href="#无结构文件-（二进制文件、链接库）（exe文件、dll文件、so文件）" class="headerlink" title="无结构文件 （二进制文件、链接库）（exe文件、dll文件、so文件）"></a>无结构文件 （二进制文件、链接库）（exe文件、dll文件、so文件）</h4></li>
<li>也称为流式文件</li>
<li>文件内容长度以字节为单位</li>
</ul>
<h3 id="辅存的存储空间分配"><a href="#辅存的存储空间分配" class="headerlink" title="辅存的存储空间分配"></a>辅存的存储空间分配</h3><h4 id="辅存的分配方式"><a href="#辅存的分配方式" class="headerlink" title="辅存的分配方式"></a>辅存的分配方式</h4><h5 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h5><ul>
<li>顺序读取文件内容非常容易，速度很快</li>
<li>对存储要求高，要求满足容量的连续存储空间</li>
</ul>
<h5 id="链接分配-（链接分配可以将文件存储在离散的盘块中、需要额外的存储空间存储文件的盘块链接顺序）（、显式链接）"><a href="#链接分配-（链接分配可以将文件存储在离散的盘块中、需要额外的存储空间存储文件的盘块链接顺序）（、显式链接）" class="headerlink" title="链接分配 （链接分配可以将文件存储在离散的盘块中、需要额外的存储空间存储文件的盘块链接顺序）（、显式链接）"></a>链接分配 （链接分配可以将文件存储在离散的盘块中、需要额外的存储空间存储文件的盘块链接顺序）（、显式链接）</h5><p>链接分配可以将文件存储在离散的盘块中、需要额外的存储空间存储文件的盘块链接顺序</p>
<ul>
<li>隐式分配<ul>
<li>隐式分配的下一个链接指向存储在当前盘块内</li>
<li>隐式分配适合顺序访问，随机访问效率很低</li>
<li>可靠性差，任何一个链接出问题都影响整个文件</li>
</ul>
</li>
<li>显式分配 （如FAT文件系统）<ul>
<li>不支持高效的直接存储（FAT记录项多）</li>
<li>检索时FAT表占用较大的存储空间（需要将整个FAT加载到内存）</li>
</ul>
</li>
<li>索引分配<ul>
<li>把文件的所有盘快集中存储（索引）</li>
<li>读取某个文件时，将文件索引读取进内存即可</li>
<li>每个文件拥有一个索引块，记录所有盘块信息</li>
<li>索引分配方式支持直接访问盘块</li>
<li>文件较大时，索引分配方式具有明显优势</li>
</ul>
</li>
</ul>
<h3 id="辅存的存储空间管理"><a href="#辅存的存储空间管理" class="headerlink" title="辅存的存储空间管理"></a>辅存的存储空间管理</h3><h4 id="空闲表"><a href="#空闲表" class="headerlink" title="空闲表"></a>空闲表</h4><ul>
<li>空闲盘区的分配与内存分配类似</li>
<li>首次适应算法、循环适应算法等</li>
<li>回收过程也与内存回收类似</li>
</ul>
<h4 id="空闲链表"><a href="#空闲链表" class="headerlink" title="空闲链表"></a>空闲链表</h4><ul>
<li>空闲链表法吧所有空闲盘区组成一个空闲链表</li>
<li>每个链表节点存储空闲盘块和空闲的数目</li>
</ul>
<h4 id="位示图"><a href="#位示图" class="headerlink" title="位示图"></a>位示图</h4><ul>
<li>位示图维护成本低</li>
<li>位示图可以非常容易找到空闲盘块</li>
<li>位示图使用0/1比特位，占用空间很小</li>
</ul>
<h2 id="Linux的文件系统"><a href="#Linux的文件系统" class="headerlink" title="Linux的文件系统"></a>Linux的文件系统</h2><h3 id="文件系统概览"><a href="#文件系统概览" class="headerlink" title="文件系统概览"></a>文件系统概览</h3><h4 id="FAT-File-Allocation-Table"><a href="#FAT-File-Allocation-Table" class="headerlink" title="FAT (File Allocation Table)"></a>FAT (File Allocation Table)</h4><p>FAT16,FAT32等，微软Dos/Windows使用的文件系统；使用一张表保存盘块的信息</p>
<h4 id="NTFS-（New-Technology-File-System）"><a href="#NTFS-（New-Technology-File-System）" class="headerlink" title="NTFS （New Technology File System）"></a>NTFS （New Technology File System）</h4><p>windows NT环境的文件系统；NTFS对FAT进行了改进，取代了旧的文件系统</p>
<h4 id="EXT2-3-4（Extended-file-system）"><a href="#EXT2-3-4（Extended-file-system）" class="headerlink" title="EXT2/3/4（Extended file system）"></a>EXT2/3/4（Extended file system）</h4><p>扩展文件系统</p>
<h2 id="操作系统的设备管理"><a href="#操作系统的设备管理" class="headerlink" title="操作系统的设备管理"></a>操作系统的设备管理</h2><h3 id="广义的IO设备"><a href="#广义的IO设备" class="headerlink" title="广义的IO设备"></a>广义的IO设备</h3><h4 id="对CPU而言"><a href="#对CPU而言" class="headerlink" title="对CPU而言"></a>对CPU而言</h4><ul>
<li>凡是对CPU进行数据输入的都是输入设备</li>
<li>凡是CPU进行数据输出的都是输出设备</li>
</ul>
<h3 id="按使用特性分类"><a href="#按使用特性分类" class="headerlink" title="按使用特性分类"></a>按使用特性分类</h3><h4 id="存储设备"><a href="#存储设备" class="headerlink" title="存储设备"></a>存储设备</h4><ul>
<li>U盘（NTFS文件系统）</li>
<li>内存</li>
<li>磁盘<h4 id="交互IO设备"><a href="#交互IO设备" class="headerlink" title="交互IO设备"></a>交互IO设备</h4></li>
<li>键盘</li>
<li>显示器</li>
</ul>
<h3 id="按信息交换的单位分类"><a href="#按信息交换的单位分类" class="headerlink" title="按信息交换的单位分类"></a>按信息交换的单位分类</h3><h4 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h4><ul>
<li>磁盘</li>
<li>SD卡</li>
</ul>
<h4 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h4><ul>
<li>打印机</li>
<li>Shell终端</li>
</ul>
<h3 id="按设备的共享属性分类"><a href="#按设备的共享属性分类" class="headerlink" title="按设备的共享属性分类"></a>按设备的共享属性分类</h3><ul>
<li>独占设备</li>
<li>共享设备</li>
<li>虚拟设备</li>
</ul>
<h3 id="按传输速率分类"><a href="#按传输速率分类" class="headerlink" title="按传输速率分类"></a>按传输速率分类</h3><ul>
<li>低速设备</li>
<li>中速设备</li>
<li>高速设备    </li>
</ul>
<h3 id="IO设备的缓冲区"><a href="#IO设备的缓冲区" class="headerlink" title="IO设备的缓冲区"></a>IO设备的缓冲区</h3><p>解决CPU与IO设备的速率不匹配</p>
<ul>
<li>减少CPU处理IO请求的频率</li>
<li>提高CPU与IO设备之间的并行性</li>
<li>专用缓冲区只适用于特定的IO进程</li>
<li>当这样的IO进程比较多时，对内存的消耗也很大</li>
<li>操作系统划出可供多个进程使用的公共缓冲区，称之为缓存池</li>
</ul>
<h3 id="SPOOLing技术"><a href="#SPOOLing技术" class="headerlink" title="SPOOLing技术"></a>SPOOLing技术</h3><p>SPOOLing技术把同步调用低速设备改为异步调用</p>
<ul>
<li>关于慢速字符设备如何与计算机主机交换信息的一种技术</li>
<li>利用高速共享设备将低速的独享设备模拟为高速的共享设备</li>
<li>逻辑上,系统为每一个用户都分配了一台独立的高速独享设备    </li>
<li>在输入、输出之间增加了排队转储环节（输入井、输出井）    </li>
<li>SPOOLing 负责输入（出）井与低速设备之间的调度</li>
<li>逻辑上，进程直接与高速设备交互，减少了进程的等待时间</li>
</ul>
<h1 id="第六章操作系统之提升篇"><a href="#第六章操作系统之提升篇" class="headerlink" title="第六章操作系统之提升篇"></a>第六章操作系统之提升篇</h1><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><ul>
<li>原子性是指一系列操作不可被中断的特性</li>
<li>这一系列操作要么全部执行完成，要么全部没有执行</li>
<li>不存在部分执行部分未执行的情况</li>
</ul>
<h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><ul>
<li>互斥量是最简单的线程同步的方法</li>
<li>互斥量（互斥锁），处于两态之一的变量：解锁和加锁</li>
<li>两个状态可以保证资源访问的串行</li>
</ul>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><ul>
<li>自旋锁也是一种多线程同步的变量</li>
<li>使用自旋锁的线程会反复检查锁变量是否可用</li>
<li>自旋锁不会让出CPU，是一种忙等待状态</li>
<li>自旋锁避免了进程或线程上下文切换的开销</li>
<li>操作系统内部很多地方使用的是自旋锁</li>
<li>自旋锁不适合在单核cpu使用</li>
</ul>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><ul>
<li>读写锁是一种特殊的自旋锁</li>
<li>允许多个读者同时访问资源以提高读性能</li>
<li>对于写操作则是互斥的</li>
</ul>
<h2 id="线程同步之条件变量"><a href="#线程同步之条件变量" class="headerlink" title="线程同步之条件变量"></a>线程同步之条件变量</h2><ul>
<li>条件变量是一种相对复杂的线程同步方法</li>
<li>条件变量允许线程睡眠，直到满足某种条件</li>
<li>当满足条件时，可以向该线程信号，通知唤醒</li>
</ul>
<h2 id="线程同步资源总结"><a href="#线程同步资源总结" class="headerlink" title="线程同步资源总结"></a>线程同步资源总结</h2><p>互斥量、自旋锁、读写锁 都是在对临界资源进行加锁解锁操作</p>
<p>条件变量 是对条件变量进行加锁保护</p>
<h3 id="线程同步方法对比"><a href="#线程同步方法对比" class="headerlink" title="线程同步方法对比"></a>线程同步方法对比</h3><table>
<thead>
<tr>
<th align="center">同步方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">互斥锁</td>
<td align="center">最简单的一种线程同步方法，会阻塞线程</td>
</tr>
<tr>
<td align="center">自旋锁</td>
<td align="center">避免切换的一种线程同步方法，属于忙等待</td>
</tr>
<tr>
<td align="center">读写锁</td>
<td align="center">为“读多写少”的资源设计线程同步方法，可以显著提高性能</td>
</tr>
<tr>
<td align="center">条件变量</td>
<td align="center">相对复杂的一种线程同步方法，有更灵活的使用场景</td>
</tr>
</tbody></table>
<h2 id="使用fork系统调用创建进程"><a href="#使用fork系统调用创建进程" class="headerlink" title="使用fork系统调用创建进程"></a>使用fork系统调用创建进程</h2><ul>
<li>fork系统调用是用于创建进程的</li>
<li>fork创建的进程初始化状态与父进程一样</li>
<li>系统会为fork的进程分配新的资源</li>
</ul>
<p>C语言中fork函数会返回两次 ，第一次返回fork的子进程ID,第二次是子进程执行返回的0</p>
<h2 id="进程同步之共享内存"><a href="#进程同步之共享内存" class="headerlink" title="进程同步之共享内存"></a>进程同步之共享内存</h2><p>共享内存是高性能后台开发中最常用的进程同步的方式</p>
<ul>
<li>共享存储允许不相关的进程访问同一片物理内存</li>
<li>共享内存是两个进程之间共享和传递数据最快的方式</li>
<li>共享内存未提供同步机制，需要借助其他管理机制访问</li>
</ul>
<h3 id="使用共享内存步骤"><a href="#使用共享内存步骤" class="headerlink" title="使用共享内存步骤"></a>使用共享内存步骤</h3><ol>
<li>申请共享内存</li>
<li>连接到当前进程空间、使用共享内存</li>
<li>脱离进程空间</li>
<li>删除共享内存</li>
</ol>
<h2 id="进程同步之Unix域套接字"><a href="#进程同步之Unix域套接字" class="headerlink" title="进程同步之Unix域套接字"></a>进程同步之Unix域套接字</h2><ul>
<li>域套接字是一种高级的进程间通信的方法</li>
<li>Unix域套接字可以用于同一机器进程间通信</li>
<li>提供了单机可靠的进程通信同步服务</li>
</ul>
<h3 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a>相关信息</h3><ul>
<li>套接字（socket）原是网络通信中使用的术语</li>
<li>Unix系统提供的域套接字提供了网络套接字类似的功能</li>
</ul>
<h3 id="服务端使用套接字流程"><a href="#服务端使用套接字流程" class="headerlink" title="服务端使用套接字流程"></a>服务端使用套接字流程</h3><ol>
<li>创建套接字</li>
<li>绑定（bind）套接字</li>
<li>监听（listen）套接字</li>
<li>接受&amp;处理消息</li>
</ol>
<h3 id="客户端使用套接字流程"><a href="#客户端使用套接字流程" class="headerlink" title="客户端使用套接字流程"></a>客户端使用套接字流程</h3><ol>
<li>创建套接字</li>
<li>连接套接字</li>
<li>发送信息</li>
</ol>
<h1 id="第七章-计算机网络之概述篇"><a href="#第七章-计算机网络之概述篇" class="headerlink" title="第七章 计算机网络之概述篇"></a>第七章 计算机网络之概述篇</h1><h2 id="计算机网络的发展简史"><a href="#计算机网络的发展简史" class="headerlink" title="计算机网络的发展简史"></a>计算机网络的发展简史</h2><h3 id="互联网发展历史"><a href="#互联网发展历史" class="headerlink" title="互联网发展历史"></a>互联网发展历史</h3><ol>
<li>第一个阶段 单个网络（Arpanet）1969年诞生于美国军事基地</li>
<li>第二个阶段 三级结构互联网 </li>
<li>多层次ISP互联网络<ul>
<li>ISP (Internet Service Provider) 网络服务提供商</li>
<li>中国移动、中国电信、中国联通<h3 id="中国互联网发展历史"><a href="#中国互联网发展历史" class="headerlink" title="中国互联网发展历史"></a>中国互联网发展历史</h3></li>
</ul>
</li>
<li>1980年开始互联网实验</li>
<li>1989年第一个公共网络建立运行</li>
<li>1994年接入国际互联网</li>
</ol>
<h3 id="当前中国最大的五个网络"><a href="#当前中国最大的五个网络" class="headerlink" title="当前中国最大的五个网络"></a>当前中国最大的五个网络</h3><ul>
<li>中国电信互联网CHINANET</li>
<li>中国联通互联网UNINET</li>
<li>中国移动互联网CMNET</li>
<li>中国教育与科研计算机网CERNET</li>
<li>中国科学技术网CSTNET</li>
</ul>
<h2 id="层次结构设计的基本原理"><a href="#层次结构设计的基本原理" class="headerlink" title="层次结构设计的基本原理"></a>层次结构设计的基本原理</h2><h3 id="层次结构设计的目的"><a href="#层次结构设计的目的" class="headerlink" title="层次结构设计的目的"></a>层次结构设计的目的</h3><ul>
<li>保证数据通路顺畅</li>
<li>目的计算机状态</li>
<li>识别目的计算机</li>
<li>检查数据是否错误</li>
</ul>
<h3 id="层次结构设计的基本原则"><a href="#层次结构设计的基本原则" class="headerlink" title="层次结构设计的基本原则"></a>层次结构设计的基本原则</h3><ul>
<li>各层之间是相互独立的</li>
<li>每一层要有足够的灵活性</li>
<li>各层之间完全解耦</li>
</ul>
<h3 id="OSI7层网络模型"><a href="#OSI7层网络模型" class="headerlink" title="OSI7层网络模型"></a>OSI7层网络模型</h3><h4 id="OSI结构"><a href="#OSI结构" class="headerlink" title="OSI结构"></a>OSI结构</h4><ul>
<li>应用层 为计算机用户提供接口和服务</li>
<li>表示层 数据处理（编码解码、加密解密等）</li>
<li>会话层 管理（建立、维护、重连）通信会话</li>
<li>传输层 管理端到端的通信连接</li>
<li>网络层 数据路由（决定数据在网络的路径）</li>
<li>数据链路层 管理相邻节点之间的数据通信</li>
<li>物理层 数据通信的光电物理特效</li>
</ul>
<h4 id="OSI7层网络模型的遗憾"><a href="#OSI7层网络模型的遗憾" class="headerlink" title="OSI7层网络模型的遗憾"></a>OSI7层网络模型的遗憾</h4><ul>
<li>OSI欲成为全球计算机都遵循的标准</li>
<li>OSI在市场化过程中困难重重，TCP/IP在全球范围成功运行</li>
<li>OSI最终并没有成为广为使用的标准模型</li>
</ul>
<h4 id="OSI失败的原因"><a href="#OSI失败的原因" class="headerlink" title="OSI失败的原因"></a>OSI失败的原因</h4><ul>
<li>OSI专家缺乏实际经验</li>
<li>OSI标准制定周期过长，按OSI标准生产的设备无法及时进入市场</li>
<li>OSI模型设计的不合理，一些功能在多层中重复出现</li>
</ul>
<h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h3><h4 id="组成-2"><a href="#组成-2" class="headerlink" title="组成"></a>组成</h4><ul>
<li>应用层 （HTTP、FTP、SMTP、POP3/）</li>
<li>传输层 （TCP、UDP）</li>
<li>网络层 （IP）</li>
<li>网络接口层 （Ethernet、PPP）</li>
</ul>
<h2 id="现代互联网的网络拓扑"><a href="#现代互联网的网络拓扑" class="headerlink" title="现代互联网的网络拓扑"></a>现代互联网的网络拓扑</h2><h3 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h3><h4 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h4><ul>
<li>终端机器</li>
<li>路由器</li>
<li>网关</li>
<li>地区ISP</li>
</ul>
<h4 id="企业"><a href="#企业" class="headerlink" title="企业"></a>企业</h4><ul>
<li>终端机器</li>
<li>路由器</li>
<li>网关<ul>
<li>内部网关</li>
<li>统一网关</li>
</ul>
</li>
<li>地区ISP</li>
</ul>
<h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3><ul>
<li>主干ISP</li>
<li>路由器</li>
</ul>
<h3 id="站在用户角度看网络模式"><a href="#站在用户角度看网络模式" class="headerlink" title="站在用户角度看网络模式"></a>站在用户角度看网络模式</h3><ul>
<li>客户端/服务器（C/S） 模式</li>
<li>点对点（P2P）模式 ，通常用于下载</li>
</ul>
<h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><h3 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h3><p>网络使用的速度单位 bps= bit/s 每秒传输多少bit</p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><h4 id="发送时延"><a href="#发送时延" class="headerlink" title="发送时延"></a>发送时延</h4><p>发送时延=（数据长度（bit）/发送速率（bit/s））</p>
<blockquote>
<p>发送速率受限于计算机网卡</p>
</blockquote>
<h4 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h4><p>传播时延=（传输路径距离/传播速率（bit/s））</p>
<blockquote>
<p>传播速率受限于传输介质</p>
</blockquote>
<h4 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h4><p>数据包在网络设备中等待被处理的时间</p>
<h4 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h4><p>数据包到达设备或者目的机器被处理所需要的时间</p>
<h3 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h3><ul>
<li>RTT(Route-Trip Time) 是评估网络质量的一项重要指标</li>
<li>RTT表示的是数据报文在端到端通信中的来回一次的时间</li>
<li>通常使用ping命令查看RTT</li>
</ul>
<h2 id="物理层的概述"><a href="#物理层的概述" class="headerlink" title="物理层的概述"></a>物理层的概述</h2><h3 id="物理层的作用"><a href="#物理层的作用" class="headerlink" title="物理层的作用"></a>物理层的作用</h3><ul>
<li>连接不同的物理设备</li>
<li>传输bit流</li>
</ul>
<h4 id="物理层传输介质"><a href="#物理层传输介质" class="headerlink" title="物理层传输介质"></a>物理层传输介质</h4><h5 id="有线介质"><a href="#有线介质" class="headerlink" title="有线介质"></a>有线介质</h5><ul>
<li>双绞线(无屏蔽双绞线、有屏蔽双绞线)</li>
<li>同轴电缆</li>
<li>光钎</li>
</ul>
<h5 id="无线介质"><a href="#无线介质" class="headerlink" title="无线介质"></a>无线介质</h5><ul>
<li>红外线</li>
<li>无线</li>
<li>激光</li>
</ul>
<h4 id="比特流"><a href="#比特流" class="headerlink" title="比特流"></a>比特流</h4><h3 id="信道的基本概念"><a href="#信道的基本概念" class="headerlink" title="信道的基本概念"></a>信道的基本概念</h3><ul>
<li>信道是往一个方向传送信息的媒体</li>
<li>一条通信电路包含一个接收信道和一个发送信道</li>
</ul>
<h4 id="信道分类"><a href="#信道分类" class="headerlink" title="信道分类"></a>信道分类</h4><h5 id="单工通信信道"><a href="#单工通信信道" class="headerlink" title="单工通信信道"></a>单工通信信道</h5><ul>
<li>只能一个方向通信，没有反方向反馈的信道</li>
<li>有线电视、无线电收音机等等</li>
</ul>
<h5 id="半双工通信信道"><a href="#半双工通信信道" class="headerlink" title="半双工通信信道"></a>半双工通信信道</h5><ul>
<li>双方都可以发送和接收信息</li>
<li>不能双方同时发送，也不能同时接收</li>
</ul>
<h5 id="全双工通信信道"><a href="#全双工通信信道" class="headerlink" title="全双工通信信道"></a>全双工通信信道</h5><ul>
<li>双方都可以同时发送和接收信息</li>
</ul>
<h3 id="分用-复用技术"><a href="#分用-复用技术" class="headerlink" title="分用-复用技术"></a>分用-复用技术</h3><ul>
<li>频分复用</li>
<li>时分复用</li>
<li>波分复用</li>
<li>码分复用</li>
</ul>
<h2 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><ul>
<li>“帧” 是数据链路层数据的基本单位</li>
<li>发送端在网络层的一段数据前后添加特定标记形成“帧”</li>
<li>接收端根据前后特定标记识别出“帧”</li>
</ul>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><ul>
<li>“透明”在计算机领域是一个非常重要的一个术语</li>
<li>控制字符在帧数据中，但要当做不存在去处理</li>
</ul>
<h3 id="差错监测"><a href="#差错监测" class="headerlink" title="差错监测"></a>差错监测</h3><ul>
<li>物理层只管传输比特流，无法控制是否出错</li>
<li>数据链路层负责起“差错监测”的工作</li>
</ul>
<h2 id="数据链路层的差错监测"><a href="#数据链路层的差错监测" class="headerlink" title="数据链路层的差错监测"></a>数据链路层的差错监测</h2><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>在bit流的最后添加一位来标识数据奇偶性</p>
<h3 id="循环冗余校验码CRC"><a href="#循环冗余校验码CRC" class="headerlink" title="循环冗余校验码CRC"></a>循环冗余校验码CRC</h3><ul>
<li>一种根据传输或保存的数据而产生固定位数校验码的方法</li>
<li>检测数据传输或者保存后可能出现的错误</li>
<li>生成的数字计算出来并且附加到数据后面</li>
<li>CRC的错误检测能力与位串的阶数r有关</li>
<li>数据链路层只进行数据的检测，不进行纠正，如果数据出错，直接丢弃</li>
</ul>
<h2 id="最大传输单元MTU"><a href="#最大传输单元MTU" class="headerlink" title="最大传输单元MTU"></a>最大传输单元MTU</h2><h3 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h3><ul>
<li>最大传输单元MTU（Maximum Transmission Unit）</li>
<li>数据链路层的数据帧也不是无限大的</li>
<li>数据帧过大过小都会影响传输的效率<blockquote>
<p>以太网MTU一般为1500字节</p>
</blockquote>
</li>
</ul>
<h3 id="路径MTU"><a href="#路径MTU" class="headerlink" title="路径MTU"></a>路径MTU</h3><p>路径MTU由链路中MTU的最小值决定</p>
<h2 id="以太网协议详解"><a href="#以太网协议详解" class="headerlink" title="以太网协议详解"></a>以太网协议详解</h2><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><ul>
<li>物理地址、硬件地址</li>
<li>每个设备都拥有唯一的MAC地址</li>
</ul>
<h3 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h3><ul>
<li>以太网（Ethernet）是一种使用广泛的局域网技术</li>
<li>以太网是一种应用于数据链路层的协议</li>
<li>使用以太网可以完成相邻设备的数据帧传输</li>
</ul>
<h3 id="基于以太网协议的数据结构"><a href="#基于以太网协议的数据结构" class="headerlink" title="基于以太网协议的数据结构"></a>基于以太网协议的数据结构</h3><ul>
<li>目的地址（6byte）+源地址（6）+类型（2）+帧数据（46-1500）+CRC（4）</li>
</ul>
<h3 id="以太网协议工作过程"><a href="#以太网协议工作过程" class="headerlink" title="以太网协议工作过程"></a>以太网协议工作过程</h3><ol>
<li>A通过网卡发出数据帧</li>
<li>数据帧到达路由器，路由器取出前6个字节</li>
<li>路由器匹配MAC地址表，找到对应的网络接口</li>
<li>路由器往该网络接口发送数据帧</li>
</ol>
<h3 id="路由器中mac地址表无映射数据的情况"><a href="#路由器中mac地址表无映射数据的情况" class="headerlink" title="路由器中mac地址表无映射数据的情况"></a>路由器中mac地址表无映射数据的情况</h3><ol>
<li>E检查MAC地址表中，发现没有C的信息</li>
<li>E将广播A的数据包到除A以外的端口</li>
<li>E将收到来自B、C的回应，并将地址记录</li>
</ol>
<h1 id="第八章-计算机网络之网络层"><a href="#第八章-计算机网络之网络层" class="headerlink" title="第八章 计算机网络之网络层"></a>第八章 计算机网络之网络层</h1><h2 id="IP协议详解"><a href="#IP协议详解" class="headerlink" title="IP协议详解"></a>IP协议详解</h2><h3 id="虚拟互联网络"><a href="#虚拟互联网络" class="headerlink" title="虚拟互联网络"></a>虚拟互联网络</h3><ul>
<li>IP协议使得复杂的实际网络变为一个虚拟互联的网络</li>
<li>IP协议使得网络层可以屏蔽底层细节而专注网络层的数据转发</li>
<li>IP协议解决了在虚拟网络中数据报传输路径的问题</li>
</ul>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><h3 id="数据帧-帧首部-帧数据-帧尾部"><a href="#数据帧-帧首部-帧数据-帧尾部" class="headerlink" title="数据帧=帧首部+帧数据+帧尾部"></a>数据帧=帧首部+帧数据+帧尾部</h3><h3 id="帧数据-IP数据报-IP首部-IP数据报的数据"><a href="#帧数据-IP数据报-IP首部-IP数据报的数据" class="headerlink" title="帧数据(IP数据报)=IP首部+IP数据报的数据"></a>帧数据(IP数据报)=IP首部+IP数据报的数据</h3><h3 id="IP首部-4位版本-4位首部长度-8位服务类型-TCP-UDP-16位总长度"><a href="#IP首部-4位版本-4位首部长度-8位服务类型-TCP-UDP-16位总长度" class="headerlink" title="IP首部=4位版本+4位首部长度+8位服务类型(TCP/UDP)+16位总长度"></a>IP首部=4位版本+4位首部长度+8位服务类型(TCP/UDP)+16位总长度</h3><p>如果ip数据报的数据超过2^16,会进行ip数据分片传输</p>
<h2 id="IP协议的转发流程"><a href="#IP协议的转发流程" class="headerlink" title="IP协议的转发流程"></a>IP协议的转发流程</h2><h3 id="路由表的简介"><a href="#路由表的简介" class="headerlink" title="路由表的简介"></a>路由表的简介</h3><p>路由表工作在网络层,存储目的ip地址和下一跳ip地址的映射关系</p>
<h3 id="IP协议的转发流程-1"><a href="#IP协议的转发流程-1" class="headerlink" title="IP协议的转发流程"></a>IP协议的转发流程</h3><p>逐跳过程</p>
<h2 id="IP地址的子网划分"><a href="#IP地址的子网划分" class="headerlink" title="IP地址的子网划分"></a>IP地址的子网划分</h2><h3 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h3><table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">网络号</th>
<th align="center">主机号</th>
<th align="center">标识</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A类地址</td>
<td align="center">8</td>
<td align="center">24</td>
<td align="center">首位为0</td>
</tr>
<tr>
<td align="center">B类地址</td>
<td align="center">16</td>
<td align="center">16</td>
<td align="center">首位为10</td>
</tr>
<tr>
<td align="center">C类地址</td>
<td align="center">24</td>
<td align="center">8</td>
<td align="center">首位为110</td>
</tr>
<tr>
<td align="center">### 特殊的主机号</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">* 主机号全0表示当前网络,不可分配为特定主机</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">* 主机号为全1表示广播地址,向当前网络段所有主机发送消息</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="特殊的网络号"><a href="#特殊的网络号" class="headerlink" title="特殊的网络号"></a>特殊的网络号</h3><ul>
<li>A类地址网络段全0表示特殊网络</li>
<li>A类地址网络段后7位全1(127)表示本地回环地址</li>
<li>B类地址网络端(128.0)是不可以使用的</li>
<li>C类地址网络段(192.0.0)是不可以使用的</li>
</ul>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>子网掩码的作用是用于快速计算ip地址的网络号</p>
<h3 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h3><ul>
<li>CIDR没有A,B,C类网络号,和子网划分的概念</li>
<li>CIDR将网络前缀相同的IP地址称为一个”CIDR地址块”</li>
<li>192.168.11.36/24 “/“为CIDR记法</li>
</ul>
<h2 id="ARP协议与RARP协议"><a href="#ARP协议与RARP协议" class="headerlink" title="ARP协议与RARP协议"></a>ARP协议与RARP协议</h2><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><ul>
<li>ARP(Address Resolution Protocol) 地址解析协议</li>
<li>将”网络层IP32位地址” 通过ARP协议转换为 “数据链路层MAC48位地址”</li>
<li>ARP缓存表存有IP地址和MAC地址的映射关系</li>
</ul>
<h3 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h3><ul>
<li>逆地址解析协议</li>
</ul>
<h2 id="网络地址转换NAT技术"><a href="#网络地址转换NAT技术" class="headerlink" title="网络地址转换NAT技术"></a>网络地址转换NAT技术</h2><p>由于IP地址不够使用,而衍生出的技术</p>
<ul>
<li>网络地址转换技术NAT(Network Address Translation)</li>
<li>NAT技术用于多个主机通过一个公有IP访问互联网的私有网络中</li>
<li>NAT技术减缓了IP地址的消耗,但是增加了网络通信的复杂度</li>
</ul>
<h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><ul>
<li>网络控制报文协议(Internet Control Message Protocol)</li>
<li>ICMP协议可以报告错误信息或者异常信息</li>
<li>ping 应用</li>
<li>tracerote 应用</li>
</ul>
<h2 id="网络层的路由概述"><a href="#网络层的路由概述" class="headerlink" title="网络层的路由概述"></a>网络层的路由概述</h2><h2 id="内部网关路由协议之RIP协议"><a href="#内部网关路由协议之RIP协议" class="headerlink" title="内部网关路由协议之RIP协议"></a>内部网关路由协议之RIP协议</h2><h1 id="第11章-计算机网络之传输层"><a href="#第11章-计算机网络之传输层" class="headerlink" title="第11章 计算机网络之传输层"></a>第11章 计算机网络之传输层</h1><h2 id="UDP协议详解"><a href="#UDP协议详解" class="headerlink" title="UDP协议详解"></a>UDP协议详解</h2><ul>
<li>UDP(User Datagram Protocol: 用户数据报协议)</li>
<li>UDP是一个非常简单的协议</li>
<li>UDP是无连接的协议</li>
<li>UDP不能保证可靠的交付数据</li>
<li>UDP是面向报文传输的</li>
<li>UDP没有拥塞控制</li>
<li>UDP首部开销很小</li>
</ul>
<h2 id="TCP协议详解"><a href="#TCP协议详解" class="headerlink" title="TCP协议详解"></a>TCP协议详解</h2><ul>
<li>TCP(Transmission Control Protocol:传输控制协议)</li>
<li>TCP协议是计算机网络中非常复杂的一个协议</li>
<li>TCP是面向连接的协议</li>
<li>TCP的一个连接有两端(点对点通信)</li>
<li>TCP提供可靠的传输服务</li>
<li>TCP协议提供全双工的通信</li>
<li>TCP是面字节流的协议</li>
</ul>
<p>序号（sequence number）：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。<br>确认号（acknowledgement number）：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。  </p>
<table>
<thead>
<tr>
<th align="center">标记</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">URG</td>
<td align="center">Urgent:紧急位,URG=1,表示紧急数据</td>
</tr>
<tr>
<td align="center">ACK</td>
<td align="center">Acknowledgement:确认位,ACK=1,确认号才生效</td>
</tr>
<tr>
<td align="center">PSH</td>
<td align="center">Push:推送位,PSH=1,尽快吧数据交付给应用层</td>
</tr>
<tr>
<td align="center">PST</td>
<td align="center">Reset:重置位,RST=1,重新建立连接</td>
</tr>
<tr>
<td align="center">SYN</td>
<td align="center">Synchronization:同步位,SYN=1表示连接请求报文</td>
</tr>
<tr>
<td align="center">FIN</td>
<td align="center">Finish:终止位,FIN=1表示释放连接</td>
</tr>
</tbody></table>
<h2 id="可靠传输的基本原理"><a href="#可靠传输的基本原理" class="headerlink" title="可靠传输的基本原理"></a>可靠传输的基本原理</h2><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><ul>
<li>每发送一个消息,都需要设置一个定时器</li>
<li>最简单的可靠传输协议</li>
<li>对信道利用效率不高</li>
</ul>
<h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><ul>
<li>滑动窗口</li>
<li>累计确认</li>
</ul>
<h2 id="TCP协议的可靠传输"><a href="#TCP协议的可靠传输" class="headerlink" title="TCP协议的可靠传输"></a>TCP协议的可靠传输</h2><ul>
<li>TCP的可靠传输基于连续ARQ协议</li>
<li>TCP的滑动窗口以字节为单位</li>
</ul>
<h3 id="TCP协议的选择重传"><a href="#TCP协议的选择重传" class="headerlink" title="TCP协议的选择重传"></a>TCP协议的选择重传</h3><h3 id="TCP协议的流量控制"><a href="#TCP协议的流量控制" class="headerlink" title="TCP协议的流量控制"></a>TCP协议的流量控制</h3><ul>
<li>流量控制指让发送方发送速率不要太快</li>
<li>流量控制是使用滑动窗口来实现的</li>
</ul>
<h3 id="坚持定时器"><a href="#坚持定时器" class="headerlink" title="坚持定时器"></a>坚持定时器</h3><ul>
<li>当接收到窗口为0的消息,则启动坚持定时器</li>
<li>坚持定时器每隔一段时间发送一个窗口探测报文</li>
</ul>
<h2 id="TCP协议的拥塞控制"><a href="#TCP协议的拥塞控制" class="headerlink" title="TCP协议的拥塞控制"></a>TCP协议的拥塞控制</h2><p>报文超时则任务是拥塞  </p>
<ul>
<li>一条数据链路经过非常多的设备</li>
<li>数据链路中各个部分都有可能成为网络传输的瓶颈</li>
</ul>
<h3 id="拥塞控制对比流量控制"><a href="#拥塞控制对比流量控制" class="headerlink" title="拥塞控制对比流量控制"></a>拥塞控制对比流量控制</h3><ul>
<li>流量控制考虑点对点的通信量的控制</li>
<li>拥塞控制考虑整个网络,是全局性的考虑</li>
</ul>
<h3 id="慢启动算法"><a href="#慢启动算法" class="headerlink" title="慢启动算法"></a>慢启动算法</h3><ul>
<li>由小到达逐渐增加发送数据量</li>
<li>每收到一个报文确认,就加一</li>
</ul>
<h3 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h3><ul>
<li>维护一个拥塞窗口的变量</li>
<li>只要网络不拥塞,就试探着拥塞窗口调大</li>
</ul>
<h2 id="TCP连接的三次握手"><a href="#TCP连接的三次握手" class="headerlink" title="TCP连接的三次握手"></a>TCP连接的三次握手</h2><h3 id="三次握手的过程"><a href="#三次握手的过程" class="headerlink" title="三次握手的过程"></a>三次握手的过程</h3><ol>
<li>发送方 发送: SYN=1,seq=x </li>
<li>接收方 回应: SYN=1,seq=y,ack=x+1</li>
<li>发送方 发送: ACK=1,seq=x+1,ack=y+1</li>
</ol>
<h3 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h3><p>已经失效的连接请求报文传送到对方,引起错误<br>如果不进行第三次握手,就会导致一个现象,发送方发送的连接请求由于网络原因(超时重传),发送多个连接请求,导致建立多个连接.</p>
<h2 id="TCP连接的四次挥手"><a href="#TCP连接的四次挥手" class="headerlink" title="TCP连接的四次挥手"></a>TCP连接的四次挥手</h2><h3 id="TCP-连接的释放"><a href="#TCP-连接的释放" class="headerlink" title="TCP 连接的释放"></a>TCP 连接的释放</h3><ol>
<li>发送方 发送:FIN=1,seq=u</li>
<li>接收方 回应:ACK=1,seq=v,ack=u+1</li>
<li>接收方 发送:FIN=1,ACK=1,seq=w,ack=u+1</li>
<li>发送方 回应:ACK=1,seq=u+1,ack=w+1<h3 id="为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？"><a href="#为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？" class="headerlink" title="为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？"></a>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</h3>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。<br>但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</li>
</ol>
<h3 id="等待计时器-TIME-WAIT"><a href="#等待计时器-TIME-WAIT" class="headerlink" title="等待计时器(TIME-WAIT)"></a>等待计时器(TIME-WAIT)</h3><ul>
<li>等待计时器会等待2MSL的时间,接收方发送(FIN=1,ACK=1,seq=w,ack=u+1)会等待 2MSL的时间,如果超时都还没有收到发送方的消息,则重新发送FIN</li>
<li>MSL(Max Segment Lifetime) 最长报文寿命</li>
</ul>
<h3 id="为什么需要等待2MSL"><a href="#为什么需要等待2MSL" class="headerlink" title="为什么需要等待2MSL"></a>为什么需要等待2MSL</h3><ul>
<li>最后一个报文没有确认</li>
<li>确保发送方的ACK可以到达接收方</li>
<li>2MSL时间内没有收到,则接收方会重发</li>
<li>确保当前连接的所有报文都已经过期</li>
</ul>
<h2 id="套接字与套接字编程"><a href="#套接字与套接字编程" class="headerlink" title="套接字与套接字编程"></a>套接字与套接字编程</h2><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><ul>
<li>使用端口(Port)来标记不同的网络编程</li>
<li>端口(Port)使用16bit表示(0~65535)</li>
<li>{IP:Port}=套接字</li>
</ul>
<h3 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><ol>
<li>创建套接字  </li>
<li>绑定(bind)套接字  </li>
<li>监听(listen)套接字</li>
<li>接收&amp;处理信息</li>
</ol>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ol>
<li>创建套接字  </li>
<li>连接套接字</li>
<li>发送信息</li>
</ol>
<h2 id="网络套接字与域套接字"><a href="#网络套接字与域套接字" class="headerlink" title="网络套接字与域套接字"></a>网络套接字与域套接字</h2><ul>
<li>网络套接字通过网络通信</li>
<li>域套接字通过域套接字文件通信</li>
</ul>
<h2 id="TCP协议的四个定时器"><a href="#TCP协议的四个定时器" class="headerlink" title="TCP协议的四个定时器"></a>TCP协议的四个定时器</h2><h3 id="超时定时器"><a href="#超时定时器" class="headerlink" title="超时定时器"></a>超时定时器</h3><p>超时定时器主要应用在TCP的可靠传输协议里面,是为了控制可能发生丢失的报文二设计的定时器,当TCP协议发送端发送一个报文时,就会为该报文设置一个超时定时器.<br>如果超时定时器结束之前收到了来自接收端对改报文段的去人,则撤销这个定时器.<br>如果超时定时器结束是任然没有收到来自接收端对该报文段的确认(超时),则任务这个报文可能已经丢弃,发送段重新发送博爱文,并重新设置一个超时定时器<br>需要注意的是,发送端在超时定时器撤销之前,必须继续缓存已发送未确认的报文,知道发送单收到了来自接收端的确认</p>
<h3 id="坚持定时器-1"><a href="#坚持定时器-1" class="headerlink" title="坚持定时器"></a>坚持定时器</h3><p>要理解坚持定时器，需要理解“零窗口通知”的情况。我们知道接收端通过调整接收窗口的大小可以控制发送端的发送速度，当接收端把接收窗口调小时，那么发送端就会调小发送的流量。<br>这就可能产生一种情况，就是接收端的缓存区已经满了，这个时候接收端会给发送端发送一个“零窗口”的消息，表示说“当前我已经没有余力处理更多的数据了”，这就是“零窗口通知”的情况。<br>当出现这种情况的时候，双方都会陷入等待的状态，发送端等待接收端的窗口调大，接收端等待发送端发送的数据。当接收端窗口可以调大的时候，接收端会发送窗口调大的信息给发送端，但是这个消息是不可靠的，也即是这个消息可能会在传输中丢失，并且不会被感知到丢失和重传。<br>如果这个消息在发送过程中丢失的话，那么发送端和接收端就会进入死锁状态，因为接收端认为“我已经把窗口调大的消息发送出去了，发送端理应发送新的消息给我才对”，所以接收端会一直等待发送端的消息；而发送端因为没有收到窗口调大的消息，则认为“接收端还没有调大窗口，因此我不能发送”，发送端也会一直等待。<br>因此为了解决这个问题，当发送端收到窗口为零的消息之后，会启动一个坚持定时器来周期性主动的向接收方查询，以便发现窗口是否增大，这个就是坚持定时器的作用。  </p>
<h3 id="时间等待计时器"><a href="#时间等待计时器" class="headerlink" title="时间等待计时器"></a>时间等待计时器</h3><p>时间等待计时器(Time-Wait)是由主动关闭TCP连接的一方设置的，当主动关闭TCP连接的一方收到来自对方的FIN报文的时候（第三次挥手），则认为对方也可以关闭TCP连接，这个时候主动关闭TCP连接的一方发送一个消息确认的报文（第四次挥手），并启动这个时间等待计时器，这个计时器会等待2倍MSL的时间，MSL(Max Segment Lifetime)，最大报文段寿命。<br>以下为方便讨论，我们把主动关闭的一方称为A，被动关闭的一方称为B。<br>这个定时器主要是为了正确关闭一个TCP连接而考虑的，这主要是为了保证A在对最后一个FIN报文（第三次挥手）发送确认的报文可以到达B。<br>当A发出这个报文之后，就会启动2MSL计时器，注意，这个报文是有可能在网络传输过程中丢失的，如果B收不到这个确认，那么B会重新发送一次FIN报文，A会重新收到这个报文并重传一次最后的确认，并重新启动2MSL计时器，直到双方正常结束TCP连接。2MSL时间可以保证当B没有收到确认时，B可以再次发出FIN报文，并且A可以再次收到并重新发送确认，所以2MSL的时间可以保证连接正常结束。  </p>
<h3 id="保活计时器"><a href="#保活计时器" class="headerlink" title="保活计时器"></a>保活计时器</h3><p>活计时器，顾名思义，保活是这个计时器的主要目的，他是为了保活TCP连接而设计的，保活定时器可以防止TCP连接的两端出现长时期的空闲，当一方出现状态变化或故障时，另一方没有察觉的情况。<br>设想连接双方在建立连接后，只传输了一些数据，然后就都保持静默了，双方也都没有关闭连接（这种情况经常存在），如果这个时候其中一方已经故障，那么这个连接将会永远被打开，如果被连接的一方是服务端的话，那将浪费很多服务端的资源。<br>因此为了解决这个问题，服务端一般都会设置一个保活定时器，每次收到对方的数据则重置这个定时器，如果定时器超时，服务端则发送探测报文段，探测客户端是否还在线，如果没有收到响应的话，那么则认为客户端已经断开连接了，因此服务端也会终止这个连接。<br>保活定时器其实有很广泛的应用，在今天，很多的分布式系统，都会使用保活定时器来检测其他节点是否在线还是已经故障，或者其他节点也会每隔一段时间向主节点上报心跳信息以证明在线，这些都是保活定时器在更多领域的广泛应用。  </p>
<h1 id="第12章-计算机网络之应用层篇"><a href="#第12章-计算机网络之应用层篇" class="headerlink" title="第12章 计算机网络之应用层篇"></a>第12章 计算机网络之应用层篇</h1><h2 id="DNS详解"><a href="#DNS详解" class="headerlink" title="DNS详解"></a>DNS详解</h2><ul>
<li>DNS(Domain Name System:域名系统)</li>
</ul>
<h2 id="DHCP协议详解"><a href="#DHCP协议详解" class="headerlink" title="DHCP协议详解"></a>DHCP协议详解</h2><ul>
<li>DHCP(Dynamic Host Configuration Protocol: 动态主机设置协议)</li>
<li>DHCP 是一个局域网协议</li>
<li>DHCP 是应用UDP协议的应用层协议</li>
</ul>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul>
<li>DHCP服务器监听默认端口：67</li>
<li>主机使用UDP协议广播DHCP发现报文</li>
<li>DHCP服务器发出DHCP提供报文头</li>
<li>主机向DHCP服务器发出DHCP请求报文</li>
<li>DHCP服务器回应并提供IP地址</li>
</ul>
<h2 id="HTTP协议详解"><a href="#HTTP协议详解" class="headerlink" title="HTTP协议详解"></a>HTTP协议详解</h2><ul>
<li>HTTP(HyperText Transfer Protocol:超文本传输协议)</li>
<li>http(s)://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</li>
<li>HTTP协议是可靠的数据传输协议（基于TCP协议）</li>
</ul>
<h3 id="Web服务器服务过程"><a href="#Web服务器服务过程" class="headerlink" title="Web服务器服务过程"></a>Web服务器服务过程</h3><p>1.接收客户端连接<br>2.接收请求报文<br>3.处理请求<br>4.访问web资源<br>5.构造应答<br>6.发送应答</p>
<h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><ul>
<li>GET 获取指定的服务端资源</li>
<li>POST 提交数据到服务端</li>
<li>DELETE 删除指定的服务端资源</li>
<li>UPDATE 更新指定的服务端资源</li>
<li>PUT</li>
<li>OPTIONS</li>
<li>PATCH</li>
<li>HEAD</li>
<li>TRACE</li>
</ul>
<h2 id="HTTP工作的结构"><a href="#HTTP工作的结构" class="headerlink" title="HTTP工作的结构"></a>HTTP工作的结构</h2><h3 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h3><h3 id="Web代理"><a href="#Web代理" class="headerlink" title="Web代理"></a>Web代理</h3><ul>
<li>正向代理 为客户端进行代理</li>
<li>反向代理 为服务器进行代理</li>
</ul>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><ul>
<li>CDN (Content Delivery Network :内容分发网络)</li>
</ul>
<h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><h2 id="HTTPS协议详解"><a href="#HTTPS协议详解" class="headerlink" title="HTTPS协议详解"></a>HTTPS协议详解</h2><ul>
<li>HTTP是明文传输的</li>
<li>HTTPS(Secure)是安全的HTTP协议</li>
<li>HTTPS 应用了对称和非对称加密的算法，通过非对称加密算法交换密钥，生成对称加密秘钥，然后使用对称加密秘钥加密数据，进行传输</li>
</ul>
<h3 id="加密模型"><a href="#加密模型" class="headerlink" title="加密模型"></a>加密模型</h3><ul>
<li>对称加密（数据加密解密使用同一秘钥）</li>
<li>非对称加密（秘钥不一致）<ul>
<li>私钥 </li>
<li>公钥<blockquote>
<p>私钥和公钥是具有一定数学关系</p>
</blockquote>
</li>
</ul>
</li>
<li>数字证书是可信性组织颁发给特定对象的认证，证书内容<ul>
<li>证书格式，版本号</li>
<li>证书序列号</li>
<li>签名算法</li>
<li>有效期</li>
<li>对象名称</li>
<li>对象公开秘钥    </li>
</ul>
</li>
</ul>
<h3 id="SSL-Secure-Sockets-Layer-安全套接层"><a href="#SSL-Secure-Sockets-Layer-安全套接层" class="headerlink" title="SSL(Secure Sockets Layer:安全套接层)"></a>SSL(Secure Sockets Layer:安全套接层)</h3><ul>
<li>数据安全和数据完整</li>
<li>对传输层数据进行加密传输</li>
</ul>
<h3 id="HTTPS-传输过程"><a href="#HTTPS-传输过程" class="headerlink" title="HTTPS 传输过程"></a>HTTPS 传输过程</h3><p>1.443端口的TCP连接<br>2.SSL安全参数握手<br>3.客户端发送数据<br>4.服务端发送数据 </p>
<h3 id="SSL安全参数握手过程"><a href="#SSL安全参数握手过程" class="headerlink" title="SSL安全参数握手过程"></a>SSL安全参数握手过程</h3><p>1.客户端=&gt;服务端：随机数1,，协议版本，加密算法<br>2.服务端=&gt;客户端：随机数2，数字证书，确定加密算法<br>3.客户端确认证书是否有效;生成随机数3;使用服务器公钥加密随机数3<br>4.客户端=&gt;服务端：发送随机数3</p>
<blockquote>
<p>客户端和服务端根据随机数1,2,3 生成对称秘钥，用于后面数据传输</p>
</blockquote>
<h1 id="第13章-计算机网络实践"><a href="#第13章-计算机网络实践" class="headerlink" title="第13章 计算机网络实践"></a>第13章 计算机网络实践</h1>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
        <tag>操作系统</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql/MySQL在什么情况下会使用到临时表</title>
    <url>/2020/04/01/mysql/MySQL%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%88%B0%E4%B8%B4%E6%97%B6%E8%A1%A8/</url>
    <content><![CDATA[<p>MySQL在执行SQL查询时可能会用到临时表，一般情况下，用到临时表就意味着性能较低。临时表存储，MySQL临时表分为“内存临时表”和“磁盘临时表”，<br>其中内存临时表使用MySQL的MEMORY存储引擎，磁盘临时表使用MySQL的MyISAM存储引擎；</p>
<a id="more"></a>

<p> 一般情况下，MySQL会先创建内存临时表，但内存临时表超过配置指定的值后，MySQL会将内存临时表导出到磁盘临时表；<br> Linux平台上缺省是/tmp目录，/tmp目录小的系统要注意啦。  </p>
<h3 id="使用临时表的场景"><a href="#使用临时表的场景" class="headerlink" title="使用临时表的场景"></a>使用临时表的场景</h3><ul>
<li>ORDER BY子句和GROUP BY子句不同， 例如：ORDERY BY price GROUP BY name；   </li>
<li>在JOIN查询中，ORDER BY或者GROUP BY使用了不是第一个表的列 例如：SELECT * from TableA, TableB ORDER BY TableA.price GROUP by TableB.name<br>（我在测试的时候发现即使是使用第一个表的列，也会使用到临时表）</li>
<li>ORDER BY中使用了DISTINCT关键字 ORDERY BY DISTINCT(price)  </li>
<li>SELECT语句中指定了SQL_SMALL_RESULT关键字 SQL_SMALL_RESULT的意思就是告诉MySQL，结果会很小，请直接使用内存临时表，<br>不需要使用索引排序 SQL_SMALL_RESULT必须和GROUP BY、DISTINCT或DISTINCTROW一起使用 一般情况下，我们没有必要使用这个选项，<br>让MySQL服务器选择即可。  </li>
<li>当group by 索引的时候，当数据量较小的时候不会使用临时表，当数据量（我测试的数据量在30万左右）大的时候会使用临时表</li>
<li>当group by 不是索引的时候会使用临时表  </li>
</ul>
<h3 id="直接使用磁盘临时表的场景"><a href="#直接使用磁盘临时表的场景" class="headerlink" title="直接使用磁盘临时表的场景"></a>直接使用磁盘临时表的场景</h3><ul>
<li>表包含TEXT或者BLOB列；</li>
<li>GROUP BY 或者 DISTINCT 子句中包含长度大于512字节的列</li>
<li>使用UNION或者UNION ALL时，SELECT子句中包含大于512字节的列；</li>
</ul>
<h3 id="临时表相关配置"><a href="#临时表相关配置" class="headerlink" title="临时表相关配置"></a>临时表相关配置</h3><ul>
<li>tmp_table_size 指定系统创建的内存临时表最大大小；</li>
<li>max_heap_table_size 指定用户创建的内存表的最大大小；<blockquote>
<p>注意：最终的系统创建的内存临时表大小是取上述两个配置值的最小值。</p>
</blockquote>
</li>
</ul>
<h3 id="表的设计原则"><a href="#表的设计原则" class="headerlink" title="表的设计原则"></a>表的设计原则</h3><p>使用临时表一般都意味着性能比较低，特别是使用磁盘临时表，性能更慢，因此我们在实际应用中应该尽量避免临时表的使用。<br>常见的避免临时表的方法有：</p>
<ul>
<li><p>创建索引：在ORDER BY或者GROUP BY的列上创建索引；</p>
</li>
<li><p>分拆很长的列：一般情况下，TEXT、BLOB，大于512字节的字符串，基本上都是为了显示信息，而不会用于查询条件， 因此表设计的时候，<br>应该将这些列独立到另外一张表。</p>
</li>
</ul>
<h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><p>如果表的设计已经确定，修改比较困难，那么也可以通过优化SQL语句来减少临时表的大小，以提升SQL执行效率。常见的优化SQL语句方法如下：</p>
<ul>
<li>拆分SQL语句，临时表主要是用于排序和分组，很多业务都是要求排序后再取出详细的分页数据，这种情况下可以将排序和取出详细数据拆分成不同的SQL，<br>以降低排序或分组时临时表的大小，提升排序和分组的效率，我们的案例就是采用这种方法。</li>
<li>优化业务，去掉排序分组等操作，有时候业务其实并不需要排序或分组，仅仅是为了好看或者阅读方便而进行了排序，例如数据导出、数据查询等操作，<br>这种情况下去掉排序和分组对业务也没有多大影响。</li>
</ul>
<h3 id="如何判断使用了临时表"><a href="#如何判断使用了临时表" class="headerlink" title="如何判断使用了临时表"></a>如何判断使用了临时表</h3><p>使用explain查看执行计划，Extra列看到Using temporary就意味着使用了临时表。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql临时表</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql/MySQL提升课程全面讲解MySQL架构设计</title>
    <url>/2020/04/01/mysql/MySQL%E6%8F%90%E5%8D%87%E8%AF%BE%E7%A8%8B%E5%85%A8%E9%9D%A2%E8%AE%B2%E8%A7%A3MySQL%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="第一章-实例和故事"><a href="#第一章-实例和故事" class="headerlink" title="第一章 实例和故事"></a>第一章 实例和故事</h1><h2 id="什么决定了电商双11大促的成败"><a href="#什么决定了电商双11大促的成败" class="headerlink" title="什么决定了电商双11大促的成败"></a>什么决定了电商双11大促的成败</h2><h2 id="在双11大促的数据库服务器"><a href="#在双11大促的数据库服务器" class="headerlink" title="在双11大促的数据库服务器"></a>在双11大促的数据库服务器</h2><h2 id="在大促中什么影响了数据库性能"><a href="#在大促中什么影响了数据库性能" class="headerlink" title="在大促中什么影响了数据库性能"></a>在大促中什么影响了数据库性能</h2><ul>
<li>sql查询数据</li>
<li>服务器硬件</li>
<li>网卡流量</li>
<li>磁盘IO<a id="more"></a>
<h3 id="超高的QPS和TPS带来的影响"><a href="#超高的QPS和TPS带来的影响" class="headerlink" title="超高的QPS和TPS带来的影响"></a>超高的QPS和TPS带来的影响</h3>QPS: 每秒钟处理的查询量  </li>
<li>效率底下的sql<h3 id="大量的并发和超高的CPU使用率"><a href="#大量的并发和超高的CPU使用率" class="headerlink" title="大量的并发和超高的CPU使用率"></a>大量的并发和超高的CPU使用率</h3></li>
<li>大量的并发导致数据库连接被占满（max_connections 默认100）</li>
<li>超高的CPU使用率，因为CPU资源耗尽而出现宕机<h3 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h3></li>
<li>磁盘IO性能突然下降（使用更快的磁盘设备）</li>
<li>其它大量消耗磁盘性能的计划任务（调整计划，做好磁盘维护）<h3 id="网卡流量"><a href="#网卡流量" class="headerlink" title="网卡流量"></a>网卡流量</h3></li>
<li>减少从服务器的数量</li>
<li>进行分级缓存</li>
<li>避免使用select * 进行查询</li>
<li>分离业务网络和服务器网络</li>
</ul>
<h2 id="大表带来的问题"><a href="#大表带来的问题" class="headerlink" title="大表带来的问题"></a>大表带来的问题</h2><h3 id="什么是大表"><a href="#什么是大表" class="headerlink" title="什么是大表"></a>什么是大表</h3><ul>
<li>记录行数巨大，单表超过千万行</li>
<li>表数据文件巨大，表数据文件超过10G<h3 id="大表对查询的影响"><a href="#大表对查询的影响" class="headerlink" title="大表对查询的影响"></a>大表对查询的影响</h3></li>
<li>慢查询 很难在一定的时间内过滤出所需要的数据<h3 id="大表对DDL的影响"><a href="#大表对DDL的影响" class="headerlink" title="大表对DDL的影响"></a>大表对DDL的影响</h3><h4 id="建立索引需要很长的时间"><a href="#建立索引需要很长的时间" class="headerlink" title="建立索引需要很长的时间"></a>建立索引需要很长的时间</h4>mysql&lt;5.5 建立索引会锁表<br>mysql&gt;=5.5 虽然不会锁表但会引起主从延迟  </li>
</ul>
<h4 id="修改表结构需要长时间锁表"><a href="#修改表结构需要长时间锁表" class="headerlink" title="修改表结构需要长时间锁表"></a>修改表结构需要长时间锁表</h4><p>会造成长时间锁表<br>影响正常的数据操作  </p>
<h4 id="如何处理数据库中的大表"><a href="#如何处理数据库中的大表" class="headerlink" title="如何处理数据库中的大表"></a>如何处理数据库中的大表</h4><ul>
<li>分库分表把一张大表分成多个小表<br>分表的主键选择<br>分表后跨分区数据的统计和查询</li>
<li>大表的历史数据归档减少对前后端业务的影响<br>归档的时间点的选择<br>如何进行归档操作   </li>
</ul>
<h2 id="大事务带来的问题"><a href="#大事务带来的问题" class="headerlink" title="大事务带来的问题"></a>大事务带来的问题</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><ul>
<li>事务是数据库系统区别于其它一切文件系统的重要特性之一</li>
<li>事务是一组具有原子性的sql语句，或是一个独立的工作单元</li>
</ul>
<h3 id="大事务"><a href="#大事务" class="headerlink" title="大事务"></a>大事务</h3><ul>
<li>运行时间长，操作的数据比较多的事务<br>锁定太多的数据，造成大量的阻塞和锁超时<br>回滚时所需要时间比较长<br>执行时间长，容易造成主从延迟</li>
</ul>
<h3 id="如何处理大事务"><a href="#如何处理大事务" class="headerlink" title="如何处理大事务"></a>如何处理大事务</h3><ul>
<li>避免一次处理太多的数据</li>
<li>移出不必要在事务中的select操作</li>
</ul>
<h2 id="第2章-什么影响了mysql的性能"><a href="#第2章-什么影响了mysql的性能" class="headerlink" title="第2章 什么影响了mysql的性能"></a>第2章 什么影响了mysql的性能</h2>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql架构</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql/Mysql面试题</title>
    <url>/2020/04/01/mysql/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="主键超键候选键外键"><a href="#主键超键候选键外键" class="headerlink" title="主键超键候选键外键"></a>主键超键候选键外键</h3><ul>
<li>超键（super key）:在关系中能唯一标识元组的属性集称为关系模式的超键</li>
<li>候选键（candidate key）:不含有多余属性的超键称为候选键</li>
<li>主键（primary key）:用户选作元组标识的一个候选键称为主键</li>
<li>外键（foreign key）:在一个表中存在另一个表的主键，称此键为此表的外键</li>
</ul>
<h3 id="数据库事务的四个特性及含义-ACID"><a href="#数据库事务的四个特性及含义-ACID" class="headerlink" title="数据库事务的四个特性及含义(ACID)"></a>数据库事务的四个特性及含义(ACID)</h3><ul>
<li>原子性（Atomicity）<br>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败。</li>
<li>一致性（Correspondence）<br>事务将数据库从一种中一致性状态转换到另一种一致性状态，在事务开始之前和事务结束之后数据库中数据的完整性没有被破坏</li>
<li>隔离性（Isolation）<br>隔离性要求一个事务对数据库中数据的修改，在未提交完成前对其它事务是不可见的</li>
<li>持久性(Durability)<br>一旦事务提交，则其所做的修改就会永久保存到数据库中。</li>
</ul>
<h3 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h3><ul>
<li>脏读<br>事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>
<li>不可重复读<br>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。<br>事务 A 重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务 B 提交的行。  </li>
<li>幻读<br>幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。</li>
</ul>
<h3 id="MySQL事务隔离级别"><a href="#MySQL事务隔离级别" class="headerlink" title="MySQL事务隔离级别"></a>MySQL事务隔离级别</h3><table>
<thead>
<tr>
<th align="left">事务隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读未提交（read-uncommitted）</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="left">读已提交（read-committed）</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="left">可重复读（repeatable-read）</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="left">串行化（serializable）</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
</tbody></table>
<h3 id="视图的作用，视图可以更改么"><a href="#视图的作用，视图可以更改么" class="headerlink" title="视图的作用，视图可以更改么"></a>视图的作用，视图可以更改么</h3><p>视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询；不包含任何列或数据。  </p>
<p>使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。<br>视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by 则对视图再次order by将被覆盖。</p>
<p>创建视图：create view XXX as XXXXXXXXXXXXXX;<br>对于某些视图比如未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新；</p>
<p>但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。</p>
<h3 id="drop-delete与truncate的区别"><a href="#drop-delete与truncate的区别" class="headerlink" title="drop,delete与truncate的区别"></a>drop,delete与truncate的区别</h3><ul>
<li>drop 是删除整张表（结构和数据）</li>
<li>delete 是删除数据</li>
<li>truncate 清空表，使得表恢复到初始状态<blockquote>
<p>执行速度： drop&gt;truncate&gt;delete</p>
</blockquote>
</li>
</ul>
<h3 id="索引的工作原理及其种类"><a href="#索引的工作原理及其种类" class="headerlink" title="索引的工作原理及其种类"></a>索引的工作原理及其种类</h3><h4 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h4><p>在关系数据库中，索引是一种单独的、物理的数对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。  </p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>索引提供指向存储在表的指定列中的数据值的指针，然后根据您指定的排序顺序对这些指针排序。数据库使用索引以找到特定值，然后顺指针找到包含该值的行。</p>
<h4 id="为什么需要建立索引"><a href="#为什么需要建立索引" class="headerlink" title="为什么需要建立索引"></a>为什么需要建立索引</h4><p>当数据保存在磁盘类存储介质上时，它是作为数据块存放。这些数据块是被当做一个整体来访问的，这样是为了保证操作的原子性。磁盘数据块存储结构类似于链表存储结构，每个数据块包含数据部分，以及指向下一个数据块(节点)的指针，不要连续的数据块进行存储。</p>
<p>记录集只能在某一个关键字段上排序，因此如果想要在一个无序字段上搜索数据，就要执行一个线性搜索的过程，平均需要访问N/2个数据块，N表示数据占用的数据块数目。</p>
<p>如果这个字段是一个非主键字段(也就是说，不包含唯一访问入口)，那么需要访问整个数据存储的数据块。<br>而如果数据是有序的，则可以使用二分法查找，这样只需要访问log2(N)的数据块，这也就是我们为什么有序的字段查询速度更快的原因。</p>
<h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><p>Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。</p>
<ul>
<li>FULLTEXT 即为全文索引，目前只有MyISAM引擎支持。使用场景少，可使用其他方案代替</li>
<li>HASH 因为hash表在处理较小数据量时具有无可比拟的素的优势，所以hash索引很适合做缓存（内存数据库）<br>如mysql数据库的内存版本Memsql，使用量很广泛的缓存工具Mencached，NoSql数据库redis等，都使用了hash索引这种形式。</li>
<li>BTREE Mysql默认的索引类型，具有普遍的适用性</li>
<li>RTREE 相对于BTREE，RTREE的优势在于范围查找.很少使用</li>
</ul>
<h4 id="mysql中sql语句与索引相关的地方"><a href="#mysql中sql语句与索引相关的地方" class="headerlink" title="mysql中sql语句与索引相关的地方"></a>mysql中sql语句与索引相关的地方</h4><ul>
<li><p>myisam里所有键（索引）的长度仅支持1000字节，innodb是767.</p>
<blockquote>
<p>767字节是MySQLVersion 5.6和InnoDB表(和以前的版本)的限制长度。MyISAM表的长度为1000字节。在MySQLVersion 5.7及以上版本中，这个限制已经增加到3072字节。<br>如果你在一个大char或varchar字段上设置了一个索引，该字段是utf8mb4编码的，则必须将最大索引前缀长度767字节(或3072字节)除以4，结果为191字节。这是因为utf8mb4字符的最大长度是4个字节。对于UTF 8字符，它将是三个字节，导致最大索引前缀长度为254。</p>
</blockquote>
</li>
<li><p>blob和text字段仅支持前缀索引.</p>
</li>
<li><p>使用!=以及&lt;&gt;不等于的时候，mysql不使用索引.</p>
</li>
<li><p>当在字段使用函数的时候，mysql无法使用索引；在join时条件字段类型不一致的时候，mysql无法使用索引；在组合索引里使用非第一个索引时也不使用索引.</p>
</li>
<li><p>在使用like的时候，以%开头，即”%***”的时候无法使用索引；在使用or的时候，要求or前后字段都有索引.</p>
</li>
</ul>
<h3 id="连接的种类"><a href="#连接的种类" class="headerlink" title="连接的种类"></a>连接的种类</h3><ul>
<li>笛卡尔积 （join）</li>
<li>左连接（left join）</li>
<li>右连接（right join） </li>
<li>内连接 （inner join）</li>
</ul>
<h3 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h3><h4 id="范式的简介"><a href="#范式的简介" class="headerlink" title="范式的简介"></a>范式的简介</h4><p>范式的英文名称是Normal Form，它是英国人E.F.Codd（关系数据库的老祖宗）在上个世纪70年代提出关系数据库模型后总结出来的。范式是关系数据库<br>理论的基础，也是我们在设计数据库结构过程中所要遵循的规则和指导方法。目前有迹可寻的共有8种范式，依次是：1NF，2NF，3NF，BCNF，4NF，5NF，DKNF，6NF。<br>通常所用到的只是前三个范式，即：第一范式（1NF），第二范式（2NF），第三范式（3NF）。</p>
<p>数据往往种类繁多，而且每种数据之间又互相关联，因此，在设计数据库时，所需要满足的范式越多，那表的层次及结构也就越复杂，最终造成数据的处理困难。<br>这样，还不如不满足这些范式呢。所以在使用范式的时候也要细细斟酌，是否一定要使用该范式，必须根据实际情况做出选择。一般情况下，我们使用前三个范式已经够用了，<br>不再使用更多范式，就能完成对数据的优化，达到最优效果。</p>
<h4 id="通俗的理解"><a href="#通俗的理解" class="headerlink" title="通俗的理解"></a>通俗的理解</h4><ul>
<li><p>第一范式<br>属性不可分割，每个字段都应该是不可再拆分的。<br>比如一个字段是姓名（NAME），在国内的话通常理解都是姓名是一个不可再拆分的单位，这时候就符合第一范式；但是在国外的话还要分为FIRST NAME和LAST NAME，<br>这时候姓名这个字段就是还可以拆分为更小的单位的字段，就不符合第一范式了。</p>
</li>
<li><p>第二范式<br>要求表中要有主键，表中其他其他字段都依赖于主键。<br>因此第二范式只要记住主键约束就好了。比如说有一个表是学生表，学生表中有一个值唯一的字段学号，那么学生表中的其他所有字段都可以根据这个学号字段去获取，<br>依赖主键的意思也就是相关的意思，因为学号的值是唯一的，因此就不会造成存储的信息对不上的问题，即学生001的姓名不会存到学生002那里去。</p>
</li>
<li><p>第三范式<br>要求表中不能有其他表中存在的、存储相同信息的字段，通常实现是在通过外键去建立关联，因此第三范式只要记住外键约束就好了。<br>比如说有一个表是学生表，学生表中有学号，姓名等字段，那如果要把他的系编号，系主任，系主任也存到这个学生表中，那就会造成数据大量的冗余，<br>一是这些信息在系信息表中已存在，二是系中有1000个学生的话这些信息就要存1000遍。因此第三范式的做法是在学生表中增加一个系编号的字段（外键），<br>与系信息表做关联。</p>
</li>
</ul>
<h3 id="数据库优化的思路"><a href="#数据库优化的思路" class="headerlink" title="数据库优化的思路"></a>数据库优化的思路</h3><h4 id="数据库方面"><a href="#数据库方面" class="headerlink" title="数据库方面"></a>数据库方面</h4><ul>
<li>建立索引</li>
<li>分库、分表、分区</li>
<li>数据库引擎（无理由使用Innodb）<br>mysql比较常用的数据库引擎是：innodb 、myisam;<br>myisam是表级锁，适用于一次插入多次查询的表，或者是读写分离中读库中的表<br>innodb是行级锁，适用于频繁更新，插入，读写分离写库中的表</li>
<li>预处理<br>实时数据放入缓存中<br>历史数据，将复杂sql语句执行出来的结果生成视图，查询的时候直接查询视图，速率显著提高。  </li>
<li>读写分离</li>
<li>增加服务器内存、CPU及网络带宽</li>
</ul>
<h4 id="Sql优化"><a href="#Sql优化" class="headerlink" title="Sql优化"></a>Sql优化</h4><ul>
<li>对查询进行优化，尽量避免全表扫描，首先考虑在where及order by涉及的列上加索引</li>
<li>避免在where子句中对字段进行null值判断，比如select id from where num is null 将会放弃索引进行全表扫描。 解决办法是设置为默认值，比如0。</li>
<li>避免在where子句中使用!= 或者&lt;&gt;,否则会放弃索引进行全表扫描</li>
<li>避免在where子句中使用or来连接条件，否则会放弃索引进行全表扫描 解决办法使用union all</li>
<li>避免全模糊查询，比如select id from a where name like ‘%abc%’，将放弃索引进行全表扫描;解决办法使用右模糊查询，</li>
<li>避免隐式转换，比如varchar类型的字段a = 1 ，如此会放弃索引进行全表扫描</li>
<li>避免在where子句=的左边进行函数、算数运算或则其他表达式运算，否则将放弃索引进行全表扫描</li>
<li>尽量使用数字型字段，若只包含数字信息的字段尽量不要设计成字符串类型</li>
</ul>
<p>参考文章：<a href="https://sq.163yun.com/blog/article/183654375478206464" target="_blank" rel="noopener">MySQL数据库优化两三事</a></p>
<h3 id="存储过程与触发器的区别"><a href="#存储过程与触发器的区别" class="headerlink" title="存储过程与触发器的区别"></a>存储过程与触发器的区别</h3><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><p>是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。</p>
<h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><p>触发器是一种特殊类型的存储过程，它又不同于存储过程，触发器主要是通过事件进行触发而被执行的，而存储过程可以通过存储过程名字而被直接调用</p>
]]></content>
  </entry>
  <entry>
    <title>mysql/通过Docker安装配置MySQL主从节点</title>
    <url>/2020/04/01/mysql/%E9%80%9A%E8%BF%87Docker%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEMySQL%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="拉取最新版mysql镜像"><a href="#拉取最新版mysql镜像" class="headerlink" title="拉取最新版mysql镜像"></a>拉取最新版mysql镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>
<h2 id="mysql主服务器"><a href="#mysql主服务器" class="headerlink" title="mysql主服务器"></a>mysql主服务器</h2><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 3307:3306 --name mysql_master -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="修改配置并添加slave用户"><a href="#修改配置并添加slave用户" class="headerlink" title="修改配置并添加slave用户"></a>修改配置并添加slave用户</h3><p>1.进入容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it d45457d26cad &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>2.修改配置    </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt update &amp;&amp; apt install  vim -y</span><br><span class="line">vim /etc/mysql/my.cnf</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment">## 同一局域网内注意要唯一</span></span><br><span class="line">server-id=100  </span><br><span class="line"><span class="comment">## 开启二进制日志功能，可以随便取（关键）</span></span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br></pre></td></tr></table></figure>
<p>3.添加slave用户，用于slave读取binlog</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456 </span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql5.7以下使用 CREATE USER 'slave'@'%' IDENTIFIED BY '123456';</span></span><br><span class="line"><span class="comment">#mysql5.8修改了默认的认证方式为caching_sha2_password ,如果使用此方式创建slave用户，</span></span><br><span class="line"><span class="comment">#那么在后面slave连接master的时候就需要使用加密方式进行连接，否则会报错：Authentication requires secure connection</span></span><br><span class="line"></span><br><span class="line">CREATE USER <span class="string">'slave'</span>@<span class="string">'%'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'123456'</span>;</span><br><span class="line"></span><br><span class="line">GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO <span class="string">'slave'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure>

<p>4.重启容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker restart d45457d26cad</span><br></pre></td></tr></table></figure>

<h2 id="mysql从服务器"><a href="#mysql从服务器" class="headerlink" title="mysql从服务器"></a>mysql从服务器</h2><h3 id="启动容器-1"><a href="#启动容器-1" class="headerlink" title="启动容器"></a>启动容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 3308:3306 --name mysql_slave -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest</span><br></pre></td></tr></table></figure>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>1.进入容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 3e80d15d8b00 /bin/bash</span><br></pre></td></tr></table></figure>
<p>2.修改配置    </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt update &amp;&amp; apt install  vim -y</span><br><span class="line">vim /etc/mysql/my.cnf</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment">## 设置server_id,注意要唯一</span></span><br><span class="line">server-id=101  </span><br><span class="line"><span class="comment">## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用</span></span><br><span class="line"><span class="built_in">log</span>-bin=mysql-slave-bin   </span><br><span class="line"><span class="comment">## relay_log配置中继日志</span></span><br><span class="line">relay_log=edu-mysql-relay-bin</span><br></pre></td></tr></table></figure>
<p>3.重启容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker restart 3e80d15d8b00</span><br><span class="line">```    </span><br><span class="line"><span class="comment">## 配置slave使其连上master    </span></span><br><span class="line">```bash</span><br><span class="line">change master to master_host=<span class="string">'192.168.11.36'</span>, master_user=<span class="string">'slave'</span>, master_password=<span class="string">'123456'</span>, master_port=3307, master_log_file=<span class="string">'mysql-bin.000001'</span>, master_log_pos= 605, master_connect_retry=30;</span><br><span class="line"></span><br><span class="line">start slave </span><br><span class="line"></span><br><span class="line">show slave status \G 查看主从状态</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考文章<br><a href="https://www.cnblogs.com/songwenjie/p/9371422.html" target="_blank" rel="noopener">基于Docker的Mysql主从复制搭建</a></p>
</blockquote>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql主从同步</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx/如何利用nginx进行自动化负载均衡</title>
    <url>/2020/04/01/nginx/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8nginx%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<p>基于Docker + Consul + Nginx + Consul-Template + Registrator的服务自动负载均衡实现 </p>
<a id="more"></a>

<h2 id="docker-composer相关知识点"><a href="#docker-composer相关知识点" class="headerlink" title="docker-composer相关知识点"></a>docker-composer相关知识点</h2><ul>
<li>ports 暴露容器端口到主机的任意端口或指定端口, 用法如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ports:</span><br><span class="line"> </span><br><span class="line">    - &quot;80:80&quot; # 绑定容器的80端口到主机的80端口</span><br><span class="line">     </span><br><span class="line">    - &quot;9000:8080&quot; # 绑定容器的8080端口到主机的9000端口</span><br><span class="line">     </span><br><span class="line">    - &quot;443&quot; # 绑定容器的443端口到主机的任意端口，容器启动时随机分配绑定的主机端口</span><br></pre></td></tr></table></figure></li>
<li>links 使得docker容器间通过指定的名字来和目标容器通信 <blockquote>
<p>如果使用links则容器间通信 只能通过该使用容器的ip地址来通信或者通过宿主机的ip加上容器暴露出的端口号来通信 （这两种都有弊端）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">links:</span><br><span class="line">    -  consul_server_master:consul # 当前容器中使用consul 即可获取容器consul_server_master的ip地址,便于通信</span><br></pre></td></tr></table></figure></li>
<li>depends_on 决定容器的依赖, 也就是指定当前容器的启动顺序，必须依赖启动后才会启动<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">depends_on:</span><br><span class="line">    - lb</span><br><span class="line">    - registrator</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="consul-相关知识点"><a href="#consul-相关知识点" class="headerlink" title="consul 相关知识点"></a>consul 相关知识点</h2><ul>
<li><p>Client模式 就是客户端模式。是 Consul 节点的一种模式，这种模式下，所有注册到当前节点的服务会被转发到 Server，本身是不持久化这些信息。</p>
</li>
<li><p>Server模式 表明这个 Consul 是个 Server ，这种模式下，功能和 Client 都一样，唯一不同的是，它会把所有的信息持久化的本地，这样遇到故障，信息是可以被保留的。同时可以同步多个consul客户端的数据</p>
<blockquote>
<p>Server 节点之间的数据一致性保证协议使用的是 raft，而 zookeeper 用的 paxos，etcd采用的也是raft</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command: consul agent -server -bootstrap-expect 1 -advertise 192.168.1.181 -node consul_server_master -data-dir &#x2F;tmp&#x2F;data-dir -client 0.0.0.0 -ui</span><br><span class="line"># -bootstrap-expect&#x3D;2 表示节点个数为2个</span><br><span class="line"># -node&#x3D;consul-server-1 表示节点名称为consul-server-1</span><br><span class="line"># -client&#x3D;0.0.0.0 表示允许连接的客户端 IP</span><br><span class="line"># -bind&#x3D;10.211.55.2 表示服务端 IP为10.211.55.2</span><br><span class="line"># -datacenter&#x3D;dc1 数据中心名称</span><br><span class="line"># -join&#x3D;10.211.55.4 表示加入10.211.55.4节点的集群</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务发现协议 Consul 采用 http 和 DNS 协议，etcd 只支持 http </p>
</li>
<li><p>服务注册 Consul 支持两种方式实现服务注册，一种是通过 Consul 的服务注册 Http API，由服务自己调用 API 实现注册，另一种方式是通过 json 格式的配置文件实现注册，将需要注册的服务以 json 格式的配置文件给出。Consul 官方建议使用第二种方式。</p>
</li>
<li><p>服务定义参数</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">环境变量Key</th>
<th align="center">环境变量Value</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SERVICE_ID</td>
<td align="center">web-001</td>
<td align="center">可以为GUID或者可读性更强变量，保证不重复</td>
</tr>
<tr>
<td align="center">SERVICE_NAME</td>
<td align="center">web</td>
<td align="center">如果ID没有设置，Consul会将name作为id，则有可能注册失败</td>
</tr>
<tr>
<td align="center">SERVICE_TAGS</td>
<td align="center">nodejs,web</td>
<td align="center">服务的标签，用逗号分隔，开发者可以根据标签来查询一些信息</td>
</tr>
<tr>
<td align="center">SERVICE_IGNORE</td>
<td align="center">Boolean</td>
<td align="center">是否忽略本Container，可以为一些不需要注册的Container添加此属性</td>
</tr>
</tbody></table>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul>
<li><p>通过 Nginx 自身实现负载均衡和请求转发</p>
</li>
<li><p>通过 Consul-template 的 config 功能实时监控 Consul 集群节点的服务和数据的变化；<br>实时的用 Consul 节点的信息替换 Nginx 配置文件的模板，并重新加载配置文件</p>
<blockquote>
<p>Consul-template 和 nginx 必须安装在同一台机器上，因为 Consul-template 需要动态修改 nginx 的配置文件 nginx.conf，然后执行 nginx -s reload 命令进行路由更新，达到动态负载均衡的目的</p>
</blockquote>
</li>
<li><p>registrator，它可以通过跟本地的 docker 引擎通信，来获取本地启动的容器信息，并且注册到指定的服务发现管理端。</p>
</li>
</ul>
<p>数据流向： docker 容器数据-&gt; registrator -&gt; consul -&gt;consul-template -&gt; nginx</p>
<h2 id="镜像构建"><a href="#镜像构建" class="headerlink" title="镜像构建"></a>镜像构建</h2><ul>
<li>Consul：consul:latest</li>
<li>Registrator：gliderlabs/registrator:latest</li>
<li>Nginx和Consul-template：liberalman/nginx-consul-template:latest</li>
<li>Web: yeasy/simple-web:latest</li>
</ul>
<h2 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line">#backend web application, scale this with docker-compose scale web&#x3D;3</span><br><span class="line">services:</span><br><span class="line">    web:</span><br><span class="line">      image: yeasy&#x2F;simple-web:latest</span><br><span class="line">      environment:</span><br><span class="line">        - SERVICE_80_NAME&#x3D;my-web-server</span><br><span class="line">      ports:</span><br><span class="line">      - &quot;80&quot;</span><br><span class="line">      depends_on:</span><br><span class="line">          - lb</span><br><span class="line">          - registrator  </span><br><span class="line"></span><br><span class="line">    #load balancer will automatically update the config using consul-template</span><br><span class="line">    lb:</span><br><span class="line">      image: liberalman&#x2F;nginx-consul-template:latest</span><br><span class="line">      hostname: lb</span><br><span class="line">      environment:</span><br><span class="line">          - SERVICE_IGNORE&#x3D;true</span><br><span class="line">      links:</span><br><span class="line">      -  consul_server_master:consul</span><br><span class="line">      ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">      depends_on:</span><br><span class="line">          - consul_server_master</span><br><span class="line">          </span><br><span class="line">    consul_server_master:</span><br><span class="line">      image:  consul:latest</span><br><span class="line">      hostname: consul_server_master</span><br><span class="line">      environment:</span><br><span class="line">          - SERVICE_IGNORE&#x3D;true</span><br><span class="line">      ports:</span><br><span class="line">      - &quot;8500:8500&quot;</span><br><span class="line">      command: consul agent -server -bootstrap-expect 1 -node consul_server_master -data-dir &#x2F;tmp&#x2F;consul -client 0.0.0.0 -ui</span><br><span class="line"></span><br><span class="line">    # listen on local docker sock to register the container with public ports to the consul service</span><br><span class="line">    registrator:</span><br><span class="line">      image: gliderlabs&#x2F;registrator:master</span><br><span class="line">      hostname: registrator</span><br><span class="line">      environment:</span><br><span class="line">          - SERVICE_IGNORE&#x3D;true</span><br><span class="line">      links:</span><br><span class="line">      - consul_server_master:consul</span><br><span class="line">      depends_on:</span><br><span class="line">          - consul_server_master</span><br><span class="line">      volumes:</span><br><span class="line">      - &quot;&#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;tmp&#x2F;docker.sock&quot;</span><br><span class="line">      command: -internal consul:&#x2F;&#x2F;consul:8500</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：我们使用的第三方镜像 liberalman/nginx-consul-template，Nginx 会把名称为 my-web-server的服务容器作为后台转发的目标服务器,当然你也可以自己制作镜像指定模板. </p>
</blockquote>
<h2 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h2><ol>
<li><p>docker-compose 模板所在目录，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker-compose up</span><br></pre></td></tr></table></figure></li>
<li><p>访问 <a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> 可以看到一个 web 页面，提示实际访问的目标地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#2019-12-20 04:12:30: 19 requests from &lt;LOCAL: 172.17.0.6&gt; to WebServer &lt;172.17.0.4&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加web 测试负载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker-compose scale web=3</span><br></pre></td></tr></table></figure>
</li>
<li><p>重复刷新<a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> 观察ip变化</p>
</li>
</ol>
<h2 id="总结测试"><a href="#总结测试" class="headerlink" title="总结测试"></a>总结测试</h2><p>最先我未去指定容器的启动顺序（deponds_on） 导致docker-compose up 后访问<a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> 报错 nginx 502<br>原因是因为 registrator容器先于web容器启动，导致未将web容器注册到consul 所以生成的nginx配置文件中，没用web参与负载</p>
<p>本文搭建的consul为单节点版本 ， 集群版 <a href="https://www.jianshu.com/p/fa41434d444a" target="_blank" rel="noopener">参考文章1</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://www.jianshu.com/p/fa41434d444a" target="_blank" rel="noopener">基于Docker + Consul + Nginx + Consul-Template的服务负载均衡实现</a></li>
<li><a href="https://my.oschina.net/xiaominmin/blog/1597660" target="_blank" rel="noopener">用 consul + consul-template + registrator + nginx 打造真正可动态扩展的服务架构 </a></li>
<li><a href="https://www.sohu.com/a/282625515_468635" target="_blank" rel="noopener">8分钟学会Consul集群搭建及微服务概念 </a></li>
</ol>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>自动负载均衡</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>redis/Redis面试题</title>
    <url>/2020/04/01/redis/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="使用Redis有哪些好处"><a href="#使用Redis有哪些好处" class="headerlink" title="使用Redis有哪些好处"></a>使用Redis有哪些好处</h2><ul>
<li>速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</li>
<li>支持丰富数据类型，支持string，list，set，sorted set，hash</li>
<li>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li>
<li>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除<a id="more"></a>

</li>
</ul>
<h2 id="redis相比memcached有哪些优势"><a href="#redis相比memcached有哪些优势" class="headerlink" title="redis相比memcached有哪些优势"></a>redis相比memcached有哪些优势</h2><ul>
<li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</li>
<li>redis的速度比memcached快很多</li>
<li>redis可以持久化其数据</li>
</ul>
<h2 id="redis常见性能问题和解决方案"><a href="#redis常见性能问题和解决方案" class="headerlink" title="redis常见性能问题和解决方案"></a>redis常见性能问题和解决方案</h2><h3 id="Master写内存快照"><a href="#Master写内存快照" class="headerlink" title="Master写内存快照"></a>Master写内存快照</h3><p>save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。 </p>
<p>Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。  </p>
<h3 id="Master-AOF持久化"><a href="#Master-AOF持久化" class="headerlink" title="Master AOF持久化"></a>Master AOF持久化</h3><p>如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。</p>
<p>如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</p>
<h3 id="Master调用BGREWRITEAOF"><a href="#Master调用BGREWRITEAOF" class="headerlink" title="Master调用BGREWRITEAOF"></a>Master调用BGREWRITEAOF</h3><p>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</p>
<p>将no-appendfsync-on-rewrite的配置设为yes可以缓解这个问题，设置为yes表示rewrite期间对新写操作不fsync，暂时存在内存中，等rewrite完成后再写入。最好是不开启Master的AOF备份功能。  </p>
<h4 id="Redis主从复制的性能问题"><a href="#Redis主从复制的性能问题" class="headerlink" title="Redis主从复制的性能问题"></a>Redis主从复制的性能问题</h4><p>第一次Slave向Master同步的实现是：Slave向Master发出同步请求，Master先dump出rdb文件，然后将rdb文件全量传输给slave，然后Master把缓存的<br>命令转发给Slave，初次同步完成。第二次以及以后的同步实现是：Master将变量的快照直接实时依次发送给各个Slave。不管什么原因导致Slave和<br>Master断开重连都会重复以上过程。Redis的主从复制是建立在内存快照的持久化基础上，只要有Slave就一定会有内存快照发生。虽然Redis宣称主从<br>复制无阻塞，但由于Redis使用单线程服务，如果Master快照文件比较大，那么第一次全量传输会耗费比较长时间，且文件传输过程中Master可能无法<br>提供服务，也就是说服务会中断，对于关键服务，这个后果也是很可怕的。  </p>
<p>尽量避免在压力较大的主库上增加从库。</p>
<h3 id="单点故障问题"><a href="#单点故障问题" class="headerlink" title="单点故障问题"></a>单点故障问题</h3><p>由于目前Redis的主从复制还不够成熟，所以存在明显的单点故障问题，这个目前只能自己做方案解决</p>
<p>为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…….，这样的结构也方便解<br>决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。</p>
<h2 id="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"><a href="#MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据" class="headerlink" title="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"></a>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</h2><h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><p>redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。redis 提供 </p>
<h3 id="6种数据淘汰策略"><a href="#6种数据淘汰策略" class="headerlink" title="6种数据淘汰策略"></a>6种数据淘汰策略</h3><ul>
<li>volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰</li>
<li>volatile-random 从已设置过期时间的数据集中任意选择数据淘汰</li>
<li>allkeys-lru 从数据集中挑选最近最少使用的数据淘汰</li>
<li>allkeys-random 从数据集中任意选择数据淘汰</li>
<li>no-enviction 禁止驱逐数据<h3 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h3>计算一下20w数据大约占用的内存，设置Redis内存限制，设置淘汰策略，加载热数据到内存中</li>
</ul>
<h2 id="Memcache与Redis的区别都有哪些"><a href="#Memcache与Redis的区别都有哪些" class="headerlink" title="Memcache与Redis的区别都有哪些"></a>Memcache与Redis的区别都有哪些</h2><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><ul>
<li>Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小</li>
<li>Redis有部份存在硬盘上，这样能保证数据的持久性。<h3 id="数据支持类型"><a href="#数据支持类型" class="headerlink" title="数据支持类型"></a>数据支持类型</h3></li>
<li>Memcache对数据类型支持相对简单</li>
<li>Redis有复杂的数据类型<h3 id="value大小"><a href="#value大小" class="headerlink" title="value大小"></a>value大小</h3></li>
<li>redis最大可以达到1GB，而memcache只有1MB</li>
</ul>
<h2 id="redis最适合的场景"><a href="#redis最适合的场景" class="headerlink" title="redis最适合的场景"></a>redis最适合的场景</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，<br>也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。</p>
<h3 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h3><p>很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。</p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无<br>疑是种挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。</p>
<h3 id="分布式会话"><a href="#分布式会话" class="headerlink" title="分布式会话"></a>分布式会话</h3><p>集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中<br>心的session服务，session不再由容器管理，而是由session服务及内存数据库管理。</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可<br>以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。<br>可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。</p>
<h3 id="社交网络"><a href="#社交网络" class="headerlink" title="社交网络"></a>社交网络</h3><p>点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，<br>Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。</p>
<h3 id="最新列表"><a href="#最新列表" class="headerlink" title="最新列表"></a>最新列表</h3><p>Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。</p>
<h3 id="消息系统"><a href="#消息系统" class="headerlink" title="消息系统"></a>消息系统</h3><p>消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。<br>Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。</p>
<h2 id="Redis的同步机制"><a href="#Redis的同步机制" class="headerlink" title="Redis的同步机制"></a>Redis的同步机制</h2><p>Redis通过主从同步机制来确保master和salve之间的数据同步</p>
<h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><p>全量复制是指salve启动时进行的初始化同步。<br>全同步过程：</p>
<ol>
<li>在salve启动时，会向master发送一条SYNC指令。  </li>
<li>master收到这条指令后，会启动一个备份进程将所有数据写到rdb文件中去。  </li>
<li>更新master的状态（备份是否成功、备份时间等），然后将rdb文件内容发送给等待中的salve。  <blockquote>
<p>master并不会立即将rdb内容发送给salve。而是为每个等待中的salve注册写事件，当salve对应的socket可以发送数据时，再讲rdb内容发送给salve。</p>
</blockquote>
<h3 id="增量拷贝"><a href="#增量拷贝" class="headerlink" title="增量拷贝"></a>增量拷贝</h3>如果出现网络闪断或者命令丢失等异常情况时，当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。因此会把它们当作psync<br>参数发送给主节点，要求进行部分复制操作<br>主节点接到psync命令后首先核对参数runId是否与自身一致，如果一致，说明之前复制的是当前主节点；之后根据参数offset在自身复制积压缓冲区查找<br>，如果偏移量之后的数据存在缓冲区中，则对从节点发送+continue响应，表示可以进行部分复制；否则进行全量复制。<br>主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。</li>
</ol>
<h2 id="是否使用过Redis集群-集群的原理是什么"><a href="#是否使用过Redis集群-集群的原理是什么" class="headerlink" title="是否使用过Redis集群,集群的原理是什么"></a>是否使用过Redis集群,集群的原理是什么</h2><h2 id="redis集群如何保证一致性"><a href="#redis集群如何保证一致性" class="headerlink" title="redis集群如何保证一致性"></a>redis集群如何保证一致性</h2>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>go/golang面试题</title>
    <url>/2020/04/01/go/golang%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="golang-调度"><a href="#golang-调度" class="headerlink" title="golang 调度"></a>golang 调度</h2><ul>
<li>CSP(通信顺序进程)</li>
<li>顺序一致性模型 <blockquote>
<p>1.Go语言中，同一个Goroutine线程内部，顺序一致性内存模型是得到保证的;<br>  2.不同的Goroutine之间，并不满足顺序一致性内存模型，需要通过明确定义的同步事件来作为同步的参考</p>
</blockquote>
<a id="more"></a></li>
<li>Goroutine采用的是半抢占式的协作调度，只有在当前Goroutine发生阻塞时才会导致调度 。以下是可能导致调度的点 <blockquote>
<p>1.I/O,select<br>  2.channel<br>  3.等待锁<br>  4.函数调用（有时）<br>  5.runtime.Gosched(),由程序主动交出控制权</p>
</blockquote>
</li>
</ul>
<h2 id="go-结构体能不能进行比较"><a href="#go-结构体能不能进行比较" class="headerlink" title="go 结构体能不能进行比较"></a>go 结构体能不能进行比较</h2><ul>
<li>如果结构体的所有成员变量都是可以比较的，那么结构体就可以比较</li>
<li>结构体之间进行转换需要他们具备完全相同的成员（字段名，字段类型，字段个数）</li>
<li>切片，map不能进行比较</li>
</ul>
<h2 id="结构体可以作为map的key吗"><a href="#结构体可以作为map的key吗" class="headerlink" title="结构体可以作为map的key吗"></a>结构体可以作为map的key吗</h2><ul>
<li>结构体必须是可以比较的，才能作为key，否则编译报错</li>
</ul>
<h2 id="go-defer-先进后出，栈结构"><a href="#go-defer-先进后出，栈结构" class="headerlink" title="go defer 先进后出，栈结构"></a>go defer 先进后出，栈结构</h2><h2 id="select作用"><a href="#select作用" class="headerlink" title="select作用"></a>select作用</h2><ul>
<li>用于监听和channel有关的IO操作，当IO操作触发时，触发相应的动作</li>
<li>所有的channel表达式都会被求值，所有被发送的表达式都会被求值，求值顺序：自上而下，从左到右</li>
<li>select常用于协程的安全退出</li>
</ul>
<h2 id="context包"><a href="#context包" class="headerlink" title="context包"></a>context包</h2><ul>
<li>context 一般理解为程序单元（goroutine）的一个运行状态，现场，快照,通过context将当前程序的状态传递给下（goroutine）</li>
<li>context 常用于将过期或者撤销的信号传递给被调用的程序单元</li>
</ul>
<h2 id="主协成如何等待其余协程完成"><a href="#主协成如何等待其余协程完成" class="headerlink" title="主协成如何等待其余协程完成"></a>主协成如何等待其余协程完成</h2><ul>
<li>使用channel进行通信</li>
<li>使用sync.WaitGroup包</li>
</ul>
<h2 id="slice-len-cap-共享-扩容"><a href="#slice-len-cap-共享-扩容" class="headerlink" title="slice,len,cap,共享,扩容"></a>slice,len,cap,共享,扩容</h2><ul>
<li>slice底层数据结构由，数组，len,cap 组成，append扩容时是以当前容量的2倍进行扩容</li>
<li>slice 加锁可以实现消息队列</li>
</ul>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul>
<li>map 是非线程安全的，多个协程同时操作一个map，会导致程序崩溃</li>
<li>map 是无序的，想要顺序读取，可将map的key放入切片后排序后进行map读取</li>
<li>map key是唯一的，可用于实现set集合</li>
<li>map 可实现发布订阅</li>
</ul>
<h2 id="大文件排序"><a href="#大文件排序" class="headerlink" title="大文件排序"></a>大文件排序</h2><ul>
<li>归并算法</li>
<li>利用goroutine 并发排序缩短时间</li>
</ul>
<h2 id="标准Http协议6种请求方法"><a href="#标准Http协议6种请求方法" class="headerlink" title="标准Http协议6种请求方法"></a>标准Http协议6种请求方法</h2><ul>
<li>GET</li>
<li>POST</li>
<li>PUT</li>
<li>DELETE</li>
<li>HEAD<blockquote>
<p>HEAD 常用于判定某个资源是否存在 </p>
</blockquote>
</li>
<li>Options<blockquote>
<p>用于检查资源地址是否有效</p>
</blockquote>
</li>
</ul>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><ul>
<li>2PC</li>
<li>TCC</li>
<li>本地消息表</li>
<li>MQ事务（RocketMQ）</li>
</ul>
<h2 id="golang中值类型和引用类型"><a href="#golang中值类型和引用类型" class="headerlink" title="golang中值类型和引用类型"></a>golang中值类型和引用类型</h2><ul>
<li>值类型分别有：int系列、float系列、bool、string、数组和结构体</li>
<li>引用类型有：指针、slice切片、管道channel、接口interface、map、函数等</li>
<li>值类型的特点是：变量直接存储值，内存通常在栈中分配</li>
<li>引用类型的特点是：变量存储的是一个地址，这个地址对应的空间里才是真正存储的值，内存通常在堆中分配,编译器会隐式地为我们解引用，取到指针指向的实际变量</li>
</ul>
<h2 id="Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？"><a href="#Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？" class="headerlink" title="Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？"></a>Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？</h2><p>Golang中Goroutine 可以通过 Channel 进行安全读写共享变量。</p>
<h2 id="无缓冲-Chan-的发送和接收是否同步"><a href="#无缓冲-Chan-的发送和接收是否同步" class="headerlink" title="无缓冲 Chan 的发送和接收是否同步?"></a>无缓冲 Chan 的发送和接收是否同步?</h2><p>无缓冲的channel由于没有缓冲发送和接收需要同步.<br>有缓冲channel不要求发送和接收操作同步.<br>channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据。<br>channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。  </p>
<h2 id="go语言的并发机制以及它所使用的CSP并发模型-GMP"><a href="#go语言的并发机制以及它所使用的CSP并发模型-GMP" class="headerlink" title="go语言的并发机制以及它所使用的CSP并发模型 GMP"></a>go语言的并发机制以及它所使用的CSP并发模型 GMP</h2><p>CSP模型是上个世纪七十年代提出的,不同于传统的多线程通过共享内存来通信，CSP讲究的是“以通信的方式来共享内存”。用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。 CSP中channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。<br>Golang中channel 是被单独创建并且可以在进程之间传递，它的通信模式类似于 boss-worker 模式的，一个实体通过将消息发送到channel 中，然后又监听这个 channel 的实体处理，两个实体之间是匿名的，这个就实现实体中间的解耦，其中 channel 是同步的一个消息被发送到 channel 中，最终是一定要被另外的实体消费掉的，在实现原理上其实类似一个阻塞的消息队列。<br>Goroutine 是Golang实际并发执行的实体，它底层是使用协程(coroutine)实现并发，coroutine是一种运行在用户态的用户线程，类似于 greenthread，go底层选择使用coroutine的出发点是因为，它具有以下特点：  </p>
<ul>
<li>用户空间 避免了内核态和用户态的切换导致的成本。</li>
<li>可以由语言和框架层进行调度。</li>
<li>更小的栈空间允许创建大量的实例。</li>
</ul>
<p>Golang中的Goroutine的特性:<br>Golang内部有三个对象： P对象(processor) 代表上下文（或者可以认为是cpu），M(work thread)代表工作线程，G对象（goroutine）.  </p>
<ul>
<li>G（Goroutine）我们所说的协程，为用户级的轻量级线程，每个Goroutine对象中的sched保存着其上下文信息.</li>
<li>M（Machine） 对内核级线程的封装，数量最大值为1000</li>
<li>P（Processor） 即为G和M的调度对象，用来调度G和M之间的关联关系，其数量可通过GOMAXPROCS()来设置，默认为核心数.</li>
</ul>
<p>GMP调度原理:<br>Goroutine 调度器和 OS 调度器是通过 M 结合起来的，每个 M 都代表了 1 个内核线程，OS 调度器负责把内核线程分配到 CPU 的核上执行。<br>M想要执行G,必须先获得P,在go中有,两个队列,一个全局的G队列和P本地队列,M从P本地队列中获取G,如果P本地队列为空,则从全局队列中拉取一些G放到本地队列,如果全局队列为空则从其他P本地队列偷取G来,放到自己的本地队列中.如果偷取失败,则当前M进入自旋状态,等待可执行的G,<br>而其他未获得P的会进入休眠状态,一定时间过后会被操作系统回收.<br>如果当前M执行G的过程中G发生阻塞,则P会立即分离出来,寻找空闲M进行绑定</p>
<p>Golang的CSP并发模型，是通过Goroutine和Channel来实现的。<br>Goroutine 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。 Channel是Go语言中各个并发结构体(Goroutine)之前的通信机制。通常Channel，是各个Goroutine之间通信的”管道“，有点类似于Linux中的管道。<br>在通信过程中，传数据channel &lt;- data和取数据&lt;-channel必然会成对出现，因为这边传，那边取，两个goroutine之间才会实现通信。  </p>
<h2 id="Golang-中常用的并发模式？"><a href="#Golang-中常用的并发模式？" class="headerlink" title="Golang 中常用的并发模式？"></a>Golang 中常用的并发模式？</h2><h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><p>并发编程中最常见的例子就是生产者消费者模式，该模式主要通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。简单地说，就是生产者生产一些数据，然后放到成果队列中，同时消费者从成果队列中来取这些数据。这样就让生产消费变成了异步的两个过程。当成果队列中没有数据时，消费者就进入饥饿的等待中；而当成果队列中数据已满时，生产者则面临因产品挤压导致CPU被剥夺的下岗问题。</p>
<h3 id="发布订阅模型"><a href="#发布订阅模型" class="headerlink" title="发布订阅模型"></a>发布订阅模型</h3><p>发布订阅（publish-and-subscribe）模型通常被简写为pub/sub模型。在这个模型中，消息生产者成为发布者（publisher），而消息消费者则成为订阅者（subscriber），生产者和消费者是M:N的关系。在传统生产者和消费者模型中，是将消息发送到一个队列中，而发布订阅模型则是将消息发布给一个主题。</p>
<h3 id="控制并发数"><a href="#控制并发数" class="headerlink" title="控制并发数"></a>控制并发数</h3><p>利用带缓存的channel实现</p>
<h3 id="赢者为王"><a href="#赢者为王" class="headerlink" title="赢者为王"></a>赢者为王</h3><p>开启多个Goroutine 执行相同的任务,谁先返回,取谁的结果</p>
<h3 id="并发的安全退出"><a href="#并发的安全退出" class="headerlink" title="并发的安全退出"></a>并发的安全退出</h3><p>通过select和channel 实现</p>
<h3 id="context包-1"><a href="#context包-1" class="headerlink" title="context包"></a>context包</h3><p>在Go1.7发布时，标准库增加了一个context包，用来简化对于处理单个请求的多个Goroutine之间与请求域的数据、超时和退出等操作  </p>
<h3 id="通过sync-WaitGroup实现并发控制"><a href="#通过sync-WaitGroup实现并发控制" class="headerlink" title="通过sync.WaitGroup实现并发控制"></a>通过sync.WaitGroup实现并发控制</h3><h2 id="JSON标准库对nil-slice和空slice的处理是一致的吗？"><a href="#JSON标准库对nil-slice和空slice的处理是一致的吗？" class="headerlink" title="JSON标准库对nil slice和空slice的处理是一致的吗？　"></a>JSON标准库对nil slice和空slice的处理是一致的吗？　</h2><p>不一直,nil slice会序列化成null ,空slice会序列化成空数组[]</p>
<h2 id="协程，线程，进程的区别。"><a href="#协程，线程，进程的区别。" class="headerlink" title="协程，线程，进程的区别。"></a>协程，线程，进程的区别。</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<h2 id="互斥锁，读写锁，死锁问题是怎么解决"><a href="#互斥锁，读写锁，死锁问题是怎么解决" class="headerlink" title="互斥锁，读写锁，死锁问题是怎么解决"></a>互斥锁，读写锁，死锁问题是怎么解决</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁就是互斥变量mutex，用来锁住临界区的.<br>条件锁就是条件变量，当进程的某些资源要求不满足时就进入休眠，也就是锁住了。当资源被分配到了，条件锁打开，进程继续运行；读写锁，也类似，用于缓冲区等临界资源能互斥访问的。  </p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>通常有些公共数据修改的机会很少，但其读的机会很多。并且在读的过程中会伴随着查找，给这种代码加锁会降低我们的程序效率。读写锁可以解决这个问题。  </p>
<blockquote>
<p>注意：写独占，读共享，写锁优先级高</p>
</blockquote>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）。 另外一种情况是：若线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。</p>
<h4 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h4><p>1.互斥条件：一个资源每次只能被一个进程使用<br>2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。<br> 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。  </p>
<h3 id="怎么解决死锁问题"><a href="#怎么解决死锁问题" class="headerlink" title="怎么解决死锁问题"></a>怎么解决死锁问题</h3><h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><p>可以把资源一次性分配：（破坏请求和保持条件）<br>然后剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）<br>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</p>
<h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。</p>
<h4 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h4><p>首先为每个进程和每个资源指定一个唯一的号码,然后建立资源分配表和进程等待表.</p>
<h4 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h4><p>当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有:  </p>
<ol>
<li>剥夺资源 从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态.</li>
<li>撤消进程 可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止.所谓代价是指优先级、运行代价、进程的重要性和价值等。</li>
</ol>
<h2 id="Golang的内存模型，为什么小对象多了会造成gc压力"><a href="#Golang的内存模型，为什么小对象多了会造成gc压力" class="headerlink" title="Golang的内存模型，为什么小对象多了会造成gc压力"></a>Golang的内存模型，为什么小对象多了会造成gc压力</h2><h3 id="面向并发的内存模型"><a href="#面向并发的内存模型" class="headerlink" title="面向并发的内存模型"></a>面向并发的内存模型</h3><p>常见的并行编程有多种模型，主要有多线程、消息传递等。Go语言是基于消息并发模型的集大成者，它将基于CSP模型的并发编程内置到了语言中,并且go语言是共享内存的  </p>
<h3 id="Goroutine和系统线程"><a href="#Goroutine和系统线程" class="headerlink" title="Goroutine和系统线程"></a>Goroutine和系统线程</h3><p>Goroutine采用的是半抢占式的协作调度，只有在当前Goroutine发生阻塞时才会导致调度；同时发生在用户态，调度器会根据具体函数只保存必要的寄存器，切换的代价要比系统线程低得多。运行时有一个runtime.GOMAXPROCS变量，用于控制当前运行正常非阻塞Goroutine的系统线程数目。  </p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>所谓的原子操作就是并发编程中“最小的且不可并行化”的操作。</p>
<h3 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h3><p>在Go语言中，同一个Goroutine线程内部，顺序一致性内存模型是得到保证的。但是不同的Goroutine之间，并不满足顺序一致性内存模型，需要通过明确定义的同步事件来作为同步的参考。</p>
<p>通常小对象过多会导致GC三色法消耗过多的GPU。优化思路是，减少对象分配.</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>goland面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>go/gomod</title>
    <url>/2020/04/01/go/gomod/</url>
    <content><![CDATA[<h2 id="环境变量GO111MODULE"><a href="#环境变量GO111MODULE" class="headerlink" title="环境变量GO111MODULE"></a>环境变量GO111MODULE</h2><ul>
<li><p>GO111MODULE=off </p>
<blockquote>
<p>go命令从不使用新模块支持。使用GOPATH模式(查找vendor目录和GOPATH路径下的依赖)</p>
</blockquote>
</li>
<li><p>GO111MODULE=on </p>
<blockquote>
<p>go命令开启模块支持,此时执行go get 命令,所有依赖都会下到$GOPATH/pkg/mod ,go依赖查找也只会到$GOPATH/pkg/mod进行查找</p>
</blockquote>
</li>
<li><p>GO111MODULE=auto </p>
<blockquote>
<p>默认值,go命令根据当前目录启用或禁用模块支持。仅当当前目录位于$GOPATH/src之外并且其本身包含go.mod文件或位于包含go.mod文件的目录下时，才启用模块支持。简而言之,就是项目包含go.mod文件时会开启模块支持</p>
</blockquote>
</li>
</ul>
<a id="more"></a>
<p>注意：</p>
<p>Go 1.13中，module mode优先级提升，GO111MODULE的默认值依然为auto，但在这个auto下，无论是在GOPATH/src下还是GOPATH之外的repo中，只要目录下有go.mod，go编译器都会使用go module来管理依赖。</p>
<h2 id="go-mod命令"><a href="#go-mod命令" class="headerlink" title="go mod命令"></a>go mod命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">download    下载依赖的module到本地cache</span><br><span class="line">edit        编辑go.mod文件</span><br><span class="line">graph       打印模块依赖图</span><br><span class="line">init        在当前文件夹下初始化一个新的module, 创建go.mod文件</span><br><span class="line">tidy        增加丢失的module，去掉未用的module</span><br><span class="line">vendor      将依赖复制到vendor下,注意依赖需要在import 中声明后才能进行导入</span><br><span class="line">verify      校验依赖</span><br><span class="line">why         解释为什么需要依赖</span><br></pre></td></tr></table></figure>
<h2 id="go-get-…"><a href="#go-get-…" class="headerlink" title="go get ./…"></a>go get ./…</h2><p>查找出当前项目的依赖，并进行下载</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>GOPROXY 只有在GO111MODULE开启的时候生效，并且使用 go ./… 命令才能用到代理</p>
<ul>
<li><a href="http://mirrors.aliyun.com/goproxy" target="_blank" rel="noopener">http://mirrors.aliyun.com/goproxy</a> #阿里云代理</li>
<li><a href="https://goproxy.cn" target="_blank" rel="noopener">https://goproxy.cn</a> #七牛云代理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GOPROXY&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;goproxy&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="使用本地包"><a href="#使用本地包" class="headerlink" title="使用本地包"></a>使用本地包</h2><p>go.mod 文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require modtest v0.0.0</span><br><span class="line">replace modtest v0.0.0 &#x3D;&gt; ..&#x2F;modtest</span><br></pre></td></tr></table></figure>

<h2 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h2><p>1.使用GOPATH模式进行打包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GO111MODULE&#x3D;off</span><br><span class="line">go build  -a -v -o app main.go</span><br></pre></td></tr></table></figure>
<p>2.使用vendor目录下包来进行打包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GO111MODULE&#x3D;on</span><br><span class="line">go build -mod&#x3D;vendor -a -v -o app main.go</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>gomod</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka/kafak介绍</title>
    <url>/2020/04/01/kafka/kafak%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Kafka是最初由Linkedin公司开发，是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统（也可以当做MQ系统），常见可以用于web/nginx日志、访问日志，消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。</p>
<a id="more"></a>
<p>主要应用场景是：日志收集系统和消息系统</p>
<p>Kafka主要设计目标如下：</p>
<ul>
<li>以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间的访问性能。</li>
<li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条消息的传输。</li>
<li>支持Kafka Server间的消息分区，及分布式消费，同时保证每个partition内的消息顺序传输。</li>
<li>同时支持离线数据处理和实时数据处理。</li>
<li>Scale out:支持在线水平扩展</li>
</ul>
<h2 id="消息系统介绍"><a href="#消息系统介绍" class="headerlink" title="消息系统介绍"></a>消息系统介绍</h2><p>一个消息系统负责将数据从一个应用传递到另外一个应用，应用只需关注于数据，无需关注数据在两个或多个应用间是如何传递的。分布式消息传递基于可靠的消息队列，在客户端应用和消息系统之间异步传递消息。有两种主要的消息传递模式：点对点传递模式、发布-订阅模式。大部分的消息系统选用发布-订阅模式。Kafka就是一种发布-订阅模式。</p>
<h3 id="点对点消息传递模式"><a href="#点对点消息传递模式" class="headerlink" title="点对点消息传递模式"></a>点对点消息传递模式</h3><p>在点对点消息系统中，消息持久化到一个队列中。此时，将有一个或多个消费者消费队列中的数据。但是一条消息只能被消费一次。当一个消费者消费了队列中的某条数据之后，该条数据则从消息队列中删除。该模式即使有多个消费者同时消费数据，也能保证数据处理的顺序。这种架构描述示意图如下：</p>
<p><img src="/2020/04/01/kafka/kafak%E4%BB%8B%E7%BB%8D/1228818-20180507190326476-771565746.png" alt></p>
<p>生产者发送一条消息到queue，只有一个消费者能收到。</p>
<h3 id="发布-订阅消息传递模式"><a href="#发布-订阅消息传递模式" class="headerlink" title="发布-订阅消息传递模式"></a>发布-订阅消息传递模式</h3><p>在发布-订阅消息系统中，消息被持久化到一个topic中。与点对点消息系统不同的是，消费者可以订阅一个或多个topic，消费者可以消费该topic中所有的数据，同一条数据可以被多个消费者消费，数据被消费后不会立马删除。在发布-订阅消息系统中，消息的生产者称为发布者，消费者称为订阅者。该模式的示例图如下：</p>
<p><img src="/2020/04/01/kafka/kafak%E4%BB%8B%E7%BB%8D/1228818-20180507190443404-1266011458.png" alt></p>
<p>发布者发送到topic的消息，只有订阅了topic的订阅者才会收到消息。</p>
<h2 id="Kafka的优点"><a href="#Kafka的优点" class="headerlink" title="Kafka的优点"></a>Kafka的优点</h2><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p>
<h3 id="冗余（副本）"><a href="#冗余（副本）" class="headerlink" title="冗余（副本）"></a>冗余（副本）</h3><p>有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</p>
<h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><p>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。</p>
<h3 id="灵活性-amp-峰值处理能力"><a href="#灵活性-amp-峰值处理能力" class="headerlink" title="灵活性&amp;峰值处理能力"></a>灵活性&amp;峰值处理能力</h3><p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p>
<h3 id="可恢复性"><a href="#可恢复性" class="headerlink" title="可恢复性"></a>可恢复性</h3><p>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p>
<h3 id="顺序保证"><a href="#顺序保证" class="headerlink" title="顺序保证"></a>顺序保证</h3><p>在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。Kafka保证一个Partition内的消息的有序性。</p>
<h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p>在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速。该缓冲有助于控制和优化数据流经过系统的速度</p>
<h3 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h3><p>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p>
<h2 id="常用Message-Queue对比"><a href="#常用Message-Queue对比" class="headerlink" title="常用Message Queue对比"></a>常用Message Queue对比</h2><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。</p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>Redis是一个基于Key-Value对的NoSQL数据库，开发维护很活跃。虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</p>
<h3 id="ZeroMQ"><a href="#ZeroMQ" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h3><p>ZeroMQ号称最快的消息队列系统，尤其针对大吞吐量的需求场景。ZeroMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，技术上的复杂度是对这MQ能够应用成功的挑战。ZeroMQ具有一个独特的非中间件的模式，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序将扮演这个服务器角色。你只需要简单的引用ZeroMQ程序库，可以使用NuGet安装，然后你就可以愉快的在应用程序之间发送消息了。但是ZeroMQ仅提供非持久性的队列，也就是说如果宕机，数据将会丢失。其中，Twitter的Storm 0.9.0以前的版本中默认使用ZeroMQ作为数据流的传输（Storm从0.9版本开始同时支持ZeroMQ和Netty作为传输模块）。</p>
<h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h3><p>ActiveMQ是Apache下的一个子项目。 类似于ZeroMQ，它能够以代理人和点对点的技术实现队列。同时类似于RabbitMQ，它少量代码就可以高效地实现高级应用场景。</p>
<h3 id="Kafka-Jafka"><a href="#Kafka-Jafka" class="headerlink" title="Kafka/Jafka"></a>Kafka/Jafka</h3><p>Kafka是Apache下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理。Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。</p>
<h2 id="Kafka中的术语解释"><a href="#Kafka中的术语解释" class="headerlink" title="Kafka中的术语解释"></a>Kafka中的术语解释</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在深入理解Kafka之前，先介绍一下Kafka中的术语。下图展示了Kafka的相关术语以及之间的关系：</p>
<p><img src="/2020/04/01/kafka/kafak%E4%BB%8B%E7%BB%8D/1228818-20180507190731172-1317551019.png" alt><br>上图中一个topic配置了3个partition。Partition1有两个offset：0和1。Partition2有4个offset。Partition3有1个offset。副本的id和副本所在的机器的id恰好相同。</p>
<p>如果一个topic的副本数为3，那么Kafka将在集群中为每个partition创建3个相同的副本。集群中的每个broker存储一个或多个partition。多个producer和consumer可同时生产和消费数据。</p>
<h3 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h3><p>Kafka集群包含一个或多个服务器，服务器节点称为broker。</p>
<p>broker存储topic的数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个partition。</p>
<p>如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。</p>
<p>如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。</p>
<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</p>
<h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><p>topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。partition中的数据是有序的，不同partition间的数据丢失了数据的顺序。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。</p>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>生产者即数据的发布者，该角色将消息发布到Kafka的topic中。broker接收到生产者发送的消息后，broker将该消息追加到当前用于追加数据的segment文件中。生产者发送的消息，存储到一个partition中，生产者也可以指定数据存储的partition。</p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>消费者可以从broker中读取数据。消费者可以消费多个topic中的数据。</p>
<h3 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h3><p>每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</p>
<h3 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h3><p>每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。</p>
<h3 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h3><p>Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从“in sync replicas”（ISR）列表中删除，重新创建一个Follower。</p>
<blockquote>
<p><a href="https://www.cnblogs.com/qingyunzong/p/9004509.html" target="_blank" rel="noopener">转载自</a></p>
</blockquote>
]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>git/快速认识Git</title>
    <url>/2020/04/01/git/%E5%BF%AB%E9%80%9F%E8%AE%A4%E8%AF%86Git/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>分布式版本控制系统，由Linux创始人Linus使用C语言实现</p>
<a id="more"></a>


<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>初始化一个git 仓库，命令执行后，会在当前目录下生成一个隐藏目录.git</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<h3 id="git本地架构"><a href="#git本地架构" class="headerlink" title="git本地架构"></a>git本地架构</h3><p><img src="/2020/04/01/git/%E5%BF%AB%E9%80%9F%E8%AE%A4%E8%AF%86Git/0.jpeg" alt></p>
<h4 id="git组成"><a href="#git组成" class="headerlink" title="git组成"></a>git组成</h4><ul>
<li>工作区（所有的操作，在git add 之前都位于工作区域）</li>
<li>版本库（整个.git目录）<ul>
<li>暂存区</li>
<li>若干分支</li>
</ul>
</li>
</ul>
<h4 id="文件到版本库的过程"><a href="#文件到版本库的过程" class="headerlink" title="文件到版本库的过程"></a>文件到版本库的过程</h4><ol>
<li>文件位于工作区</li>
<li>使用git add 命令将文件从工作区提交到暂存区</li>
<li>使用git commit 命令将文件从暂存区提交到某个分支（默认提交到当前分支）</li>
</ol>
<h3 id="撤销修改、版本回退"><a href="#撤销修改、版本回退" class="headerlink" title="撤销修改、版本回退"></a>撤销修改、版本回退</h3><ul>
<li>文件位于工作区，丢弃工作区修改，直接从版本库中检出文件覆盖<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></table></figure></li>
<li>文件位于暂存区，暂存区的修改撤销掉，重新放回工作区<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure></li>
<li>文件已经提交到分支<ul>
<li>回滚到上一个版本  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^ #HEAD代表当前版本， HEAD^代表上一个版本</span><br></pre></td></tr></table></figure></li>
<li>回滚到指定版本（向后回滚）  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log #查看版本id</span><br><span class="line">git reset --hard id #执行回滚</span><br></pre></td></tr></table></figure></li>
<li>回滚到指定版本（向前回滚）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reflog #记录了你的每一次操作，通过此命令查看版本id</span><br><span class="line">git reset --hard id #执行回滚</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>远程仓库存在的意义在于同步代码</p>
<h4 id="本地已有仓库，远程仓库为空"><a href="#本地已有仓库，远程仓库为空" class="headerlink" title="本地已有仓库，远程仓库为空"></a>本地已有仓库，远程仓库为空</h4><p>1.将本地仓库关联到远程仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@server-name:path&#x2F;repo-name.git</span><br></pre></td></tr></table></figure>
<blockquote>
<p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</p>
</blockquote>
<p>2.第一次提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令</p>
</blockquote>
<h4 id="本地已有仓库，远程仓库非空"><a href="#本地已有仓库，远程仓库非空" class="headerlink" title="本地已有仓库，远程仓库非空"></a>本地已有仓库，远程仓库非空</h4><p>1.将本地分支和远程分支关联</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to&#x3D;origin&#x2F;master master</span><br></pre></td></tr></table></figure>

<p>2.使用git pull整合远程仓库和本地仓库，使用这个命令后你需要解决本地与远程的冲突，非常麻烦，谨慎使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull --allow-unrelated-histories 忽略版本不同造成的影响</span><br></pre></td></tr></table></figure>

<h4 id="本地无仓库，直接从远程仓库克隆"><a href="#本地无仓库，直接从远程仓库克隆" class="headerlink" title="本地无仓库，直接从远程仓库克隆"></a>本地无仓库，直接从远程仓库克隆</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@server-name:path&#x2F;repo-name.git</span><br></pre></td></tr></table></figure>


<h4 id="git配置过程中fatal-拒绝合并无关的历史"><a href="#git配置过程中fatal-拒绝合并无关的历史" class="headerlink" title="git配置过程中fatal:拒绝合并无关的历史"></a>git配置过程中fatal:拒绝合并无关的历史</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先将远程仓库和本地仓库关联起来：</span><br><span class="line"></span><br><span class="line">git branch --set-upstream-to&#x3D;origin&#x2F;master master</span><br><span class="line"></span><br><span class="line">然后使用git pull整合远程仓库和本地仓库，</span><br><span class="line"></span><br><span class="line">git pull --allow-unrelated-histories    (忽略版本不同造成的影响)</span><br></pre></td></tr></table></figure>

<h3 id="分支合并策略"><a href="#分支合并策略" class="headerlink" title="分支合并策略"></a>分支合并策略</h3><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>使用–no-ff 禁用Fast forward模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure>

<p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>tag 是某个commit id的别名</p>
<h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><ul>
<li>git tag v1.0 # git默认将标签打在当前commit id 上</li>
<li>git tag v0.9 f52c633 #指定commit id 打标签</li>
<li>git tag -a v0.1 -m “version 0.1 released” 1094adb #打出带有说明的标签</li>
<li>git tag #查看标签<blockquote>
<p>标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p>
</blockquote>
</li>
</ul>
<h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><ul>
<li>git tag -d v0.1 #删除标签</li>
<li>git push origin v1.0 #推送标签</li>
<li>git push origin –tags #一次性推送全部尚未推送到远程的本地标签</li>
<li>删除远程标签<ul>
<li>git tag -d v0.9 #先删除本地标签</li>
<li>git push origin :refs/tags/v0.9 #通知远程删除标签</li>
</ul>
</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><ul>
<li>git config –global credential.helper store #记住用户名和密码</li>
<li>git config –global core.filemode false #忽略文件权限的修改</li>
</ul>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><ul>
<li>git checkout – file #撤销git add 操作</li>
<li>git reset HEAD <file> #撤销commit 操作</file></li>
</ul>
<h3 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a>版本回滚</h3><ul>
<li>git reset –hard origin/master #回滚到远程分支，有冲突的时候，放弃本地修改，使用这个</li>
<li>git reset –hard HEAD^ #回到上一个版本</li>
<li>git reset –hard id #回滚到指定版本，配合git log 或者git reflog 使用</li>
</ul>
<h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><ul>
<li>.gitignore <blockquote>
<p>需要注意的是已经提交到版本库中的文件忽略会无效，需要同时使用下面这个命令才会生效,其次.gitignore 文件中如果不指定目录，则会递归的去忽略文件或者目录</p>
</blockquote>
</li>
<li>git update-index –assume-unchanged config/pay.php #忽略已经提交到版本库的文件</li>
</ul>
<h3 id="远程仓库-1"><a href="#远程仓库-1" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul>
<li>git remote add origin git@server-name:path/repo-name.git #添加远程仓库</li>
<li>git remote set-url origin git@server-name:path/repo-name.git #修改远程仓库地址</li>
<li>git push -u origin master #第一次推送，实际上这条命令是将当前的master分支推送到远程分支,git 会自动关联远程的分支和本地的分支</li>
</ul>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ul>
<li>git checkout -b dev #创建并切换到dev分支</li>
<li>git branch –set-upstream-to=origin/dev dev #将远程的dev分支与本地的dev分支进行关联</li>
<li>git checkout -b dev origin/dev #创建并切换到dev分支并与远程dev分支关联(直接拉取远程分支)</li>
<li>git checkout master #切换到master分支</li>
<li>git merge –no-ff -m ‘合并dev分支’ dev # 禁用快进方式合并分支</li>
<li>git branch -d feature-vulcan #删除一个已经合并过的分支</li>
<li>git branch -D feature-vulcan #删除一个没有合并国的分支</li>
<li>git push origin –delete branchName # 删除远程分支</li>
<li>git remote prune origin #删除所有远端已经删除本地仍然存在的分支,本地未推送到远端的分支不会被删除</li>
</ul>
<h3 id="标签-1"><a href="#标签-1" class="headerlink" title="标签"></a>标签</h3><ul>
<li>git tag -a <tagname> -m “blablabla…” #为某一次提交打一个标签</tagname></li>
<li>git push origin v1.01 #将v1.01标签推送到远程</li>
<li>git push origin :refs/tags/v1.00  #删除远程v1.00标签</li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul>
<li>git log –graph –pretty=oneline –abbrev-commit #友好的显示日志信息，在linux下可以为这个长命令起一个别名</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>go/goland使用</title>
    <url>/2020/04/01/go/goland%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ul>
<li>AsciiDoc #文档输出markdown转pdf</li>
<li>Protobuf Support  </li>
<li>Protobuf Buffer Editor #proto语法提示</li>
<li>Translation # 翻译</li>
<li></li>
</ul>
<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><ul>
<li>Ctrl+Shift+T #快速生成测试文件</li>
<li>Alt+Shift+左 #回到上一次光标停留的地方</li>
<li>Alt+F12 #切换编辑框和terminal </li>
<li>Esc #从目录切换到代码编辑区域</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>go/goland激活教程</title>
    <url>/2020/04/01/go/goland%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>提供三种方式进行激活</p>
<h2 id="申请使用License（推荐）"><a href="#申请使用License（推荐）" class="headerlink" title="申请使用License（推荐）"></a>申请使用License（推荐）</h2><p>转载自<a href="https://www.toutiao.com/a6744540170936123916/" target="_blank" rel="noopener">免费获取 JetBrains 全系产品正版 License</a></p>
<a id="more"></a>

<h3 id="项目要求"><a href="#项目要求" class="headerlink" title="项目要求"></a>项目要求</h3><p>要申请获取免费的正版 License，有两个条件;</p>
<ul>
<li>你自己的项目</li>
<li>项目必须在目前三个月内保持活跃的提交记录<blockquote>
<p>对于项目的内容、star 之类的目前并没有什么硬性要求</p>
</blockquote>
</li>
</ul>
<h3 id="给项目添加-License"><a href="#给项目添加-License" class="headerlink" title="给项目添加 License"></a>给项目添加 License</h3><p>首先在申请之前，我们需要给自己的开源项目添加 License，后面在申请的时候会使用到。在我们的项目 GitHub 页面上点击”Create new file”，然后输入 LICENSE， GitHub 会给我们提供一些 LICENSE 的模板，我们可以根据模板来选择合适的开源 LICENSE，比如我这里就选择的是”Apache License 2.0”协议<br><img src="/2020/04/01/go/goland%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B/527bcd19ed0e4dc2a2b0ea16701efab0.jpeg" alt></p>
<h3 id="填写申请表"><a href="#填写申请表" class="headerlink" title="填写申请表"></a>填写申请表</h3><p>直接打开申请地址： <a href="https://www.jetbrains.com/shop/eform/opensource，页面上的描述已经非常清楚了。" target="_blank" rel="noopener">https://www.jetbrains.com/shop/eform/opensource，页面上的描述已经非常清楚了。</a></p>
<blockquote>
<p>jetBrains 可通过提供免费的所有产品 License 来支持您的开源项目，以用于项目的开发。如果您是项目负责人或核心贡献者，请填写以下表格以请求支持。</p>
</blockquote>
<p>然后根据我们自己的开源项目填写申请表单即可：<br><img src="/2020/04/01/go/goland%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B/fc9b8e45315e48a398e343525a324a8a.jpeg" alt></p>
<p>申请提交后，会收到一封邮件，意思了收到申请等待提交，等待几天后会收到审核成功的邮件，大概意思是</p>
<blockquote>
<p>已批准您的免费 JetBrains 开源许可证申请。免费订阅有效期为一年。许可证到期前不久，您将收到一封自动电子邮件提醒。如果您的项目当时仍符合我们的支持计划的要求，请随时申请续订。该 License 只能用于开发非商业性开源项目。请不要将它们用于任何商业目的。然后就是如果你觉得 JetBrains 给了你很大的帮助，希望你可以在你的开源项目上能够带上 JetBrains 的徽标。</p>
</blockquote>
<h3 id="获取-License"><a href="#获取-License" class="headerlink" title="获取 License"></a>获取 License</h3><p>上面的邮件是说我们的申请已经通过了，但是还需要做一些配置才能获得具体的 License，点击邮件中的”Take me to my license(s)“链接即可前往处理，首先需要用我们申请的邮箱注册一个 JetBrains 的帐号：<br><img src="/2020/04/01/go/goland%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B/63c48e1c2fea4285b29d0d53a408872d.jpeg" alt></p>
<p>注册后会发送一封激活邮件，通过激活邮件中的链接可以进入 JetBrains 的个人中心，在个人中心我们就可以看到我们申请的开源项目的申请记录：<br><img src="/2020/04/01/go/goland%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B/b91f19fedaf0493dbe176e6ba7103c58.jpeg" alt><br>点击激活 License，这个时候 License 已经可以使用了。但是还需要将该 License 分配给指定的帐号去使用，点击“Assign”，在弹出的页面中填写前面我们注册的 JetBrains 帐号邮箱，确定后这样 License 就被分配到该帐号下面去了，一封包含了激活码的邮件也会发送到邮件中。</p>
<h2 id="淘宝购买激活码"><a href="#淘宝购买激活码" class="headerlink" title="淘宝购买激活码"></a>淘宝购买激活码</h2><p>用了个吧月失效，卖家跑了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6ZUMD7WWWU-eyJsaWNlbnNlSWQiOiI2WlVNRDdXV1dVIiwibGljZW5zZWVOYW1lIjoiSmV0cyBHcm91cCIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0wOS0wMyIsInBhaWRVcFRvIjoiMjAyMC0wOS0wMiJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0wOS0wMyIsInBhaWRVcFRvIjoiMjAyMC0wOS0wMiJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDktMDMiLCJwYWlkVXBUbyI6IjIwMjAtMDktMDIifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDktMDMiLCJwYWlkVXBUbyI6IjIwMjAtMDktMDIifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDktMDMiLCJwYWlkVXBUbyI6IjIwMjAtMDktMDIifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDktMDMiLCJwYWlkVXBUbyI6IjIwMjAtMDktMDIifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDktMDMiLCJwYWlkVXBUbyI6IjIwMjAtMDktMDIifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA5LTAzIiwicGFpZFVwVG8iOiIyMDIwLTA5LTAyIn0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA5LTAzIiwicGFpZFVwVG8iOiIyMDIwLTA5LTAyIn0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA5LTAzIiwicGFpZFVwVG8iOiIyMDIwLTA5LTAyIn0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA5LTAzIiwicGFpZFVwVG8iOiIyMDIwLTA5LTAyIn0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA5LTAzIiwicGFpZFVwVG8iOiIyMDIwLTA5LTAyIn0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA5LTAzIiwicGFpZFVwVG8iOiIyMDIwLTA5LTAyIn0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA5LTAzIiwicGFpZFVwVG8iOiIyMDIwLTA5LTAyIn0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA5LTAzIiwicGFpZFVwVG8iOiIyMDIwLTA5LTAyIn0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0wOS0wMyIsInBhaWRVcFRvIjoiMjAyMC0wOS0wMiJ9XSwiaGFzaCI6IjE0Mjg5NzUwLzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0&#x3D;-Gd8RATyTEnHcAydKuC7N1ZdeLaMP9IR+nlPyVxvLsczAUTGKxcuAYbfz&#x2F;uVtepg8ey4NfJlPNS+AGcGz8x7ImkX9jEV9KElMxPu3tKSdF&#x2F;WKo6JCONX7UtudYa&#x2F;9EQum3banxci&#x2F;qH7jejSrFZSN+YjWQiYTR0Q8gq4&#x2F;a2RyQTgseZfpImY&#x2F;nXkOWLwWArr&#x2F;p+4ddp&#x2F;bWQN4nLTW+Z4ZaQeLE96Z9viCdn62EKOcR02Hfr9Oju9VYQh1L8pGrTqNey5nUSv&#x2F;LQUbVwo5qoYbBRos8l6ewkFNGsuC3vtOgGWSgkgChbDjWhW4Nkm4vDM2NFAphMsS1dgyPw3eJ3C+6A&#x3D;&#x3D;-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO&#x2F;5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij&#x2F;78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB&#x2F;xVy&#x2F;VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE&#x2F;EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl&#x2F;GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn&#x2F;72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN&#x2F;lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D&#x2F;cXmgpOyW&#x2F;1SmBz3XjVIi&#x2F;zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV&#x2F;bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit&#x2F;pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<h2 id="通过网站获取激活码"><a href="#通过网站获取激活码" class="headerlink" title="通过网站获取激活码"></a><a href="http://lookdiv.com/" target="_blank" rel="noopener">通过网站获取激活码</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AHD9079DKZ-eyJsaWNlbnNlSWQiOiJBSEQ5MDc5REtaIiwibGljZW5zZWVOYW1lIjoiSmV0IEdyb3VwcyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0xMi0xNCIsInBhaWRVcFRvIjoiMjAyMC0xMi0xMyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0xMi0xNCIsInBhaWRVcFRvIjoiMjAyMC0xMi0xMyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMTItMTQiLCJwYWlkVXBUbyI6IjIwMjAtMTItMTMifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMTItMTQiLCJwYWlkVXBUbyI6IjIwMjAtMTItMTMifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMTItMTQiLCJwYWlkVXBUbyI6IjIwMjAtMTItMTMifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMTItMTQiLCJwYWlkVXBUbyI6IjIwMjAtMTItMTMifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMTItMTQiLCJwYWlkVXBUbyI6IjIwMjAtMTItMTMifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTEyLTE0IiwicGFpZFVwVG8iOiIyMDIwLTEyLTEzIn0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTEyLTE0IiwicGFpZFVwVG8iOiIyMDIwLTEyLTEzIn0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTEyLTE0IiwicGFpZFVwVG8iOiIyMDIwLTEyLTEzIn0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTEyLTE0IiwicGFpZFVwVG8iOiIyMDIwLTEyLTEzIn0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDE5LTEyLTE0IiwicGFpZFVwVG8iOiIyMDIwLTEyLTEzIn0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTEyLTE0IiwicGFpZFVwVG8iOiIyMDIwLTEyLTEzIn0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTEyLTE0IiwicGFpZFVwVG8iOiIyMDIwLTEyLTEzIn0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTEyLTE0IiwicGFpZFVwVG8iOiIyMDIwLTEyLTEzIn0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0xMi0xNCIsInBhaWRVcFRvIjoiMjAyMC0xMi0xMyJ9XSwiaGFzaCI6IjE1ODE1MDAyLzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0&#x3D;-LSd4oz1ZeZGTkNgA7KqUD6dmIqKNRaJEiAdpNBN3rw86DnEZm6oUoTMdM40mxRG0jz5RpLR8E6&#x2F;A2uA2b9s6fX3U1dAhzuJ7HUpha2OCk9EnYGlIoxnMmYA+ZrCjlfLU2EsLMPcmKHAY5o2excxpbIqLYsNhXN3r2MxEtvGap9Y+hBxNJJYoYjV5glFIiJ&#x2F;9NNAE6s1EqRRlQk2UpFg2ODDlK1JZrQTtIJvH9squs1IFz0fY9i&#x2F;okXIyR4fCUbU2LUp5XbtMn3n2lKb2mEKDWjjSly3cZizAGz7obIixE1HZuEICEPWeAZiU8qc&#x2F;adRt7eUYW81KFdYjLNDXcVckbw&#x3D;&#x3D;-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO&#x2F;5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij&#x2F;78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB&#x2F;xVy&#x2F;VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE&#x2F;EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl&#x2F;GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn&#x2F;72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN&#x2F;lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D&#x2F;cXmgpOyW&#x2F;1SmBz3XjVIi&#x2F;zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV&#x2F;bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit&#x2F;pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><ul>
<li>Translation 翻译</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>goland激活</tag>
      </tags>
  </entry>
  <entry>
    <title>docker/docker-machine</title>
    <url>/2020/04/01/docker/docker-machine/</url>
    <content><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base&#x3D;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;machine&#x2F;releases&#x2F;download&#x2F;v0.16.0 &amp;&amp;</span><br><span class="line">  curl -L $base&#x2F;docker-machine-$(uname -s)-$(uname -m) &gt;&#x2F;tmp&#x2F;docker-machine &amp;&amp;</span><br><span class="line">  sudo mv &#x2F;tmp&#x2F;docker-machine &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-machine &amp;&amp;</span><br><span class="line">  chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-mach</span><br></pre></td></tr></table></figure>
<h3 id="网速慢"><a href="#网速慢" class="headerlink" title="网速慢"></a>网速慢</h3><p>使用xx_net代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo  apt install privoxy</span><br><span class="line">export https_proxy&#x3D;127.0.0.1:8087</span><br><span class="line">export http_proxy&#x3D;127.0.0.1:8087</span><br></pre></td></tr></table></figure>

<h3 id="x509问题"><a href="#x509问题" class="headerlink" title="x509问题"></a>x509问题</h3><p>curl -k 参数跳过证书验证</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-machine create -d  virtualbox manager1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Running pre-create checks...</span><br><span class="line">(manager1) No default Boot2Docker ISO found locally, downloading the latest release...</span><br><span class="line">Error with pre-create check: &quot;Get https:&#x2F;&#x2F;api.github.com&#x2F;repos&#x2F;boot2docker&#x2F;boot2docker&#x2F;releases&#x2F;latest: x509: certificate signed by unknown authority&quot;</span><br></pre></td></tr></table></figure>
<h3 id="直接去下载默认的iso文件"><a href="#直接去下载默认的iso文件" class="headerlink" title="直接去下载默认的iso文件"></a>直接去下载默认的iso文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -Lo ~&#x2F;.docker&#x2F;machine&#x2F;cache&#x2F;boot2docker.iso https:&#x2F;&#x2F;github.com&#x2F;boot2docker&#x2F;boot2docker&#x2F;releases&#x2F;download&#x2F;v19.03.5&#x2F;boot2docker.iso</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">curl: (60) SSL certificate problem: unable to get local issuer certificate</span><br><span class="line">More details here: https:&#x2F;&#x2F;curl.haxx.se&#x2F;docs&#x2F;sslcerts.html</span><br></pre></td></tr></table></figure>


<h3 id="curl-60-SSL-certificate-problem-unable-to-get-local-issuer-certificate问题"><a href="#curl-60-SSL-certificate-problem-unable-to-get-local-issuer-certificate问题" class="headerlink" title="curl: (60) SSL certificate problem: unable to get local issuer certificate问题"></a>curl: (60) SSL certificate problem: unable to get local issuer certificate问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -k --remote-name --time-cond cacert.pem https:&#x2F;&#x2F;curl.haxx.se&#x2F;ca&#x2F;cacert.pem</span><br><span class="line"># 注意执行此命令后需要重新开终端</span><br></pre></td></tr></table></figure>

<p>###　终端下载实在太慢问题</p>
<ol>
<li><a href="https://github.com/boot2docker/boot2docker/releases/download/v19.03.5/boot2docker.iso" target="_blank" rel="noopener">浏览器下载</a></li>
<li>将iso文件移动到　 ~/.docker/machine/cache/boot2docker.iso</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>docker/etcd</title>
    <url>/2020/04/01/docker/etcd/</url>
    <content><![CDATA[<h1 id="docker安装ectd"><a href="#docker安装ectd" class="headerlink" title="docker安装ectd"></a>docker安装ectd</h1><h2 id="etcd-启动参数说明"><a href="#etcd-启动参数说明" class="headerlink" title="etcd 启动参数说明"></a>etcd 启动参数说明</h2><ul>
<li>-name：方便理解的节点名称，默认为 default，在集群中应该保持唯一，可以使用 hostname</li>
<li>-data-dir：服务运行数据保存的路径，默认为 ${name}.etcd</li>
<li>-snapshot-count：指定有多少事务（transaction）被提交时，触发截取快照保存到磁盘</li>
<li>-heartbeat-interval：leader 多久发送一次心跳到 followers。默认值是 100ms</li>
<li>-eletion-timeout：重新投票的超时时间，如果follower在该时间间隔没有收到心跳包，会触发重新投票，默认为 1000 ms</li>
<li>-listen-peer-urls：和同伴通信的地址，比如 <a href="http://ip:2380，如果有多个，使用逗号分隔。需要所有节点都能够访问，所以不要使用">http://ip:2380，如果有多个，使用逗号分隔。需要所有节点都能够访问，所以不要使用</a> localhost</li>
<li>-listen-client-urls：对外提供服务的地址：比如 <a href="http://ip:2379,http://127.0.0.1:2379，客户端会连接到这里和etcd交互">http://ip:2379,http://127.0.0.1:2379，客户端会连接到这里和etcd交互</a></li>
<li>-advertise-client-urls：对外公告的该节点客户端监听地址，这个值会告诉集群中其他节点</li>
<li>-initial-advertise-peer-urls：该节点同伴监听地址，这个值会告诉集群中其他节点</li>
<li>-initial-cluster：集群中所有节点的信息，格式为 node1=<a href="http://ip1:2380,node2=http://ip2:2380,…。需要注意的是，这里的">http://ip1:2380,node2=http://ip2:2380,…。需要注意的是，这里的</a> node1 是节点的–name指定的名字；后面的ip1:2380 是–initial-advertise-peer-urls 指定的值</li>
<li>-initial-cluster-state：新建集群的时候，这个值为 new；假如已经存在的集群，这个值为existing</li>
<li>-initial-cluster-token：创建集群的token，这个值每个集群保持唯一。这样的话，如果你要重新创建集群，即使配置和之前一样，也会再次生成新的集群和节点 uuid；否则会导致多个集群之间的冲突，造成未知的错误</li>
</ul>
<a id="more"></a>

<h2 id="单机版"><a href="#单机版" class="headerlink" title="单机版"></a>单机版</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d  -p 2379:2379 -p 2380:2380 --name etcd quay.io&#x2F;coreos&#x2F;etcd &#x2F;usr&#x2F;local&#x2F;bin&#x2F;etcd -name qf2200-client0  -advertise-client-urls http:&#x2F;&#x2F;0.0.0.0:2379 -listen-client-urls http:&#x2F;&#x2F;0.0.0.0:2379</span><br></pre></td></tr></table></figure>


<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>测试环境：<a href="https://labs.play-with-docker.com/" target="_blank" rel="noopener">play-with-docker</a></p>
<h3 id="docker-machine-准备换环境"><a href="#docker-machine-准备换环境" class="headerlink" title="docker-machine 准备换环境"></a>docker-machine 准备换环境</h3><p>play-with-docker太卡了，自己本地搭建测试环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine create -d virtualbox manager1 &amp;&amp; </span><br><span class="line">docker-machine create -d virtualbox worker1 &amp;&amp; </span><br><span class="line">docker-machine create -d virtualbox worker2</span><br><span class="line"></span><br><span class="line">$ docker-machine ls</span><br><span class="line">NAME       ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER     ERRORS</span><br><span class="line">manager1   -        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.101:2376           v19.03.5   </span><br><span class="line">worker1    -        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.102:2376           v19.03.5   </span><br><span class="line">worker2    -        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.103:2376           v19.03.5</span><br></pre></td></tr></table></figure>


<h3 id="manager1-主机-node1-192-168-99-101"><a href="#manager1-主机-node1-192-168-99-101" class="headerlink" title="manager1 主机(node1 192.168.99.101) :"></a>manager1 主机(node1 192.168.99.101) :</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name etcd \</span><br><span class="line">    -p 2379:2379 \</span><br><span class="line">    -p 2380:2380 \</span><br><span class="line">    --volume&#x3D;etcd-data:&#x2F;etcd-data \</span><br><span class="line">    quay.io&#x2F;coreos&#x2F;etcd \</span><br><span class="line">    &#x2F;usr&#x2F;local&#x2F;bin&#x2F;etcd \</span><br><span class="line">    -name node1 \</span><br><span class="line">    -data-dir&#x3D;&#x2F;etcd-data \</span><br><span class="line">    -initial-advertise-peer-urls http:&#x2F;&#x2F;192.168.99.101:2380 \</span><br><span class="line">    -listen-peer-urls http:&#x2F;&#x2F;0.0.0.0:2380 \</span><br><span class="line">    -advertise-client-urls http:&#x2F;&#x2F;192.168.99.101:2379 \</span><br><span class="line">    -listen-client-urls http:&#x2F;&#x2F;0.0.0.0:2379 \</span><br><span class="line">    -initial-cluster-state new \</span><br><span class="line">    -initial-cluster-token docker-etcd \</span><br><span class="line">    -initial-cluster node1&#x3D;http:&#x2F;&#x2F;192.168.99.101:2380,node2&#x3D;http:&#x2F;&#x2F;192.168.99.102:2380,node3&#x3D;http:&#x2F;&#x2F;192.168.99.103:2380</span><br></pre></td></tr></table></figure>

<h3 id="worker1-主机（node2-192-168-99-102）："><a href="#worker1-主机（node2-192-168-99-102）：" class="headerlink" title="worker1 主机（node2 192.168.99.102）："></a>worker1 主机（node2 192.168.99.102）：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name etcd \</span><br><span class="line">    -p 2379:2379 \</span><br><span class="line">    -p 2380:2380 \</span><br><span class="line">    --volume&#x3D;etcd-data:&#x2F;etcd-data \</span><br><span class="line">    quay.io&#x2F;coreos&#x2F;etcd \</span><br><span class="line">    &#x2F;usr&#x2F;local&#x2F;bin&#x2F;etcd \</span><br><span class="line">    -name node2 \</span><br><span class="line">    -data-dir&#x3D;&#x2F;etcd-data \</span><br><span class="line">    -initial-advertise-peer-urls http:&#x2F;&#x2F;192.168.99.102:2380 \</span><br><span class="line">    -listen-peer-urls http:&#x2F;&#x2F;0.0.0.0:2380 \</span><br><span class="line">    -advertise-client-urls http:&#x2F;&#x2F;192.168.99.102:2379 \</span><br><span class="line">    -listen-client-urls http:&#x2F;&#x2F;0.0.0.0:2379 \</span><br><span class="line">    -initial-cluster-state existing \</span><br><span class="line">    -initial-cluster-token docker-etcd \</span><br><span class="line">    -initial-cluster node1&#x3D;http:&#x2F;&#x2F;192.168.99.101:2380,node2&#x3D;http:&#x2F;&#x2F;192.168.99.102:2380,node3&#x3D;http:&#x2F;&#x2F;192.168.99.103:2380</span><br></pre></td></tr></table></figure>

<h3 id="worker2-主机（node3-192-168-99-103）："><a href="#worker2-主机（node3-192-168-99-103）：" class="headerlink" title="worker2 主机（node3 192.168.99.103）："></a>worker2 主机（node3 192.168.99.103）：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name etcd \</span><br><span class="line">    -p 2379:2379 \</span><br><span class="line">    -p 2380:2380 \</span><br><span class="line">    --volume&#x3D;etcd-data:&#x2F;etcd-data \</span><br><span class="line">    quay.io&#x2F;coreos&#x2F;etcd \</span><br><span class="line">    &#x2F;usr&#x2F;local&#x2F;bin&#x2F;etcd \</span><br><span class="line">    -name node3 \</span><br><span class="line">    -data-dir&#x3D;&#x2F;etcd-data \</span><br><span class="line">    -initial-advertise-peer-urls http:&#x2F;&#x2F;192.168.99.103:2380 \ </span><br><span class="line">    -listen-peer-urls http:&#x2F;&#x2F;0.0.0.0:2380 \</span><br><span class="line">    -advertise-client-urls http:&#x2F;&#x2F;192.168.99.103:2379 \</span><br><span class="line">    -listen-client-urls http:&#x2F;&#x2F;0.0.0.0:2379 \</span><br><span class="line">    -initial-cluster-state existing \</span><br><span class="line">    -initial-cluster-token docker-etcd \</span><br><span class="line">    -initial-cluster node1&#x3D;http:&#x2F;&#x2F;192.168.99.101:2380,node2&#x3D;http:&#x2F;&#x2F;192.168.99.102:2380,node3&#x3D;http:&#x2F;&#x2F;192.168.99.103:2380</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker-install-ware</tag>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>etcd/etcd概念以及原理</title>
    <url>/2020/04/01/etcd/etcd%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="什么是Etcd"><a href="#什么是Etcd" class="headerlink" title="什么是Etcd"></a>什么是Etcd</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>etcd是CoreOS团队于2013年6月发起的开源项目，它的目标是构建一个高可用的分布式键值(key-value)数据库。etcd内部采用raft协议作为一致性算法，etcd基于Go语言实现。</p>
<a id="more"></a>

<h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><ul>
<li>将数据存储在集群中的高可用K-V存储</li>
<li>允许应用实时监听存储中的K-V的变化</li>
<li>能够容忍单点故障，能够应对网络分区</li>
</ul>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>Etcd主要分为4个部分</p>
<ul>
<li>HTTP Server： 用于处理用户发送的API请求以及其它etcd节点的同步与心跳信息请求。</li>
<li>Store：用于处理etcd支持的各类功能的事务，包括数据索引、节点状态变更、监控与反馈、事件处理与执行等等，是etcd对用户提供的大多数API功能的具体实现</li>
<li>Raft：Raft强一致性算法的具体实现，是etcd的核心。</li>
<li>WAL：Write Ahead Log（预写式日志），是etcd的数据存储方式。除了在内存中存有所有数据的状态以及节点的索引以外，etcd就通过WAL进行持久化存储。WAL中，所有的数据提交前都会事先记录日志。Snapshot是为了防止数据过多而进行的状态快照；Entry表示存储的具体日志内容。<br>通常，一个用户的请求发送过来，会经由HTTP Server转发给Store进行具体的事务处理，如果涉及到节点的修改，则交给Raft模块进行状态的变更、日志的记录，然后再同步给别的etcd节点以确认数据提交，最后进行数据的提交，再次同步。</li>
</ul>
<h2 id="主要应用场景"><a href="#主要应用场景" class="headerlink" title="主要应用场景"></a>主要应用场景</h2><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>服务发现要解决的也是分布式系统中最常见的问题之一，即即在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。本质上来说，服务发现就 是想要了解集群中是否有进程在监听udp或tcp端口，并且通过名字就可以查找和连接。要解决服务发现的问题，需要有下面三大支柱，缺一不可。  </p>
<ul>
<li>一个强一致性、高可用的服务存储目录<br>基于Raft算法的etcd天生就是这样一个强一致性高可用的服务存储目录。</li>
<li>一种注册服务和监控服务健康状态的机制。<br>用户可以在etcd中注册服务，并且对注册的服务设置key TTL，定时保持服务的心跳以达到监控健康状态的效果。</li>
<li>一种查找和连接服务的机制<br>通过在etcd指定的主题下注册的服务也能在对应的主题下查找到。为了确保连接，我们可以在每个服务机器上都部署一个Proxy模式的etcd，这样就可以确保能访问etcd集群的服务都能互相连接。  </li>
</ul>
<h3 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h3><p>etcd 提供watch机制，实时读取配置信息，分布式应用中会有多个程序，每个程序都需要记录一些配置信息，如mysql，redis,连接信息，如果这些信息发生变动，成千上百的容器，要去手动更改配置，将是一场噩梦，<br>通过etcd的watch机制去监听配置信息，实时进行改变</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>因为etcd使用Raft算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。  </p>
<ul>
<li>保持独占即所有获取锁的用户最终只有一个可以得到。<br>etcd为此提供了一套实现分布式锁原子操作CAS（CompareAndSwap）的API。通过设置prevExist值，可以保证在多个节点同时去创建某个目录时，只有一个成功。而创建成功的用户就可以认为是获得了锁。</li>
<li>控制时序,即所有想要获得锁的用户都会被安排执行，但是获得锁的顺序也是全局唯一的，同时决定了执行顺序。<br>etcd为此也提供了一套API（自动创建有序键），对一个目录建值时指定为POST动作，这样etcd会自动在目录下生成一个当前最大的值为键，存储这个新的值（客户端编号）。同时还可以使用API按顺序列出所有当前目录下的键值。此时这些键的值就是客户端的时序，而这些键中存储的值可以是代表客户端的编号。</li>
</ul>
<h3 id="概念词汇"><a href="#概念词汇" class="headerlink" title="概念词汇"></a>概念词汇</h3><ul>
<li>Raft：etcd所采用的保证分布式系统强一致性的算法。</li>
<li>Node：一个Raft状态机实例。</li>
<li>Member： 一个etcd实例。它管理着一个Node，并且可以为客户端请求提供服务。</li>
<li>Cluster：由多个Member构成可以协同工作的etcd集群。</li>
<li>Peer：对同一个etcd集群中另外一个Member的称呼。</li>
<li>Client： 向etcd集群发送HTTP请求的客户端。</li>
<li>WAL：预写式日志，etcd用于持久化存储的日志格式。</li>
<li>snapshot：etcd防止WAL文件过多而设置的快照，存储etcd数据状态。</li>
<li>Proxy：etcd的一种模式，为etcd集群提供反向代理服务。</li>
<li>Leader：Raft算法中通过竞选而产生的处理所有数据提交的节点。</li>
<li>Follower：竞选失败的节点作为Raft中的从属节点，为算法提供强一致性保证。</li>
<li>Candidate：当Follower超过一定时间接收不到Leader的心跳时转变为Candidate开始竞选。</li>
<li>Term：某个节点成为Leader到下一次竞选时间，称为一个Term。</li>
<li>Index：数据项编号。Raft中通过Term和Index来定位数据</li>
</ul>
<h2 id="ETCD工作原理"><a href="#ETCD工作原理" class="headerlink" title="ETCD工作原理"></a>ETCD工作原理</h2><p>ETCD使用Raft协议来维护集群内各个节点状态的一致性。简单说，ETCD集群是一个分布式系统，由多个节点相互通信构成整体对外服务，每个节点都存储了完整的数据，并且通过Raft协议保证每个节点维护的数据是一致的。<br><img src="/2020/04/01/etcd/etcd%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86/1d700b6401f7b95e0d1a4f0d9a69d41a6427eeb7.png" alt><br>如图所示，每个ETCD节点都维护了一个状态机，并且，任意时刻至多存在一个有效的主节点。主节点处理所有来自客户端写操作，通过Raft协议保证写操作对状态机的改动会可靠的同步到其他节点。</p>
<h3 id="选主"><a href="#选主" class="headerlink" title="选主"></a>选主</h3><p>Raft协议是用于维护一组服务节点数据一致性的协议。这一组服务节点构成一个集群，并且有一个主节点来对外提供服务。当集群初始化，或者主节点挂掉后，面临一个选主问题。集群中每个节点，任意时刻处于Leader, Follower, Candidate这三个角色之一。选举特点如下：  </p>
<ul>
<li>当集群初始化时候，每个节点都是Follower角色；  </li>
<li>集群中存在至多1个有效的主节点，通过心跳与其他节点同步数据；<br>当Follower在一定时间内没有收到来自主节点的心跳，会将自己角色改变为Candidate，并发起一次选主投票；当收到包括自己在内超过半数节点赞成后，选举成功；当收到票数不足半数选举失败，或者选举超时。若本轮未选出主节点，将进行下一轮选举（出现这种情况，是由于多个节点同时选举，所有节点均为获得过半选票）。<br>Candidate节点收到来自主节点的信息后，会立即终止选举过程，进入Follower角色。<br>为了避免陷入选主失败循环，每个节点未收到心跳发起选举的时间是一定范围内的随机值，这样能够避免2个节点同时发起选主。</li>
</ul>
<h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p>所谓日志复制，是指主节点将每次操作形成日志条目，并持久化到本地磁盘，然后通过网络IO发送给其他节点。其他节点根据日志的逻辑时钟(TERM)和日志编号(INDEX)来判断是否将该日志记录持久化到本地。当主节点收到包括自己在内超过半数节点成功返回，那么认为该日志是可提交的(committed），并将日志输入到状态机，将结果返回给客户端。  </p>
<p>这里需要注意的是，每次选主都会形成一个唯一的TERM编号，相当于逻辑时钟。每一条日志都有全局唯一的编号。  </p>
<p>主节点通过网络IO向其他节点追加日志。若某节点收到日志追加的消息，首先判断该日志的TERM是否过期，以及该日志条目的INDEX是否比当前以及提交的日志的INDEX跟早。若已过期，或者比提交的日志更早，那么就拒绝追加，并返回该节点当前的已提交的日志的编号。否则，将日志追加，并返回成功。  </p>
<p>当主节点收到其他节点关于日志追加的回复后，若发现有拒绝，则根据该节点返回的已提交日志编号，发生其编号下一条日志。  </p>
<p>主节点像其他节点同步日志，还作了拥塞控制。具体地说，主节点发现日志复制的目标节点拒绝了某次日志追加消息，将进入日志探测阶段，一条一条发送日志，直到目标节点接受日志，然后进入快速复制阶段，可进行批量日志追加。</p>
<p>按照日志复制的逻辑，我们可以看到，集群中慢节点不影响整个集群的性能。另外一个特点是，数据只从主节点复制到Follower节点，这样大大简化了逻辑流程。</p>
<h3 id="数据安全性"><a href="#数据安全性" class="headerlink" title="数据安全性"></a>数据安全性</h3><p>截止此刻，选主以及日志复制并不能保证节点间数据一致。试想，当一个某个节点挂掉了，一段时间后再次重启，并当选为主节点。而在其挂掉这段时间内，集群若有超过半数节点存活，集群会正常工作，那么会有日志提交。这些提交的日志无法传递给挂掉的节点。当挂掉的节点再次当选主节点，它将缺失部分已提交的日志。在这样场景下，按Raft协议，它将自己日志复制给其他节点，会将集群已经提交的日志给覆盖掉。  </p>
<p>其他协议解决这个问题的办法是，新当选的主节点会询问其他节点，和自己数据对比，确定出集群已提交数据，然后将缺失的数据同步过来。这个方案有明显缺陷，增加了集群恢复服务的时间（集群在选举阶段不可服务），并且增加了协议的复杂度。<br>Raft解决的办法是，在选主逻辑中，对能够成为主的节点加以限制，确保选出的节点已定包含了集群已经提交的所有日志。如果新选出的主节点已经包含了集群所有提交的日志，那就不需要从和其他节点比对数据了。简化了流程，缩短了集群恢复服务的时间。</p>
<p>这里存在一个问题，加以这样限制之后，还能否选出主呢？答案是：只要仍然有超过半数节点存活，这样的主一定能够选出。因为已经提交的日志必然被集群中超过半数节点持久化，显然前一个主节点提交的最后一条日志也被集群中大部分节点持久化。当主节点挂掉后，集群中仍有大部分节点存活，那这存活的节点中一定存在一个节点包含了已经提交的日志了。</p>
<h2 id="集群节点数量"><a href="#集群节点数量" class="headerlink" title="集群节点数量"></a>集群节点数量</h2><p>etcd推荐使用奇数作为集群节点个数。因为奇数个节点和其配对的偶数个节点相比，容错能力相同，却可以少一个节点。综合考虑性能和容错能力，etcd官方文档推荐的etcd集群大小是3,5,7。由于etcd使用是Raft算法，每次写入数据需要有2N+1个节点同意可以写入数据，所以部分节点由于网络或者其他不可靠因素延迟收到数据更新，但是最终数据会保持一致，高度可靠。随着节点数目的增加，每次的写入延迟会相应的线性递增，除了节点数量会影响写入数据的延迟，如果节点跟接节点之间的网络延迟，也会导致数据的延迟写入。</p>
<ul>
<li>节点数并非越多越好，过多的节点将会导致数据延迟写入。</li>
<li>节点跟节点之间的跨机房，专线之间网络延迟，也将会导致数据延迟写入。</li>
<li>受网络IO和磁盘IO的延迟</li>
<li>为了提高吞吐量，etcd通常将多个请求一次批量处理并提交Raft，</li>
<li>增加节点，读性能会提升，写性能会下降，减少节点，写性能会提升。</li>
</ul>
]]></content>
      <categories>
        <category>etcd</category>
      </categories>
      <tags>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>git/Git团队协作最佳实践-GitFlow</title>
    <url>/2020/04/01/git/Git%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-GitFlow/</url>
    <content><![CDATA[<h2 id="Git的优点"><a href="#Git的优点" class="headerlink" title="Git的优点"></a>Git的优点</h2><ul>
<li>分布式，不需要远程仓库，也可以正常工作</li>
<li>优秀的分支模型，创建和删除方便且高效，因为分支的创建和删除，只是操作HEAD指针。</li>
<li>分支合并轻松<a id="more"></a>

</li>
</ul>
<h2 id="版本管理的挑战"><a href="#版本管理的挑战" class="headerlink" title="版本管理的挑战"></a>版本管理的挑战</h2><p>虽然有这么优秀的版本管理工具，但是我们面对版本管理的时候，依然有非常大得挑战，我们都知道大家工作在同一个仓库上，那么彼此的代码协作必然带来很多问题和挑战，如下：</p>
<ul>
<li>如何开始一个Feature的开发，而不影响别的Feature？</li>
<li>由于很容易创建新分支，分支多了如何管理，时间久了，如何知道每个分支是干什么的？</li>
<li>哪些分支已经合并回了主干？</li>
<li>如何进行Release的管理？开始一个Release的时候如何冻结Feature, 如何在Prepare Release的时候，开发人员可以继续开发新的功能？</li>
<li>线上代码出Bug了，如何快速修复？而且修复的代码要包含到开发人员的分支以及下一个Release?</li>
</ul>
<p>大部分开发人员现在使用Git就只是用三个甚至两个分支，一个是Master, 一个是Develop, 还有一个是基于Develop打得各种分支。这个在小项目规模的时候还勉强可以支撑，因为很多人做项目就只有一个Release, 但是人员一多，而且项目周期一长就会出现各种问题。</p>
<h2 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h2><p>就像代码需要代码规范一样，代码管理同样需要一个清晰的流程和规范</p>
<p>Vincent Driessen 同学为了解决这个问题提出了 <a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A Successful Git Branching Model</a></p>
<p>下面是Git Flow的流程图<br><img src="/2020/04/01/git/Git%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-GitFlow/git-model@2x.png" alt></p>
<h3 id="Git-Flow常用分支"><a href="#Git-Flow常用分支" class="headerlink" title="Git Flow常用分支"></a>Git Flow常用分支</h3><ul>
<li>Production分支<blockquote>
<p> 也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改</p>
</blockquote>
</li>
<li>Develop 分支 <blockquote>
<p>这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支</p>
</blockquote>
</li>
<li>Feature 分支 <blockquote>
<p>这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release</p>
</blockquote>
</li>
<li>Release分支 <blockquote>
<p>当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支</p>
</blockquote>
</li>
<li>Hotfix分支 <blockquote>
<p>当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release</p>
</blockquote>
</li>
</ul>
<h3 id="Git-Flow工作原理"><a href="#Git-Flow工作原理" class="headerlink" title="Git Flow工作原理"></a>Git Flow工作原理</h3><h4 id="初始分支"><a href="#初始分支" class="headerlink" title="初始分支"></a>初始分支</h4><p>所有在Master分支上的Commit应该Tag<br><img src="/2020/04/01/git/Git%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-GitFlow/o_git-workflow-release-cycle-1historical.png" alt></p>
<h4 id="Feature-分支"><a href="#Feature-分支" class="headerlink" title="Feature 分支"></a>Feature 分支</h4><p>分支名 feature/*</p>
<p>Feature分支做完后，必须合并回Develop分支, 合并完分支后一般会删点这个Feature分支，但是我们也可以保留<br><img src="/2020/04/01/git/Git%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-GitFlow/o_git-workflow-release-cycle-2feature.png" alt></p>
<h4 id="Release分支"><a href="#Release分支" class="headerlink" title="Release分支"></a>Release分支</h4><p>分支名 release/*</p>
<p>Release分支基于Develop分支创建，打完Release分之后，我们可以在这个Release分支上测试，修改Bug等。同时，其它开发人员可以基于开发新的Feature<br>(记住：一旦打了Release分支之后不要从Develop分支上合并新的改动到Release分支)</p>
<p>发布Release分支时，合并Release到Master和Develop， 同时在Master分支上打个Tag记住Release版本号，然后可以删除Release分支了。<br><img src="/2020/04/01/git/Git%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-GitFlow/o_git-workflow-release-cycle-3release.png" alt></p>
<h4 id="维护分支-Hotfix"><a href="#维护分支-Hotfix" class="headerlink" title="维护分支 Hotfix"></a>维护分支 Hotfix</h4><p>分支名 hotfix/*</p>
<p>hotfix分支基于Master分支创建，开发完后需要合并回Master和Develop分支，同时在Master上打一个tag<br><img src="/2020/04/01/git/Git%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-GitFlow/o_git-workflow-release-cycle-4maintenance.png" alt></p>
<h3 id="Git-Flow代码示例"><a href="#Git-Flow代码示例" class="headerlink" title="Git Flow代码示例"></a>Git Flow代码示例</h3><ol>
<li><p>创建develop分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch  develop</span><br><span class="line">git push -u origin develop</span><br></pre></td></tr></table></figure>
</li>
<li><p>开始新Feature开发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b some-feature develop</span><br><span class="line"></span><br><span class="line"># 推送功能分支到远程，也可以不推送</span><br><span class="line">git push -u origin some-feature    </span><br><span class="line"></span><br><span class="line"># 做一些改动    </span><br><span class="line">git status</span><br><span class="line">git add some-file</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成Feature</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull origin develop</span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff some-feature</span><br><span class="line">git push origin develop</span><br><span class="line"></span><br><span class="line">git branch -d some-feature</span><br><span class="line"></span><br><span class="line"># 如果你推送了功能分支到远程，执行这个命令删除远程分支</span><br><span class="line">git push origin --delete some-feature</span><br></pre></td></tr></table></figure>
</li>
<li><p>开始Relase</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b release-0.1.0 develop</span><br><span class="line"></span><br><span class="line"># 如果有bug 在此分支上处理</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成Release</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 合并release到master</span><br><span class="line">git checkout master</span><br><span class="line">git merge --no-ff release-0.1.0</span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"># 合并release到develop </span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff release-0.1.0</span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"># 删除release分支</span><br><span class="line">git branch -d release-0.1.0</span><br><span class="line"></span><br><span class="line"># 如果分支推送到了远程，删除远程分支:</span><br><span class="line">git push origin --delete release-0.1.0 </span><br><span class="line"></span><br><span class="line"># 在master分支上打出版本号</span><br><span class="line">git tag -a v0.1.0 master</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>
</li>
<li><p>开始Hotfix</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b hotfix-0.1.1 master</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成Hotfix</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge --no-ff hotfix-0.1.1</span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff hotfix-0.1.1</span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line">git branch -d hotfix-0.1.1</span><br><span class="line"></span><br><span class="line">git tag -a v0.1.1 master</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Git-flow工具"><a href="#Git-flow工具" class="headerlink" title="Git flow工具"></a>Git flow工具</h3><p>实际上，当你理解了上面的流程后，你完全不用使用工具，但是实际上我们大部分人很多命令就是记不住呀，流程就是记不住呀，肿么办呢？</p>
<p>总有聪明的人创造好的工具给大家用, 那就是Git flow script.</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li>OS X<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install git-flow</span><br></pre></td></tr></table></figure></li>
<li>Linux<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install git-flow</span><br></pre></td></tr></table></figure></li>
<li>Windows<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -q -O - --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;nvie&#x2F;gitflow&#x2F;raw&#x2F;develop&#x2F;contrib&#x2F;gitflow-installer.sh | bash</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li>初始化: git flow init</li>
<li>开始新Feature: git flow feature start MYFEATURE</li>
<li>Publish一个Feature(也就是push到远程): git flow feature publish MYFEATURE</li>
<li>获取Publish的Feature: git flow feature pull origin MYFEATURE</li>
<li>完成一个Feature: git flow feature finish MYFEATURE</li>
<li>开始一个Release: git flow release start RELEASE [BASE]</li>
<li>Publish一个Release: git flow release publish RELEASE</li>
<li>完成Release: git flow release finish RELEASE</li>
<li>推送tag: git push –tags</li>
<li>开始一个Hotfix: git flow hotfix start VERSION [BASENAME]</li>
<li>发布一个Hotfix: git flow hotfix finish VERSION<br><img src="/2020/04/01/git/Git%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-GitFlow/o_git-flow-commands.png" alt></li>
</ul>
<h4 id="GUI工具-SourceTree"><a href="#GUI工具-SourceTree" class="headerlink" title="GUI工具-SourceTree"></a>GUI工具-SourceTree</h4><p>目前SourceTree支持Mac, Windows, Linux.<br>使用 自行探索</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://www.cnblogs.com/wish123/p/9785101.html" target="_blank" rel="noopener">Git 在团队中的最佳实践–如何正确使用Git Flow</a></p>
</li>
<li><p>声明：本站部分图片或文章内容来源于网络，版权归原作者所有，如有侵权，请与我联系删除。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git-flow</tag>
      </tags>
  </entry>
</search>
