<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="D033aiBRFi">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://phpdi.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="自律给我自由">
<meta property="og:type" content="website">
<meta property="og:title" content="phpdi">
<meta property="og:url" content="https://phpdi.github.io/index.html">
<meta property="og:site_name" content="phpdi">
<meta property="og:description" content="自律给我自由">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chen Yu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://phpdi.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title> phpdi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">phpdi</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">飞向自由</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://phpdi.github.io/2020/07/22/micro/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%8B%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_20200115_173549.jpg">
      <meta itemprop="name" content="Chen Yu">
      <meta itemprop="description" content="自律给我自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="phpdi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/22/micro/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%8B%E8%AE%B0/" class="post-title-link" itemprop="url">micro/微服务手记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-22 10:07:42 / 修改时间：14:03:33" itemprop="dateCreated datePublished" datetime="2020-07-22T10:07:42+08:00">2020-07-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>微服务将单体应用系统拆分成多个分而治之的小应用,降低系统整体崩溃的风险性;同时也可根据这些小应用的不同需求调整实体机的性能</p>
<p>微服务主要缺点是将系统复杂化,但对于本身就复杂的系统,微服务受益会很高  </p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>判定标准,使用微服务后开发和维护变得轻松了,而不是困难  </p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1.化繁为简,分散治理<br>2.服务间松耦合,服务内高内聚<br>3.服务可独立构建/部署/升级,局部更新<br>4.提高系统容错性,减少系统整体崩溃的概率<br>5.易于实现异构系统  </p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1.增加了运维部署的工作量与难度<br>2.增加了系统间调用逻辑的处理难度<br>3.日志更男收集和统计了<br>4.额外引入了一些非业务模块服务</p>
<h1 id="go-micro"><a href="#go-micro" class="headerlink" title="go-micro"></a>go-micro</h1><ul>
<li>服务发现: 支持服务注册与发现,底层支持etcd/consul/k8s</li>
<li>负载均衡: rpc服务间的请求调度均衡策略</li>
<li>同步通信: 基于RPC通信,支持单向/双向流通信模式</li>
<li>异步通信: 提供pub/sub通信模型的接口</li>
<li>高级接口: 比如服务发现,提供调用的接口是一致的</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://phpdi.github.io/2020/06/16/go/Mastering_Go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_20200115_173549.jpg">
      <meta itemprop="name" content="Chen Yu">
      <meta itemprop="description" content="自律给我自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="phpdi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/16/go/Mastering_Go/" class="post-title-link" itemprop="url">go/Mastering_Go</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-16 17:37:51" itemprop="dateCreated datePublished" datetime="2020-06-16T17:37:51+08:00">2020-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-19 11:23:19" itemprop="dateModified" datetime="2020-06-19T11:23:19+08:00">2020-06-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第2章-Go内部机制"><a href="#第2章-Go内部机制" class="headerlink" title="第2章 Go内部机制"></a>第2章 Go内部机制</h1><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收是释放掉那些不再使用的内存空间的过程.</p>
<h2 id="golang-GC算法演变过程"><a href="#golang-GC算法演变过程" class="headerlink" title="golang GC算法演变过程"></a>golang GC算法演变过程</h2><table>
<thead>
<tr>
<th align="center">版本</th>
<th align="center">GC算法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">v1.1</td>
<td align="center">STW(stop the word)</td>
</tr>
<tr>
<td align="center">v1.3</td>
<td align="center">Mark STW,Sweep(标记清除)</td>
</tr>
<tr>
<td align="center">v1.5</td>
<td align="center">三色标记</td>
</tr>
<tr>
<td align="center">v1.8</td>
<td align="center">hybrid write barrier(三色标记基础上加入写屏障)</td>
</tr>
</tbody></table>
<h2 id="标记清除算法-mark-and-sweep"><a href="#标记清除算法-mark-and-sweep" class="headerlink" title="标记清除算法(mark and sweep)"></a>标记清除算法(mark and sweep)</h2><h3 id="主要包含两个步骤"><a href="#主要包含两个步骤" class="headerlink" title="主要包含两个步骤:"></a>主要包含两个步骤:</h3><p>1.找出不可达对象,然后做上标记<br>2.回收标记好的对象</p>
<blockquote>
<p>mark and sweep 算法在执行的时候,需要程序暂停,即stop the world</p>
</blockquote>
<h3 id="标记清除算法存在的问题"><a href="#标记清除算法存在的问题" class="headerlink" title="标记清除算法存在的问题"></a>标记清除算法存在的问题</h3><ul>
<li>stop the world 程序暂停,即程序会出现卡顿</li>
<li>标记需要扫描整个堆(heap)</li>
<li>清楚数据会产生heap碎片</li>
</ul>
<h2 id="三色标记清除算法"><a href="#三色标记清除算法" class="headerlink" title="三色标记清除算法"></a>三色标记清除算法</h2><p>三色标记清除算法背后的首要原则就是它把堆中的对象根据它们的颜色分到不同集合里面，颜色是根据算法进行标记的  </p>
<ul>
<li>黑色集合 指针指向白色集合。</li>
<li>白色集合中的对象允许有指针指向黑色集合,白色集合中的对象就是垃圾回收的候选对象。</li>
<li>灰色集合可能会有指针指向白色集合里的对象。</li>
</ul>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>每次堆中的指针被修改写屏障都会去执行。如果堆中对象的指针被修改，就意味着那个对象现在是可触达的，写屏障会把它标记为灰色并把它放到灰色集合中。<br>修改器 运行写屏障,从而保证黑色集合中没有任何元素的指针去指向白色集合中的元素。<br>写屏障直观作用有两个:<br>1.process新生成的内存对象会被直接标记成灰色<br>2.位于黑色集合中的内存对象引用了一个白色集合中的对象,写屏障会将白色集合的这个对象标记为灰色  </p>
<h3 id="三色标记过程"><a href="#三色标记过程" class="headerlink" title="三色标记过程"></a>三色标记过程</h3><p>1.首先：程序创建的对象都标记为白色。<br><img src="/2020/06/16/go/Mastering_Go/6328562-1021941531ecffc3.png" alt><br>2.gc开始：扫描所有可到达的对象，标记为灰色<br><img src="/2020/06/16/go/Mastering_Go/6328562-9ae46a88a13613ee.png" alt><br>3.从灰色对象中找到其引用对象标记为灰色，把灰色对象本身标记为黑色<br><img src="/2020/06/16/go/Mastering_Go/6328562-21bc289a81b75236.png" alt><br>4.监视对象中的内存修改，并持续上一步的操作，直到灰色标记的对象不存在<br><img src="/2020/06/16/go/Mastering_Go/6328562-e0535bd79c7996e8.png" alt><br>5.此时，gc回收白色对象。<br><img src="/2020/06/16/go/Mastering_Go/6328562-6c9ecb92555f14e2.png" alt><br>6.最后，将所有黑色对象变为白色，并重复以上所有过程。<br><img src="/2020/06/16/go/Mastering_Go/6328562-0c915b27be3f258d.png" alt></p>
<h3 id="gc和用户逻辑如何并行操作"><a href="#gc和用户逻辑如何并行操作" class="headerlink" title="gc和用户逻辑如何并行操作"></a>gc和用户逻辑如何并行操作</h3><p>标记-清除(mark and sweep)算法的STW(stop the world)操作，就是runtime把所有的线程全部冻结掉，所有的线程全部冻结意味着用户逻辑是暂停的。这样所有的对象都不会被修改了，这时候去扫描是绝对安全的。<br>Go如何减短这个过程呢？标记-清除(mark and sweep)算法包含两部分逻辑：标记和清除。<br>我们知道Golang三色标记法中最后只剩下的黑白两种对象，黑色对象是程序恢复后接着使用的对象，如果不碰触黑色对象，只清除白色的对象，肯定不会影响程序逻辑。所以：清除操作和用户逻辑可以并发。<br>标记操作和用户逻辑也是并发的，用户逻辑会时常生成对象或者改变对象的引用，那么标记和用户逻辑如何并发呢？<br><strong>process新生成对象的时候，GC该如何操作呢？不会乱吗？</strong><br>我们看如下图，在此状态下：process程序又新生成了一个对象，我们设想会变成这样：<br><img src="/2020/06/16/go/Mastering_Go/6328562-1306d93ef2c96426.png" alt><br>但是这样显然是不对的，因为按照三色标记法的步骤，这样新生成的对象A最后会被清除掉，这样会影响程序逻辑。<br>Golang为了解决这个问题，引入了写屏障这个机制。<br>写屏障：该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知。<br>通俗的讲：就是在gc跑的过程中，可以监控对象的内存修改，并对对象进行重新标记。(实际上也是超短暂的stw，然后对对象进行标记)<br>在上述情况中，新生成的对象，一律都标位灰色！<br><img src="/2020/06/16/go/Mastering_Go/6328562-75599afe8b517f5c.png" alt><br><strong>那么，灰色或者黑色对象的引用改为白色对象的时候，Golang是该如何操作的？</strong><br>看如下图，一个黑色对象引用了曾经标记的白色对象。<br><img src="/2020/06/16/go/Mastering_Go/6328562-57b2f544aa5ff318.png" alt><br>这时候，写屏障机制被触发，向GC发送信号，GC重新扫描对象并标位灰色。<br><img src="/2020/06/16/go/Mastering_Go/6328562-714367c5511b3cf4.png" alt><br>因此，gc一旦开始，无论是创建对象还是对象的引用改变，都会先变为灰色。</p>
<h3 id="Unsafe-Code"><a href="#Unsafe-Code" class="headerlink" title="Unsafe Code"></a>Unsafe Code</h3><p>Unsafe code是一种绕过go类型安全和内存安全检查的Go代码。</p>
<h3 id="defer-panic-recover"><a href="#defer-panic-recover" class="headerlink" title="defer panic recover"></a>defer panic recover</h3><ul>
<li>defer是一种栈结构,先入后出</li>
<li>panic 会终止Go程序的当前流程开始panicking,根据入栈顺序调用defer,若某个defer中,有recover,则捕获panic,程序回到正常执行流程</li>
<li>recover,在defer函数中直接调用recover才能捕获panic</li>
</ul>
<h1 id="Go基本数据类型"><a href="#Go基本数据类型" class="headerlink" title="Go基本数据类型"></a>Go基本数据类型</h1><h2 id="Go切片"><a href="#Go切片" class="headerlink" title="Go切片"></a>Go切片</h2><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片的底层是数组，这意味着Go为每一个切片创建一个底层数组<br>切片作为函数的形参时是传引用操作，传递的是指向切片的内存地址，这意味着在函数中对切片的任何操作都会在函数结束后体现出来。另外，函数中传递切片要比传递同样元素数量的数组高效，因为Go只是传递指向切片的内存地址，而非拷贝整个切片。  </p>
<h3 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h3><p>GoLang中的切片扩容机制，与切片的数据类型、原本切片的容量、所需要的容量都有关系，比较复杂。对于常见数据类型，在元素数量较少时，大致可以认为扩容是按照翻倍进行的。</p>
<h3 id="大切片问题"><a href="#大切片问题" class="headerlink" title="大切片问题"></a>大切片问题</h3><p>若果存在一个很大的切片,而只需要使用很少的一部分,应当将此部分拷贝出来,否则因为这一小部分,会导致改切片不能被GC回收,典型问题将大文件的内容读到切片中，但是你只是想使用其中一小部分。  </p>
<h3 id="字节切片"><a href="#字节切片" class="headerlink" title="字节切片"></a>字节切片</h3><p>字节切片的操作与其他类型的切片并没有什么区别，但是在输入输出中（网络，文件流等）使用的非常多  </p>
<h3 id="copy-函数"><a href="#copy-函数" class="headerlink" title="copy()函数"></a>copy()函数</h3><p>内建函数copy(dst,src) 会以cap(dst)和cap(src)中的最小值为复制长度。<br>如果目标dst没有容量,则拷贝不到任何内容<br>最新的go版本中(go1.13),copy 已经支持了数组和切片的相互拷贝</p>
<h3 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h3><p>如果你发现你的代码中出现很多多维切片，你就要考虑你的代码设计是否合理并且使用不需要多维切片的更简单的设计。</p>
<h2 id="Go-map"><a href="#Go-map" class="headerlink" title="Go map"></a>Go map</h2><p>与切片与数组相比，map（映射）的功能要强大的多，但是具有灵活性的同时也伴随着性能损耗，实现Go map往往需要更多的处理能力。但是不用担心，Go的内置数据结构是非常高效的，所以当你需要map的时候就尽情地去用吧！</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>const 定义的常量,特别是数字类型,在定义的时候没有明确类型的化,那么该常量的类型在真正被使用的时候才会确定<br>严格来说,常量在编译期间就被确定了,所以定义成常量的值必须是编译器能够确定的值,在程序运行期间,不能修改的值<br>Go可以使用布尔类型、字符串、或者数字类型存储常量的值。<br>代码建议：如果你要用到许多常量，最好将它们定义到同一个包中。  </p>
<h2 id="go指针"><a href="#go指针" class="headerlink" title="go指针"></a>go指针</h2><p>使用指针时，<em>可以获取指针的值，此操作成为指针的解引用，</em>也叫取值操作符；&amp;可以获取非指针变量的地址，叫做取地址操作符。<br>变量=变量内存地址+变量值,以下代码可以很好的体现这个关系:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    var a int</span><br><span class="line">    var b *int</span><br><span class="line"></span><br><span class="line">    a&#x3D;5</span><br><span class="line">    b&#x3D;&amp;a</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;a变量指针:&quot;,&amp;a)</span><br><span class="line">    fmt.Println(&quot;a变量值:&quot;,a)</span><br><span class="line">    fmt.Println(&quot;b变量指针:&quot;,&amp;b)</span><br><span class="line">    fmt.Println(&quot;b变量值:&quot;,b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">a变量指针: 0xc000088010</span><br><span class="line">a变量值: 5</span><br><span class="line">b变量指针: 0xc00008c018</span><br><span class="line">b变量值: 0xc000088010</span><br></pre></td></tr></table></figure>

<h2 id="时间与日期的处理技巧"><a href="#时间与日期的处理技巧" class="headerlink" title="时间与日期的处理技巧"></a>时间与日期的处理技巧</h2><h3 id="解析时间"><a href="#解析时间" class="headerlink" title="解析时间"></a>解析时间</h3><p>time.Parse(layout string,value string)此函数用于字符串解析成golang时间类型,如果时间错误,将不能被解析 </p>
<h1 id="组合类型的使用"><a href="#组合类型的使用" class="headerlink" title="组合类型的使用"></a>组合类型的使用</h1><h2 id="使用new关键字"><a href="#使用new关键字" class="headerlink" title="使用new关键字"></a>使用new关键字</h2><p>new和make最大的区别就是：new返回的是空的内存地址，即没有做初始化。另外，make仅可以用来创建映射，切片和通道，而且并不是返回指针。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://phpdi.github.io/2020/06/11/http/Http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_20200115_173549.jpg">
      <meta itemprop="name" content="Chen Yu">
      <meta itemprop="description" content="自律给我自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="phpdi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/11/http/Http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">http/Http权威指南</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-11 10:22:07" itemprop="dateCreated datePublished" datetime="2020-06-11T10:22:07+08:00">2020-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-16 13:35:42" itemprop="dateModified" datetime="2020-06-16T13:35:42+08:00">2020-06-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第1章-HTTP概述"><a href="#第1章-HTTP概述" class="headerlink" title="第1章 HTTP概述"></a>第1章 HTTP概述</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><h3 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h3><ul>
<li>MIME(Multipurpose Internet Mail Extension,多用途英特网邮件扩展)</li>
<li>Web服务器回味所有的HTTP对象数据附加一个MIME类型，以告知Web浏览器该如何处理该对象</li>
<li>Content-Type:image/jpeg ,“image/jpeg”为MIME类型</li>
</ul>
<h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><ul>
<li>URI(Uniform Resource Identifier,统一资源标识符)</li>
<li>URI 有两种形式，分别称为URL和URN</li>
</ul>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><ul>
<li>统一资源定位符</li>
<li>URL包含三个部分,协议类型,服务器地址,资源地址</li>
<li>现在,几乎所有的URI都是URL</li>
<li>URL语法 : <scheme>://<user>:<password>@<host>:<port>/<path></path>;<params>?<query>#<frag></frag></query></params></port></host></password></user></scheme></li>
</ul>
<h3 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h3><ul>
<li>URN 统一资源名</li>
<li>URN是作为特定内容的唯一名称使用的,与目前资源所在地无关</li>
<li>P2P下载中使用的磁力链接是URN的一种实现，它可以持久化的标识一个BT资源，资源分布式的存储在P2P网络中，无需中心服务器用户即可找到并下载它。</li>
</ul>
<h2 id="Web的结构组件"><a href="#Web的结构组件" class="headerlink" title="Web的结构组件"></a>Web的结构组件</h2><ul>
<li>代理 位于客户端和服务端之间的HTTP中间实体</li>
<li>缓存 HTTP的仓库,使常用的页面或资源保存在离客户端更近的地方</li>
<li>网关 连接其他应用程序的特殊问web服务器</li>
<li>隧道 对HTTP通信报文进行盲转发的特殊代理</li>
<li>Agent代理 发起自动HTTP请求的半智能Web客户端</li>
</ul>
<h1 id="第3章-HTTP报文"><a href="#第3章-HTTP报文" class="headerlink" title="第3章 HTTP报文"></a>第3章 HTTP报文</h1><h2 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h2><ul>
<li>起始行(start line)</li>
<li>首部(header)</li>
<li>主体(body)</li>
</ul>
<h1 id="第4章-连接管理"><a href="#第4章-连接管理" class="headerlink" title="第4章 连接管理"></a>第4章 连接管理</h1><h2 id="用TCP套接字编程"><a href="#用TCP套接字编程" class="headerlink" title="用TCP套接字编程"></a>用TCP套接字编程</h2><ul>
<li>网络套接字 操作系统提供的操作TCP连接的工具</li>
</ul>
<h3 id="服务端套接字编程流程"><a href="#服务端套接字编程流程" class="headerlink" title="服务端套接字编程流程"></a>服务端套接字编程流程</h3><ol>
<li>创建套接字</li>
<li>绑定端口</li>
<li>监听端口</li>
<li>接收并处理消息</li>
</ol>
<h3 id="客户端套接字编程流程"><a href="#客户端套接字编程流程" class="headerlink" title="客户端套接字编程流程"></a>客户端套接字编程流程</h3><ol>
<li>创建套接字</li>
<li>连接服务端套接字</li>
<li>发送消息</li>
</ol>
<h2 id="性能聚焦区域"><a href="#性能聚焦区域" class="headerlink" title="性能聚焦区域"></a>性能聚焦区域</h2><p>###　TCP相关时延</p>
<ul>
<li>TCP连接建立握手</li>
<li>TCP慢启动拥塞控制</li>
<li>数据聚集的Nagle算法</li>
<li>用于捎带确认的TCP延迟确认算法</li>
<li>TIME_WAIT时延和端口耗尽</li>
</ul>
<h2 id="提高HTTP连接性能的方法"><a href="#提高HTTP连接性能的方法" class="headerlink" title="提高HTTP连接性能的方法"></a>提高HTTP连接性能的方法</h2><p>串行事务处理时延</p>
<ul>
<li>并行连接 通过多条TCP连接发起并发的HTTP请求</li>
<li>持久连接 重用TCP连接,以消除连接及关闭时延</li>
<li>管道化连接 通过共享TCP连接发起并发的HTTP请求</li>
<li>复用连接 交替传送请求和响应报文</li>
</ul>
<h3 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h3><p>打开大量连接会消耗很多内存资源<br>浏览器确实使用了并行连接,但他们会将并行连接的总数限制为一个较小的值(通常是4个). 服务器可以随意关闭来自特定客户端的超量连接</p>
<h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>在HTTP事务处理结束后仍然保持在打开状态的TCP连接被称为持久连接;持久连接会在不同事务之间保持打开状态,直到客户端或服务器决定将其关闭为止</p>
<h3 id="不能被代理转发或缓存响应使用的首部"><a href="#不能被代理转发或缓存响应使用的首部" class="headerlink" title="不能被代理转发或缓存响应使用的首部"></a>不能被代理转发或缓存响应使用的首部</h3><ul>
<li>Connection</li>
<li>Proxy-Authenticate</li>
<li>Proxy-Connection</li>
<li>Transfer-Encoding</li>
<li>Upgrade</li>
</ul>
<h2 id="持久连接-1"><a href="#持久连接-1" class="headerlink" title="持久连接"></a>持久连接</h2><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><p>HTTP/1.0 通过Connection:keep-alive 头部发送持久连接信号 ,服务端响应Connection:keep-alive表示支持持久连接,但是会存在一个盲中继问题<br>盲中继(哑代理)会导致,客户端保持TCP连接,服务端保持TCP连接,他们的TCP连接都是连接在代理上的,代理却什么都不知道</p>
<blockquote>
<p>只是将一个连接转发到另一个连接去,不对Connection首部进行特殊处理</p>
</blockquote>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p>HTTP/1.1使用persistent connection持久连接,改进了HTTP/1.0 中Connection:keep-alive的缺陷,HTTP/1.1中持久连接是默认激活的,要关闭则需要在报文首部显示添加Connection:close关闭持久连接</p>
<h3 id="持久连接的限制"><a href="#持久连接的限制" class="headerlink" title="持久连接的限制"></a>持久连接的限制</h3><ul>
<li>只有当连接上的所有报文都是正确的,自定义报文长度时,也就是说实体部分的长度和相应的Content-length一致,或则是用分块传输编码方式编码的,连接才能持久保持</li>
<li>HTTP/1.1的代理必须能够分别管理与客户端和服务端的持久连接,每个连接都只适用于一跳传输</li>
<li>一个用户客户端对任何服务器或代理最多维持两条持久连接,以防止服务器过载.</li>
</ul>
<h1 id="第5章-Web服务器"><a href="#第5章-Web服务器" class="headerlink" title="第5章 Web服务器"></a>第5章 Web服务器</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://phpdi.github.io/2020/06/04/linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80+%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_20200115_173549.jpg">
      <meta itemprop="name" content="Chen Yu">
      <meta itemprop="description" content="自律给我自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="phpdi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/04/linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80+%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">linux/计算机原理+操作系统基础+计算机网络面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-04 13:49:15" itemprop="dateCreated datePublished" datetime="2020-06-04T13:49:15+08:00">2020-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 10:13:35" itemprop="dateModified" datetime="2020-06-09T10:13:35+08:00">2020-06-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第二章-计算机主城原理之概述篇"><a href="#第二章-计算机主城原理之概述篇" class="headerlink" title="第二章 计算机主城原理之概述篇"></a>第二章 计算机主城原理之概述篇</h1><ul>
<li>计算机的发展历史大概可以分为几个阶段？每个阶段的计算机分别有什么特点？  <blockquote>
<p>四个阶段：电子管计算机、晶体管计算机、集成电路计算机、超大规模集成电路计算机。  </p>
</blockquote>
</li>
<li>你了解“摩尔定律”吗？“摩尔定律”对现代计算机产生了什么影响？<blockquote>
<p>摩尔定律：摩尔定律是由英特尔（Intel）创始人之一戈登·摩尔（Gordon Moore）提出来的。其内容为：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭示了信息技术进步的速度。尽管这种趋势已经持续了超过半个世纪，摩尔定律仍应该被认为是观测或推测，而不是一个物理或自然法。</p>
</blockquote>
</li>
<li>你了解冯诺依曼机吗？你是否可以大概描述冯诺依曼机的基本组成和工作原理？冯诺依曼机相对于之前的计算机有什么重要改进？<blockquote>
<p>冯诺依曼机有五大组成部分：输入设备、输出设备、运算器、存储器、控制器。冯诺依曼机把程序指令和运行数据存储起来，使得计算机从专用电路计算机发展成为通用电路计算机。</p>
</blockquote>
</li>
<li>什么是冯诺依曼瓶颈？冯诺依曼瓶颈对现代计算机产生了什么影响？<blockquote>
<p>冯诺依曼瓶颈指的是存储器和运算器之间的访问速率差异巨大，使得计算机性能无法提升。现代计算机以存储器为核心，根据局部性原理设计了存储器的层次结构，大幅提升计算机性能。</p>
</blockquote>
</li>
<li>你了解程序解释和程序翻译吗？什么是编译型语言，什么是解释型语言呢？<blockquote>
<p>编程语言可以分为解释型语言和编译型语言，程序解释指的是程序代码在运行时，逐行翻译成较低层次的编程语言去执行；程序翻译指的是程序代码在编译阶段提前翻译成较低层次的编程语言逻辑，在运行时直接运行。</p>
</blockquote>
</li>
<li>请你列举十种以上的编程语言，并分别分类他们属于什么类型的语言。<blockquote>
<p>译型语言：C、C++、Go、OC，解释型语言：Php、Python、Javascript、Perl、Lua，翻译+解释型语言：Java、C#、Kotlin等。</p>
</blockquote>
</li>
<li>你了解计算机的层次结构吗？今天的软件和硬件是怎么界定的。<blockquote>
<p>计算机的层次结构划分是为了方便理解计算机的整一个体系，在不同书籍或领域会有不一样的划分，没有绝对的正确。今天的软件、硬件的划分以硬件电路为界限，从涉及硬件电路逻辑往下的都归为硬件，要注意软件和硬件的划分也是与时俱进的，今天的软件很可能明天就变成了硬件，比如以前编写硬件逻辑代码是软件，而随着高级编程语言的出现和成熟，现在编写硬件逻辑代码已经视为硬件部分了。</p>
</blockquote>
</li>
<li>请你尝试说明高级语言、汇编语言和机器语言的区别和联系？<blockquote>
<p>高级语言是方便程序员描述程序逻辑的编程语言，与人类语言接近；汇编语言时方便程序员描述硬件逻辑的编程语言，与底层硬件接近；机器语言时方便计算机理解和运行的编程语言，一般程序员无法理解。</p>
</blockquote>
</li>
<li>CPU的速度一般使用什么做单位？它具有什么物理意义？<blockquote>
<p>赫兹，是国际单位制中频率的单位，它是每秒中的周期性变动重复次数的计量。1Hz = 1/s，即在单位时间内完成振动的次数，单位为赫兹（1赫兹=1次/秒）。</p>
</blockquote>
</li>
<li>网络的速度一般使用什么做单位？<blockquote>
<p>bps，比特率是指每秒传送的比特(bit)数。单位为 bps(Bit Per Second)，比特率越高，每秒传送数据就越多。</p>
</blockquote>
</li>
<li>20世纪80年代以前的计算机是不支持输入中文的，当时的计算机使用的是什么编码集？<blockquote>
<p>ASCII编码集。</p>
</blockquote>
</li>
<li>ASCII编码集占用多少个字节？<blockquote>
<p>ASCII有128个字符，占用7个比特位，扩展ASCII编码机占用8个比特位，一个字节。</p>
</blockquote>
</li>
<li>‘A’, ‘b’, ‘C’对应的ASCII十进制数值分别是多少？<blockquote>
<p>65、98、67。</p>
</blockquote>
</li>
<li>可以使用你熟悉的语言将 72、96、108转换为ASCII码吗？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var c rune&#x3D;&#39;a&#39; </span><br><span class="line">var i int &#x3D;98</span><br><span class="line">i1:&#x3D;int(c)</span><br><span class="line">fmt.Println(&quot;&#39;a&#39; convert to&quot;,i1)</span><br><span class="line">c1:&#x3D;rune(i)</span><br><span class="line">fmt.Println(&quot;98 convert to&quot;,string(c1))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;string to rune</span><br><span class="line">for _, char :&#x3D; range []rune(&quot;世界你好&quot;) &#123;</span><br><span class="line">    fmt.Println(string(char))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>你知道Unicode编码和UTF-8编码的区别和联系吗？<blockquote>
<p>Unicode全名为：统一码、万国码，是计算机科学领域里的一项业界标准。Unicode标准有不同的编码实现，比如UTF-8、UTF-16、UTF-32，也即是可以有多种规则来实现Unicode标准，比如UTF-8使用的是不定长字节表示Unicode字符，在表示高位Unicode字符时可以自动扩展，UTF-32使用的是定长4个字节表示Unicode字符。</p>
</blockquote>
</li>
<li>假设有10000个汉字，6000个日本字，3000个韩国字，1000个特殊字符，如果让你设计一套通用的编码集，请问每个字至少几个比特位？<blockquote>
<p>10000+6000+3000+1000=20000个字符，最起码使用15个比特位，占2个字节。</p>
</blockquote>
</li>
</ul>
<h1 id="第3章-计算机组成原理之组成篇"><a href="#第3章-计算机组成原理之组成篇" class="headerlink" title="第3章 计算机组成原理之组成篇"></a>第3章 计算机组成原理之组成篇</h1><ul>
<li>计算机的总线就像是计算机的“高速公路”，你是否可以说出总线主要的功能和分类？<blockquote>
<p>总线可以分为：片内总线、系统总线，其中系统总线可以分为数据总线、地址总线、控制总线。</p>
</blockquote>
</li>
<li>什么是总线标准，为什么需要总线标准，现在有哪些常见的总线标准？<blockquote>
<p>总线标准是系统与各模块、模块与模块之间的一个互连的标准界面。总线标准有利于各模块高效使用总线。USB、PCIe等。</p>
</blockquote>
</li>
<li>常说的“IO设备”，“I”、“O”分别是什么的缩写？<blockquote>
<p>Input、Output，输入设备、输出设备。</p>
</blockquote>
</li>
<li>常见的输入设备可以分为什么种类？<blockquote>
<p>字符输入设备（键盘等）、图像输入设备（鼠标、数位板、扫描仪）。</p>
</blockquote>
</li>
<li>常见的输出设备可以分为什么种类？<blockquote>
<p>主要是图像输出设备（显示器），但在计算机远未普及的时候，显示器属于字符输出设备。</p>
</blockquote>
</li>
<li>日常常见的计算机外设（显示器、键盘、鼠标、打印机），分别属于什么设备？<blockquote>
<p>显示器、打印机属于输出设备，键盘、鼠标属于输入设备。</p>
</blockquote>
</li>
<li>输入输出接口一般需要完成什么工作，可以把接口的线路分为什么线路？<blockquote>
<p>数据线、状态线、命令线、地址线。</p>
</blockquote>
</li>
<li>DMA的全称是什么？<blockquote>
<p>DMA：Direct Memory Access，直接内存存取。</p>
</blockquote>
</li>
<li>程序中断和DMA相比，有什么优劣？<blockquote>
<p>程序中断和DMA都是计算机IO和低速设备的交互方式，程序中断方式实现简单，DMA方式效率更高。</p>
</blockquote>
</li>
<li>你是否可以清晰的表述计算机存储器的层次结构？存储器的层次结构是为了解决什么问题的？<blockquote>
<p>存储器的层次结构可以简单划分为：缓存-主存-辅存三个层次，缓存-主存主要是为了解决主存速度不够的问题；主存-辅存主要是为了解决主存容量不足的问题。</p>
</blockquote>
</li>
<li>什么是局部性原理，局部性原理对计算机存储系统的设计产生了什么影响？<blockquote>
<p>局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。</p>
</blockquote>
</li>
<li>计算机存储系统的每一个层次分别有什么特点？<blockquote>
<p>缓存：速度快、位价高；主存：速度适中、位价适中；辅存：速度慢、位价低。</p>
</blockquote>
</li>
<li>计算机的辅助存储器一般是指计算机硬盘，你了解计算机磁盘的物理结构吗？<blockquote>
</blockquote>
</li>
<li>磁盘的调度算法有哪些？分别有什么特点？<blockquote>
<p>先来先服务算法、最短寻道时间优先算法、扫描算法、循环扫描算法。</p>
</blockquote>
</li>
<li>计算机的主存一般是指计算机内存，内存有什么特点？<blockquote>
<p>容量比缓存大、比辅存小，访问速度比缓存慢，比辅存快，主存需要持续通电使用，停电时主存数据将会丢失。</p>
</blockquote>
</li>
<li>请解释概念：主存、辅存、Cache、RAM、ROM？<blockquote>
<p>主存：主存储器，即常说的计算机内存条，辅存：辅助存储器，即常说的磁盘、U盘、光盘、磁带等，Cache：高速缓存，即常说的L1、L2、L3缓存，CPU寄存器等，RAM：随机存取存储器（英语：Random Access Memory，缩写：RAM），ROM：只读存储器（Read Only Memory，缩写：ROM）。</p>
</blockquote>
</li>
<li>什么是字？什么是字块？<blockquote>
<p>字是指存放在一个存储单元中的二进制代码组合；字块是指存储在连续的存储单元中而被看作是一个单元的一组字。</p>
</blockquote>
</li>
<li>计算机的高速缓存一般是指Cache，Cache一般位于计算机的什么硬件设备上？<blockquote>
<p>在CPU上。</p>
</blockquote>
</li>
<li>一般使用什么指标去评估主存-高速缓存的性能？<blockquote>
<p>命中率。</p>
</blockquote>
</li>
<li>命中率是怎么定义的？<br><img src="/2020/06/04/linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80+%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/5e3975ac093e3e8608760255.png" alt></li>
<li>访问效率是怎么定义的？<br><img src="/2020/06/04/linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80+%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/5e3975b70947591b13630515.png" alt></li>
<li>假设CPU执行某段程序共计访问Cache命中4800次，访问主存200次，已知Cache的存取周期是30ns，主存的存取周期是150ns，求Cache-主存系统的平均访问时间和效率，试问该系统的性能提高了多少？<blockquote>
<p>平均访问时间：(480030+150200)/5000=34.8ns，命中率：4800/5000100%=96%，访问效率e：30/34.8100%=86.2%，性能提升：(150-34.8)/150*100%=76.8%。</p>
</blockquote>
</li>
<li>请描述LFU、LRU、FIFO缓存置换算法的过程。<blockquote>
</blockquote>
</li>
<li>计算机的指令一般由操作码和地址码组成，那么计算机指令可以分类为几种类型？<blockquote>
<p>移位操作指令、数据传输指令、控制指令、算术逻辑操作指令。</p>
</blockquote>
</li>
<li>对计算机指令数据的寻址有哪几种方式？<blockquote>
<p>立即寻址、直接寻址、间接寻址。</p>
</blockquote>
</li>
<li>计算机的运算器主要由什么组成？控制器呢？<blockquote>
<p>控制器主要由：程序计数器、时序发生器、指令译码器、寄存器、总线组成。运算器主要由：数据缓冲器、ALU、寄存器、状态字寄存器、总线组成。</p>
</blockquote>
</li>
<li>请简述计算机指令的执行过程。<blockquote>
</blockquote>
</li>
</ul>
<h1 id="第4章-计算机组成原理之计算篇"><a href="#第4章-计算机组成原理之计算篇" class="headerlink" title="第4章 计算机组成原理之计算篇"></a>第4章 计算机组成原理之计算篇</h1><ul>
<li>除了十进制以外，这个世界上常见的还有什么进制？<blockquote>
<p>二进制、八进制、十二进制、二十进制、六十进制。</p>
</blockquote>
</li>
<li>二进制一般使用什么方法转换成十进制？<blockquote>
<p>整数：按权展开法。</p>
</blockquote>
</li>
<li>十进制一般使用什么方法转换成二进制？<blockquote>
<p>整数：重复相除法，小数：重复相乘法。</p>
</blockquote>
</li>
<li>计算机直接使用原码计算有什么缺点？<blockquote>
<p>0有两种表示方法，减法运算复杂。</p>
</blockquote>
</li>
<li>请计算12、124、1023、-1、-127的二进制原码。<blockquote>
<p>12(0b1100)、124(0b1111100)、1023(0b1111111111)、-1(-0b1)、-127(-0b1111111)</p>
</blockquote>
</li>
<li>计算机的补码解决了什么问题？<blockquote>
<p>相比原码的运算过程（特别是减法），补码对于计算机而言运算更加简单。</p>
</blockquote>
</li>
<li>请计算12、124、1023、-1、-127的补码，并将其使用32位定点表示法和32位浮点表示法(1位符号位、8位阶码、23位数值位)表示出来。<blockquote>
</blockquote>
</li>
<li>你是否可以使用代码实现一个通用的计算器，可以将二进制数转换为十进制数，把十进制数转换为二进制数。<blockquote>
</blockquote>
</li>
<li>计算机为了判断运算溢出使用了什么方法？<blockquote>
</blockquote>
</li>
<li>什么是溢出？什么是上溢？什么是下溢？<blockquote>
<p>双符号位判断法。当双符号位不一致表示溢出。</p>
</blockquote>
</li>
<li>对于64位浮点型(double)，一般都是采用最高位为符号位，次高11位为指数位，其次52位为尾数，试求出double型所能表达的最大值和最小值。<blockquote>
<p>溢出即计算机无法表示数值。上溢是指数值绝对值大于表示范围，下溢是指计算机无法提供有效精度表示数值。</p>
</blockquote>
</li>
<li>浮点数相比定点数，有什么优势？有什么不足的地方。<blockquote>
<p>浮点数可以表示更大的数据范围，但是运算耗时更长。</p>
</blockquote>
</li>
<li>浮点数之间做加减法运算需要几个步骤？每个步骤都是必须的吗？为什么？<blockquote>
<p>浮点数加减法需要经过以下几个步骤：对阶、尾数求和、尾数规格化、舍入、溢出判断。对阶是为了使得尾数可以进行运算，阶码不一致尾数运算无效，尾数规格化、舍入是为了正确存储结果，溢出判断是为了判断运算过程是否有误，如果溢出将会发出信号进行溢出处理。</p>
</blockquote>
</li>
<li>x=0.1101^1001, y=0.1011^110，请计算x+y的值，x-y的值。<blockquote>
<p>x+y=0.1110011^1001，x-y=0.1011101^1001。</p>
</blockquote>
</li>
<li>x=0.1101^111, y=-0.1111^1101，请计算x+y的值，x-y的值。<blockquote>
<p>x+y=-0.1110110011^1101，x-y=0.1111001101^1101。</p>
</blockquote>
</li>
</ul>
<h1 id="第6章-操作系统之基础篇"><a href="#第6章-操作系统之基础篇" class="headerlink" title="第6章 操作系统之基础篇"></a>第6章 操作系统之基础篇</h1><ul>
<li>最早的计算机是没有操作系统的，操作系统的诞生解决了什么问题？<blockquote>
<p>操作系统的出现解决了计算机操作难度大、计算机资源利用效率低等问题。</p>
</blockquote>
</li>
<li>什么是批处理操作系统，它有什么特点？<blockquote>
<p>批处理操作系统的特点是批量输入任务，有效提升计算机资源利用率。</p>
</blockquote>
</li>
<li>什么是分时操作系统，它有什么特点？<blockquote>
<p>分时操作系统是指分时复用计算机资源的操作系统，可以多个用户使用一台计算机，多个程序分时共享计算机资源。</p>
</blockquote>
</li>
<li>操作系统主要功能是什么？<blockquote>
<p>操作系统统一的管理着计算机资源；操作系统实现了对计算机资源的抽象；操作系统提供了用户与计算机之间操作的接口。</p>
</blockquote>
</li>
<li>操作系统实现了对计算机资源的抽象，这里面的计算机资源主要包括什么？<blockquote>
<p>存储资源 、网络资源、计算资源等。</p>
</blockquote>
</li>
<li>操作系统提供了用户与计算机之间的接口，使得用户可以通过操作系统操作计算机，这个接口主要有几种形式？<blockquote>
<p>系统调用、命令行、图形窗口、应用程序等。</p>
</blockquote>
</li>
<li>什么是并行？什么是并发？并行和并发有什么区别和联系？<blockquote>
<p>并行是指两个或多个事件可以在同一个时刻发生；并发是指两个或多个事件可以在同一个时间间隔发生。</p>
</blockquote>
</li>
<li>操作系统的共享性对用户来说表现为什么？<blockquote>
<p>操作系统的共享性表现为计算机资源可以同时提供给多个用户、多道程序使用。</p>
</blockquote>
</li>
<li>对于计算机资源的共享，有哪两种形式？<blockquote>
<p>互斥共享、同时共享。</p>
</blockquote>
</li>
<li>什么是操作系统的虚拟性？<blockquote>
<p>操作系统的虚拟性是指操作系统可以把计算机的物理实体转变为若干个逻辑实体以提供多个用户、多道程序使用。</p>
</blockquote>
</li>
<li>什么是操作系统的异步性？它对我们的编程有什么实际意义？<blockquote>
<p>操作系统的异步性是指是指进程以不可预知的速度向前推进。内存中的每个进程何时执行,何时暂停,以怎样的速度向前推进,每道程序总共需要多少时间才能完成等，都是不可预知的。</p>
</blockquote>
</li>
<li>什么是操作系统的进程，操作系统的进程解决了什么问题？<blockquote>
<p>进程是操作系统进行计算机资源分配和调度的基本单位。有了进程，用户的逻辑程序才能够在操作系统中独立、正常的执行；并使得计算机资源可以高效利用。</p>
</blockquote>
</li>
<li>进程在计算机中是以什么形式存在的？<blockquote>
<p>进程在计算机中表现为一片存储空间，包含进程状态、进程优先级、程序计数器、内存指针、上下文数据、IO状态信息等一系列数据。</p>
</blockquote>
</li>
<li>PCB的全称是什么？它有什么作用？<blockquote>
<p>PCB的全称是进程控制快(Process Control Block)，PCB是系统中存放进程的管理和控制信息的数据结构，有了PCB，操作系统才可以控制进程的运行。</p>
</blockquote>
</li>
<li>什么是线程，线程与进程的关系和区别？<blockquote>
<p>线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
</blockquote>
</li>
<li>进程的五状态主要是哪五状态？你了解进程的生命周期吗？<blockquote>
<p>创建状态、就绪状态、阻塞状态、执行状态、终止状态。</p>
</blockquote>
</li>
<li>什么是生产者-消费者问题，你能够编程实现吗？<blockquote>
</blockquote>
</li>
<li>什么是哲学家进餐问题，你能够编程实现吗？<blockquote>
</blockquote>
</li>
<li>进程间同步一般有哪些方法，线程间同步呢？<blockquote>
<p>进程间同步的方法有：信号量、共享内存、消息队列、Unix域套接字等，线程间同步的方法有：互斥量、自旋锁、读写锁、条件变量的等方法。</p>
</blockquote>
</li>
<li>对于Linux来说，什么是前台进程、什么是后台进程、什么是守护进程？<blockquote>
<p>前台进程是指正在运行并且占用终端的进程；后台进程是指不占用终端的进程；守护进程是指一类特殊的后台进程，随系统引导而启动。</p>
</blockquote>
</li>
<li>进程的调度算法可以分为两大类，抢占式调度和非抢占式调度，对于抢占式调度，主要有什么算法？<blockquote>
<p>先来先服务调度算法、短进程优先调度算法、高优先权优先调度算法、时间片轮转调度算法。</p>
</blockquote>
</li>
<li>死锁的危害重大，什么是死锁，死锁是怎么产生的？<blockquote>
<p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。</p>
</blockquote>
</li>
<li>为了避免死锁，操作系统使用了什么算法？你了解这个算法的过程吗？<blockquote>
<p>银行家算法。</p>
</blockquote>
</li>
<li>什么是段？什么是页？什么是段页式存储管理？<blockquote>
<p>段是指连续不等长的一片内存，页是指连续等长的一片内存，段页式存储管理是将用户程序分成若干个段，再把每个段分成若干个页的内存管理方式。</p>
</blockquote>
</li>
<li>虚拟内存是什么？从根本上来说，虚拟内存解决了什么问题？<blockquote>
<p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>
</blockquote>
</li>
<li>虚拟内存有哪些的置换算法？<blockquote>
<p>FIFO算法、LRU算法、LFU算法</p>
</blockquote>
</li>
<li>请简述Buddy算法分配内存和回收内存的过程？<blockquote>
</blockquote>
</li>
<li>在Buddy算法里面，什么是Buddy（伙伴）？<blockquote>
<p>Buddy指的是两片内存连续、大小一样的内存片段。</p>
</blockquote>
</li>
<li>在计算机里面，文件可以分为有结构文件和无结构文件，你可以列举常见的有结构文件和无结构文件吗？<blockquote>
<p>有结构文件比如：Excel文件、Word文件、PDF文件、JPG文件等；无结构文件比如：exe文件、so文件、dll文件等。</p>
</blockquote>
</li>
<li>当为文件分配辅存空间时，一般有什么分配方式？<blockquote>
<p>连续分配、链接分配、索引分配。</p>
</blockquote>
</li>
<li>FAT文件系统对应的是辅存的哪种空间分配方式？<blockquote>
<p>链接分配方式。</p>
</blockquote>
</li>
<li>ext文件系统对应的是辅存的哪种空间分配方式？<blockquote>
<p>索引分配方式。</p>
</blockquote>
</li>
<li>在辅存中，一般使用什么样的数据结构来管理存储空间？<blockquote>
<p>位示图。</p>
</blockquote>
</li>
<li>文件目录树有什么作用？<blockquote>
<p>文件目录树使得任何一个文件或文件夹都有唯一的路径。</p>
</blockquote>
</li>
<li>文件描述信息包含哪些数据？<blockquote>
<p>文件标识符、文件类型、文件权限、文件长度、文件状态、索引节点等信息。</p>
</blockquote>
</li>
<li>Linux文件有哪几种类型？<blockquote>
<p>套接字文件、普通文件、目录文件、符号链接文件、设备文件、FIFO文件。</p>
</blockquote>
</li>
<li>ext文件系统可以看做是由一个Boot Sector和若干个Block Group组成，你能简要的描述Block Group由什么组成吗？<blockquote>
<p>一个Block Group由Super Block、Inode Bitmap、Block Bitmap、Inode Table、Data Block组成。</p>
</blockquote>
</li>
<li>什么是文件的Inode，Inode存储了文件的什么信息？<blockquote>
<p>每个文件或者文件夹都有一个Inode，Inode可以理解为是文件或文件夹的“身份证”，Inode存储着文件索引节点编号、文件类型、文件权限、文件物理地址的关键信息</p>
</blockquote>
</li>
<li>什么是SPOOLing技术？计算机中常说的“脱机”是什么意思？<blockquote>
<p>SPOOLing技术是关于慢速字符设备如何与计算机主机交换信息的一种技术，它利用高速共享设备将低速的独享设备模拟为高速的共享设备，使得逻辑上系统为每一个用户都分配了一台独立的高速独享设备。</p>
</blockquote>
</li>
</ul>
<h1 id="第9章-计算机网络之概述篇"><a href="#第9章-计算机网络之概述篇" class="headerlink" title="第9章 计算机网络之概述篇"></a>第9章 计算机网络之概述篇</h1><ul>
<li>计算机网络的七层模型从顶往下分别是什么？请按顺序列举出来。<blockquote>
<p>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p>
</blockquote>
</li>
<li>现在开发者更喜欢使用TCP/IP四层模型来划分计算机网络，为什么TCP/IP四层模型会取代OSI七层模型被广泛使用？<blockquote>
</blockquote>
</li>
<li>ARP协议、RARP协议属于计算机网络的哪一个层次？<blockquote>
<p>数据链路层。</p>
</blockquote>
</li>
<li>IP协议、ICMP协议属于计算机网络的哪一个层次？<blockquote>
<p>网络层。</p>
</blockquote>
</li>
<li>传输层最重要的两个协议是什么？<blockquote>
<p>TCP协议、UDP协议。</p>
</blockquote>
</li>
<li>常见的应用层协议有HTTP协议、FTP协议等，你还能列举一些常见的应用层协议吗？<blockquote>
<p>HTTP、FTP、SMTP、DNS、POP3、Telnet、TFTP、DHCP等。</p>
</blockquote>
</li>
<li>路由器工作在计算机网络的哪几个层次？<blockquote>
<p>物理层、数据链路层、网络层。</p>
</blockquote>
</li>
<li>现代网络设备互联的两种模式分别是什么？他们有什么特点？<blockquote>
<p>客户-服务端模式、对等连接模式。客户-服务端模式由服务端提供网络服务，客户端使用服务，常常表现为一个服务端，多个客户端的连接模式。对等连接模式不分客户端和服务端，只要两个主机都运行了对等连接软件（P2P软件），它们就可以进行平等的、对等连接通信。</p>
</blockquote>
</li>
<li>时延是判断计算机网络质量的重要标准，网络时延由哪几个部分组成？<blockquote>
<p>网络时延可以划分成发送时延、传播时延、排队时延、处理时延几个部分。</p>
</blockquote>
</li>
<li>物理层主要的作用是什么？<blockquote>
<p>物理层主要的作用是连接不同的网络设备并在网络设备之间传输比特流。</p>
</blockquote>
</li>
<li>请列举物理层常见的传输介质。<blockquote>
<p>有线传输（铜线、光纤），无线传输。</p>
</blockquote>
</li>
<li>什么是信道，什么是单工信道、半双工信道、全双工信道？<blockquote>
<p>什么是信道，什么是单工信道、半双工信道、全双工信道？信道是往一个方向传送信息的媒体，单工信道指的是只能发送或者接收的信道，半双工信道指的是双方都能发送和接收信息但是不能同时发送或同时接收的信道，全双工信道指的是双方可以自由发送和接收信息的信道。</p>
</blockquote>
</li>
<li>数据链路层的三个重要功能分别是什么？<blockquote>
<p>封装成帧、透明传输、差错检测。</p>
</blockquote>
</li>
<li>物理层只负责比特流的传输，这些数据在数据链路层称为什么？<blockquote>
<p>数据帧。</p>
</blockquote>
</li>
<li>为了界定区分一个单独的数据帧，数据链路层通常会做什么操作？<blockquote>
<p>在数据的头部和尾部加入特殊比特位。</p>
</blockquote>
</li>
<li>假设有数据00100101需要传输，目标机器接收到的数据为10100100，请问使用奇偶校验码是否可以检测出错误？<blockquote>
<p>不能，因为奇偶校验位只能检测单个比特位出现的错误。</p>
</blockquote>
</li>
<li>假设有数据1101011011需要传输，采用CRC的生成多项式为P(X)=X^4+X+1，请计算添加了CRC校验码之后的数据。<blockquote>
<p>多项式位串为：10011，模二除法得到余数1110，所以得到结果11010110111110。</p>
</blockquote>
</li>
<li>什么是MAC地址？如何查看本机的MAC地址？MAC地址有什么作用？<blockquote>
<p>MAC地址也称为物理地址、硬件地址，通过在windows系统下输入命令ipconfig可以查看网络设备的MAC地址，MAC地址使用48个比特位标记一个物理设备。</p>
</blockquote>
</li>
<li>请简述以太网的工作过程。MAC地址在其中起到了什么作用？<blockquote>
<p>以太网协议通过MAC地址和硬件接口的映射关系了解到通过具体哪个接口把数据发送给下一跳。</p>
</blockquote>
</li>
</ul>
<h1 id="第10章-计算机网络之网络层篇"><a href="#第10章-计算机网络之网络层篇" class="headerlink" title="第10章 计算机网络之网络层篇"></a>第10章 计算机网络之网络层篇</h1><ul>
<li>什么是IP地址，IP地址有什么特征？IP地址和MAC地址有什么区别和联系？<blockquote>
<p>IP地址是唯一标记互联网中计算机的标识，IP地址共占用4个字节，使用点分十进制表示。IP地址和MAC地址都是一种标识，IP地址标记网络中的计算机，MAC地址标记网络硬件设备。</p>
</blockquote>
</li>
<li>IP报文由IP头部和IP数据两个部分组成，IP头部一般占用多少个字节？<blockquote>
<p>IP头部一般占用20个字节。</p>
</blockquote>
</li>
<li>请简述IP头部包含哪些数据？<blockquote>
</blockquote>
</li>
<li>IP头部的TTL数据有什么作用？<blockquote>
<p>TTL占用一个字节，TTL表示IP数据包在网络中的寿命，当TTL为0时，网络设备将丢弃这个报文。</p>
</blockquote>
</li>
<li>网络层是怎么界定区分一个IP报文的？<blockquote>
<p>IP协议头部有个字段为报文总长度，占用16个比特位，网络层根据这个字段划分报文。</p>
</blockquote>
</li>
<li>路由表是网络层重要的数据结构，路由表有什么作用？<blockquote>
<p>路由表存储着目的地址和下一跳地址的映射关系，路由表是网络层可以正常工作的重要数据结构。</p>
</blockquote>
</li>
<li>ARP协议有什么作用？如何清理本机的ARP缓存？<blockquote>
<p>ARP协议全称是地址解析协议，即ARP（Address Resolution Protocol）。ARP协议可以将IP地址翻译成物理地址。在Windows系统下使用arp -d命令就可以清楚arp缓存。</p>
</blockquote>
</li>
<li>ARP协议的设计有一定的缺陷，请通过搜索引擎自行搜索了解利用ARP漏洞攻击的方法。<blockquote>
</blockquote>
</li>
<li>IP地址一共4Bytes，32bits，理论上可以表示多少个IP？<blockquote>
<p>理论上可以表示2的32次方个IP。</p>
</blockquote>
</li>
<li>为了科学的使用IP地址，早期的科学家把IP地址划分为A、B、C三类IP地址，这些IP地址有什么特点？<blockquote>
<p>IP地址可以分为网络号和主机号两个部分，A类地址网络号为8位，主机号为24位；B类地址网络号为16位，主机号为16位；C类地址网络号为24位，主机号为8位。</p>
</blockquote>
</li>
<li>A类地址理论上可以有多少个子网，每个子网理论上有多少个主机号？<blockquote>
<p>A类地址网络号为8位，其首位为0，故理论上可以表示2的7次方个网络，主机号为24位，每个子网可以有2的24次方个主机</p>
</blockquote>
</li>
<li>请列举特殊的网络号和特殊的主机号。<blockquote>
<p>主机号全0、主机号全1的IP地址为特殊的主机号，不可分配。</p>
</blockquote>
</li>
<li>如何计算一个IP的网络号是什么？<blockquote>
<p>使用子网掩码和IP地址进行按位与运算就可得到IP地址对应的网络号。</p>
</blockquote>
</li>
<li>一个网络的掩码是255.255.255.248，请问这个网络可以连接多少台主机？<blockquote>
<p>这个网络的主机号只有3位，最多可以表示8个主机，减去全0、全1两个特殊主机号，一共可以连接6台主机。</p>
</blockquote>
</li>
<li>网络地址转换技术(NAT)解决了什么问题？<blockquote>
<p>NAT技术解决网络IP地址不够用的问题。</p>
</blockquote>
</li>
<li>NAT技术的实现原理。<blockquote>
<p>NAT技术在网络设备中通过维护一个映射表，通过映射表可以将外部地址转换为内部地址。</p>
</blockquote>
</li>
<li>ICMP报文和IP报文一样，也是由头部和数据两个部分组成，请简述ICMP报文的头部字段。<blockquote>
<p>ICMP报文的头部字段由三个部分组成，分别是8位类型、8位代码和16位校验和。</p>
</blockquote>
</li>
<li>ICMP报文和IP报文由什么关系？ICMP报文是怎么样传输的。<blockquote>
<p>ICMP协议和IP协议虽然同为网络层协议，但是ICMP是不能单独传输的，ICMP报文需要传输时作为IP报文的数据进行传输。</p>
</blockquote>
</li>
<li>常见的利用ICMP协议的计算机应用有ping和traceroute，请简述这两个应用的功能，以及这两个应用是怎么利用ICMP协议完成工作的。<blockquote>
</blockquote>
</li>
<li>网络层路由可以抽象成一个图算法问题，按照网络的大小可以分为内部网关协议和外部网关协议，请列举与网络路由相关的算法。<blockquote>
<p>距离矢量算法、Dijkstra（迪杰斯特拉）算法。</p>
</blockquote>
</li>
<li>请简述RIP协议的过程。<blockquote>
</blockquote>
</li>
<li>RIP协议有什么优点和缺点？<blockquote>
<p>RIP协议具备着实现简单、开销小等优点，但是RIP协议本身的缺陷限制了网络的规模，并且在RIP协议中坏消息传的慢，更新收敛时间长， 这也使得RIP协议整体性能较差。</p>
</blockquote>
</li>
<li>请简述OSPF协议的过程，OSPF协议中起到重要的算法是什么算法？<blockquote>
<p>Dijkstra（迪杰斯特拉）算法。</p>
</blockquote>
</li>
<li>OSPF协议有什么优点和缺点？<blockquote>
<p>OSPF协议解决了RIP协议的问题，对整个网络有一定的“全局观”，但是OSPF协议本身较为复杂，实现开销较大。</p>
</blockquote>
</li>
<li>网络层有了RIP协议和OSPF协议，为什么还需要BGP协议？BGP协议解决了什么问题？<blockquote>
<p>BGP协议全称为边际网关协议(Border Gateway Protocol)，BGP协议是因为计算机网络中人为因素的复杂性而提出的，在实际网络环境中，数据的传输还受政治、安全等方面的影响。</p>
</blockquote>
</li>
</ul>
<h1 id="第11章-计算机网络之传输层"><a href="#第11章-计算机网络之传输层" class="headerlink" title="第11章 计算机网络之传输层"></a>第11章 计算机网络之传输层</h1><ul>
<li>传输层主要工作在什么地方？<blockquote>
<p>传输层主要工作在终端设备（手机、计算机、笔记本、平板电脑等）上。</p>
</blockquote>
</li>
<li>传输层最重要的两个协议是什么？<blockquote>
<p>TCP协议和UDP协议。</p>
</blockquote>
</li>
<li>端口是什么，端口有什么作用？端口在协议中一般占用几个字节？<blockquote>
<p>端口是为了标记不同的使用网络的进程，端口使用16个比特为表示。</p>
</blockquote>
</li>
<li>UDP协议的中文全称是什么？UDP协议有什么特点？请分点说明。<blockquote>
<p>UDP全称是用户数据报协议(User Datagram Protocol)，UDP是一个非常简单的传输层协议，他不能保证可靠的交付数据。</p>
</blockquote>
</li>
<li>UDP的报文和IP报文一样，也是由头部和数据两个部分组成，请绘制UDP头部的结构图。<blockquote>
</blockquote>
</li>
<li>TCP协议的中文全称是什么？TCP协议有什么特点？请分点说明。<blockquote>
<p>TCP全称是传输控制协议(Transmission Control Protocol)，TCp是面向连接的协议，TCP协议可以提供可靠的数据传输服务。</p>
</blockquote>
</li>
<li>TCP的报文和UDP、IP报文一样，也是由头部和数据两个部分组成，请绘制TCP头部的结构图。<blockquote>
</blockquote>
</li>
<li>TCP报文头部的序号和确认号都占据4个字节，序号有什么用？确认号呢？<blockquote>
<p>序号用于传输数据的编号，在TCP报文中一个字节一个序号。确认号表示期待收到的数据的首字节序号。</p>
</blockquote>
</li>
<li>TCP报文头部的数据偏移字段有什么用？他和TCP报文的结构有什么关系？<blockquote>
<p>数据偏移字段表示传输数据偏移TCP首部的距离，如果TCP报文中包含可选数据，则数据偏移字段起作用。</p>
</blockquote>
</li>
<li>TCP报文头部的标记占用6个比特位，每个比特位的值可以为1或0，他们分别有什么意义？<blockquote>
<p>6个比特位分别是URG、ACK、PSH、RST、SYN、FIN，URG表示紧急报文、ACK表示确认报文、PSH表示该报文尽快交付应用层、RST表示重置报文，重新建立连接、SYN表示连接请求报文、FIN表示释放连接报文。</p>
</blockquote>
</li>
<li>TCP报文头部的窗口占用2个字节，窗口字段有什么作用？<blockquote>
<p>窗口指明允许对方发送的数据量，用于控制TCP连接中数据传输的速率。</p>
</blockquote>
</li>
<li>TCP协议一个重要的特点是可靠传输，可靠传输是怎么实现的？请简要描述可靠传输的基本原理。<blockquote>
<p>可靠传输依赖于超时重传，即接收方需要发送确认消息给发送方，如果一定时间内发送方没有收到确认消息，则认为消息没有到达接收方，重新发送数据。</p>
</blockquote>
</li>
<li>TCP协议的流量控制和TCP报文头部的什么字段有关系？流量控制具体是怎么工作的？请简要描述流量控制的主要过程。<blockquote>
<p>TCP的流量控制和TCP头部的窗口字段有关系，流量控制根据TCP报文中窗口的大小来进行数据的传输，当窗口较大时，增加数据发送速度，当窗口较小时，降低数据发送速度。</p>
</blockquote>
</li>
<li>TCP协议具备拥塞控制的功能，拥塞控制和流量控制有什么区别？拥塞控制是怎么实现的？<blockquote>
<p>拥塞控制和流量控制是不一样的，流量控制强调TCP连接双方的发送-接收速率，拥塞控制强调网络环境的状态，TCP连接的发送方可以感知网络环境的状态并做出反应。发送端使用慢启动算法、拥塞避免算法、快重传算法、快恢复方法。</p>
</blockquote>
</li>
<li>TCP协议的三次握手是非常重要的知识点，TCP协议的三次握手和TCP报文头部的哪些字段有关系？<blockquote>
<p>序号、确认号、TCP标记ACK、SYN、FIN。</p>
</blockquote>
</li>
<li>请简述TCP协议三次握手的过程。<blockquote>
</blockquote>
</li>
<li>TCP协议的三次握手是TCP建立可靠通信的基础，请问为什么TCP连接建立的过程叫做三次握手，请陈述三次握手的必要性，两次握手为什么不行？<blockquote>
<p>两次握手不能保证连接正确建立，TCP被连接的一端有可能响应失效的请求报文而无法确认。</p>
</blockquote>
</li>
<li>TCP协议的四次挥手是非常重要的知识点，TCP协议的四次挥手和TCP报文头部的哪些字段有关系？<blockquote>
<p>序号、确认号、TCP标记ACK、SYN、FIN。</p>
</blockquote>
</li>
<li>请简述TCP协议四次挥手的过程，并说明清楚每一次挥手后，双方进入的状态。<blockquote>
</blockquote>
</li>
<li>TCP连接释放的过程中有一个重要概念叫做2MSL，什么是2MSL，它有什么作用？<blockquote>
<p>MSL指的是最长报文段寿命(Max Segment Lifetime)，2MSL保证ACK报文可以正确到达对方。</p>
</blockquote>
</li>
<li>TCP协议有四个重要的定时器，分别是什么定时器？请简述这些定时器的作用。<blockquote>
<p>超时定时器、坚持定时器、时间等待计时器、保活计时器。</p>
</blockquote>
</li>
<li>什么是套接字？你了解套接字的编程吗？请使用套接字实现一个简单的C/S通信工具。<blockquote>
<p>套接字是TCP连接双方的IP:端口对</p>
</blockquote>
</li>
</ul>
<h1 id="第12章-计算机网络之应用层篇"><a href="#第12章-计算机网络之应用层篇" class="headerlink" title="第12章 计算机网络之应用层篇"></a>第12章 计算机网络之应用层篇</h1><ul>
<li>应用层相对于其他层，是面向用户的一层，应用层协议主要解决了什么问题？<blockquote>
<p>应用层是七层OSI模型的第七层。应用层直接和应用程序接口并提供常见的网络应用服务。</p>
</blockquote>
</li>
<li>请列举5个以上的应用层协议。<blockquote>
<p>HTTP、FTP、SMTP、DNS、POP3、Telnet、TFTP、DHCP等。</p>
</blockquote>
</li>
<li>什么是域名？为什么需要域名？<blockquote>
<p>域名是指由一串用点分隔的名字组成的网络上上某一台计算机或计算机组的名称。域名主要是为了解决IP地址难以记忆而发明的。</p>
</blockquote>
</li>
<li>把域名解析成IP地址的服务叫做什么服务？它有什么特点。<blockquote>
<p>把域名解析成IP地址的服务叫做DNS服务，DNS服务呈树状结构。</p>
</blockquote>
</li>
<li>DHCP协议是应用层中重要的一个协议，DHCP协议主要干了什么工作？<blockquote>
<p>DHCP（动态主机配置协议）是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。</p>
</blockquote>
</li>
<li>HTTP协议是广泛使用的一个协议，也是最重要的应用层协议之一，HTTP协议解决了什么问题？<blockquote>
<p>HTTP（超文本传输协议）是一个基于C/S架构进行通信的网络协议，HTTP协议是互联网数据通信的基础。HTTP规范了客户端请求的格式和服务端回应的格式。</p>
</blockquote>
</li>
<li>HTTP地址有什么特点，一个完整的HTTP地址由哪几个部分组成？<blockquote>
<p>HTTP协议的地址由以下几个部分组成：http(s)://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p>
</blockquote>
</li>
<li>HTTP协议中常用的HTTP请求方法有什么？他们分别表示什么意思。<blockquote>
<p>GET、POST、DELETE、UPDATE等，GET方法通常表示从服务端获取数据、POST方法通常表示往服务端提交数据、DELETE方法通常表示删除服务端资源、UPDATE方法通常表示更新服务端资源</p>
</blockquote>
</li>
<li>HTTP服务的状态码由3位十进制数组成，主要可以分成几类呢？<blockquote>
<p><img src="/2020/06/04/linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80+%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/5e3977c5095f8b7910140335.png" alt></p>
</blockquote>
</li>
<li>一个浏览器在请求服务器时，拿到了404状态码的回应，请问是什么意思？<blockquote>
<p>404状态码为客户端错误状态码，表示客户端所请求的资源不存在。</p>
</blockquote>
</li>
<li>一个浏览器在请求服务器时，拿到了502状态码的回应，请问是什么意思？<blockquote>
<p>502状态码为服务端错误状态码，表示服务端网关网络错误。</p>
</blockquote>
</li>
<li>请简述HTTP请求报文的主要结构。<blockquote>
<p>HTTP请求报文由以下几个部分组成：请求行、请求头、请求内容三个部分组成，请求行包含请求方法、请求地址和HTTP协议版本。</p>
</blockquote>
</li>
<li>请简述HTTP应答报文的主要结构。<blockquote>
<p>HTTP应答报文由以下几个部分组成：应答行、应答头、应答内容三个部分组成，应答行包含HTTP协议版本、状态码、状态说明。</p>
</blockquote>
</li>
<li>什么是缓存，什么是Web缓存？<blockquote>
<p>缓存是指比一般存储更快的存储。Web缓存是为了加快客户端访问速度而设计的缓存，主要存储Web数据，当缓存命中时，可以有效加快客户端访问速度。</p>
</blockquote>
</li>
<li>Web代理在生成环境中应用非常广泛，一般使用Nginx来完成代理，请问什么是Web代理，Web代理有什么作用？<blockquote>
<p>Nginx可以提供反向代理服务，代理指的是在客户端和服务端之间设置代理中间人，Web代理可以提供隐匿源站IP、屏蔽后端网络拓扑，负载均衡等功能。</p>
</blockquote>
</li>
<li>什么是CDN，什么是爬虫？搜索引擎的本质是什么？<blockquote>
<p>CDN全称是Content Delivery Network，即内容分发网络。爬虫指的是按照一定规则在互联网中自动抓取信息的程序，搜索引擎本质就是爬虫。</p>
</blockquote>
</li>
<li>HTTPS是安全的HTTP协议，HTTPS应用了密码学的知识，其中就包括对称加密和非对称加密，请问什么是对称加密，什么是非对称加密？<blockquote>
<p>对称加密指的是加密和解密使用同样的密钥，非对称加密指的是加密和解密使用不一样的密钥。</p>
</blockquote>
</li>
<li>SSL为现代Web应用的安全作出了重要的贡献，请简述SSL握手的主要过程。<blockquote>
</blockquote>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://phpdi.github.io/2020/05/28/go/grpc%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_20200115_173549.jpg">
      <meta itemprop="name" content="Chen Yu">
      <meta itemprop="description" content="自律给我自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="phpdi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/28/go/grpc%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">go/grpc笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-28 16:11:14" itemprop="dateCreated datePublished" datetime="2020-05-28T16:11:14+08:00">2020-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-29 09:32:42" itemprop="dateModified" datetime="2020-05-29T09:32:42+08:00">2020-05-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="grpc笔记"><a href="#grpc笔记" class="headerlink" title="grpc笔记"></a>grpc笔记</h1><h2 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h2><h3 id="protoc-语言编译工具安装"><a href="#protoc-语言编译工具安装" class="headerlink" title="protoc 语言编译工具安装"></a>protoc 语言编译工具安装</h3><p>1.下载protoc包 <a href="https://github.com/protocolbuffers/protobuf/releases/tag/v3.11.4" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/releases/tag/v3.11.4</a><br>2.解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo unzip protoc-3.11.4-linux-x86_64.zip -d &#x2F;usr&#x2F;local&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="protoc-gen-go-go语言插件安装"><a href="#protoc-gen-go-go语言插件安装" class="headerlink" title="protoc-gen-go go语言插件安装"></a>protoc-gen-go go语言插件安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com&#x2F;golang&#x2F;protobuf&#x2F;protoc-gen-go</span><br></pre></td></tr></table></figure>

<h3 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h3><p>Protobuf的protoc编译器是通过插件机制实现对不同语言的支持。比如protoc命令出现–xxx_out格式的参数，那么protoc将首先查询是否有内置的xxx插件，如果没有内置的xxx插件那么将继续查询当前系统中是否存在protoc-gen-xxx命名的可执行程序，最终通过查询到的插件生成代码。对于Go语言的protoc-gen-go插件来说，里面又实现了一层静态插件系统。比如protoc-gen-go内置了一个gRPC插件，用户可以通过–go_out=plugins=grpc参数来生成gRPC相关代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out&#x3D;plugins&#x3D;grpc:. route_guide.proto</span><br></pre></td></tr></table></figure>


<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="什么是grpc"><a href="#什么是grpc" class="headerlink" title="什么是grpc"></a>什么是grpc</h3><p>在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。<br><img src="/2020/05/28/go/grpc%E7%AC%94%E8%AE%B0/grpc_concept_diagram_00.png" alt></p>
<h3 id="使用-protocol-buffers"><a href="#使用-protocol-buffers" class="headerlink" title="使用 protocol buffers"></a>使用 protocol buffers</h3><p>gRPC 默认使用 protocol buffers，这是 Google 开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如 JSON）</p>
<h3 id="grpc服务定义"><a href="#grpc服务定义" class="headerlink" title="grpc服务定义"></a>grpc服务定义</h3><p>gRPC允许定义四类服务方法  </p>
<ul>
<li>单项 RPC，即客户端发送一个请求给服务端，从服务端获取一个应答，就像一次普通的函数调用。</li>
<li>服务端流式 RPC，即客户端发送一个请求给服务端，可获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止。</li>
<li>客户端流式 RPC，即客户端用提供的一个数据流写入并发送一系列消息给服务端。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答。</li>
<li>双向流式 RPC，即两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务端能按其希望的任意顺序读写，例如：服务端可以在写应答前等待所有的客户端消息，或者它可以先读一个消息再写一个消息，或者是读写相结合的其他方式。每个数据流里消息的顺序会被保持。</li>
</ul>
<h2 id="安全认证"><a href="#安全认证" class="headerlink" title="安全认证"></a>安全认证</h2><p>为了保障gRPC通信不被第三方监听篡改或伪造，我们可以对服务器启动TLS加密特性。  </p>
<h3 id="用以下命令为服务器和客户端分别生成私钥和证书"><a href="#用以下命令为服务器和客户端分别生成私钥和证书" class="headerlink" title="用以下命令为服务器和客户端分别生成私钥和证书"></a>用以下命令为服务器和客户端分别生成私钥和证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ openssl genrsa -out server.key 2048</span><br><span class="line">$ openssl req -new -x509 -days 3650 \</span><br><span class="line">    -subj &quot;&#x2F;C&#x3D;GB&#x2F;L&#x3D;China&#x2F;O&#x3D;grpc-server&#x2F;CN&#x3D;server.grpc.io&quot; \</span><br><span class="line">    -key server.key -out server.crt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ openssl genrsa -out client.key 2048</span><br><span class="line">$ openssl req -new -x509 -days 3650 \</span><br><span class="line">    -subj &quot;&#x2F;C&#x3D;GB&#x2F;L&#x3D;China&#x2F;O&#x3D;grpc-client&#x2F;CN&#x3D;client.grpc.io&quot; \</span><br><span class="line">    -key client.key -out client.crt</span><br></pre></td></tr></table></figure>
<p>以上命令将生成server.key、server.crt、client.key和client.crt四个文件。其中以.key为后缀名的是私钥文件，需要妥善保管。以.crt为后缀名是证书文件，也可以简单理解为公钥文件，并不需要秘密保存。在subj参数中的/CN=server.grpc.io表示服务器的名字为server.grpc.io，在验证服务器的证书时需要用到该信息。</p>
<p>有了证书之后，我们就可以在启动gRPC服务时传入证书选项参数：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    creds, err :&#x3D; credentials.NewServerTLSFromFile(&quot;server.crt&quot;, &quot;server.key&quot;)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server :&#x3D; grpc.NewServer(grpc.Creds(creds))</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中credentials.NewServerTLSFromFile函数是从文件为服务器构造证书对象，然后通过grpc.Creds(creds)函数将证书包装为选项后作为参数传入grpc.NewServer函数。</p>
<p>客户端基于服务器的证书和服务器名字就可以对服务器进行验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    creds, err :&#x3D; credentials.NewClientTLSFromFile(</span><br><span class="line">        &quot;server.crt&quot;, &quot;server.grpc.io&quot;,</span><br><span class="line">    )</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    conn, err :&#x3D; grpc.Dial(&quot;localhost:5000&quot;,</span><br><span class="line">        grpc.WithTransportCredentials(creds),</span><br><span class="line">    )</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    defer conn.Close()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中redentials.NewClientTLSFromFile是构造客户端用的证书对象，第一个参数是服务器的证书文件，第二个参数是签发证书的服务器的名字。然后通过grpc.WithTransportCredentials(creds)将证书对象转为参数选项传人grpc.Dial函数。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="http://doc.oschina.net/grpc?t=60133" target="_blank" rel="noopener">grpc文档</a></li>
<li><a href="https://chai2010.cn/advanced-go-programming-book/" target="_blank" rel="noopener">Go语言高级编程</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://phpdi.github.io/2020/05/08/go/go%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_20200115_173549.jpg">
      <meta itemprop="name" content="Chen Yu">
      <meta itemprop="description" content="自律给我自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="phpdi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/08/go/go%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">go/go高级编程笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-08 09:21:20" itemprop="dateCreated datePublished" datetime="2020-05-08T09:21:20+08:00">2020-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-05 13:52:46" itemprop="dateModified" datetime="2020-06-05T13:52:46+08:00">2020-06-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://chai2010.cn/advanced-go-programming-book/" target="_blank" rel="noopener">go语言高级编程</a></p>
<h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><h2 id="函数、方法和接口"><a href="#函数、方法和接口" class="headerlink" title="函数、方法和接口"></a>函数、方法和接口</h2><ul>
<li>init不是普通函数，可以定义有多个，所以也不能被其它函数调用</li>
<li>如果某个init函数内部用go关键字启动了新的goroutine的话，新的goroutine只有在进入main.main函数之后才可能被执行到。</li>
<li>每种类型对应的方法必须和类型的定义在同一个包中</li>
</ul>
<h2 id="面向并发的内存模型"><a href="#面向并发的内存模型" class="headerlink" title="面向并发的内存模型"></a>面向并发的内存模型</h2><ul>
<li>go基于CSP(通信顺序进程)模型实现并发,并且Goroutine之间可共享内存</li>
<li>Goroutine和系统线程不是等价的,一般系统线程占用一个固定大小的栈(2MB),Goroutine以一个大约2kb的栈启动,并且可以动态伸缩,最大可达1G的栈空间</li>
<li>Goroutine采用的是半抢占式的协作调度,只有在当前Goroutine发生阻塞时才会发生调度</li>
<li>初始化顺序 同包内(const &gt; var &gt; init),如果一个包内有多个init函数,会根据文件名顺序进行调用</li>
<li>可通过带缓存的channel,控制Goroutine的并发数量</li>
<li>顺序一致性内存模型 Go语言中，同一个Goroutine线程内部，顺序一致性内存模型是得到保证的。但是不同的Goroutine之间，并不满足顺序一致性内存模型<blockquote>
<p>如果在一个Goroutine中顺序执行a = 1; b = 2;两个语句，虽然在当前的Goroutine中可以认为a = 1;语句先于b = 2;语句执行，但是在另一个Goroutine中b = 2;语句可能会先于a = 1;语句执行，甚至在另一个Goroutine中无法看到它们的变化（可能始终在寄存器中）</p>
</blockquote>
</li>
</ul>
<h2 id="常见并发模式"><a href="#常见并发模式" class="headerlink" title="常见并发模式"></a>常见并发模式</h2><p>不要通过共享内存来通信,而应通过通信来共享内存</p>
<ul>
<li>等待N个线程完成后再进行下一步同步操作,可以使用sync.WaitGroup来实现</li>
<li>生产者消费者模型</li>
<li>发布订阅模型</li>
<li>控制并发数</li>
<li>赢者为王 通过适当开启一些冗余的线程，尝试用不同途径去解决同样的问题，最终以赢者为王的方式提升了程序的相应性能。</li>
<li>素数筛</li>
<li>并发的安全退出</li>
<li>通过Context包,实现Goroutine安全退出</li>
</ul>
<h1 id="第5章-Go和Web"><a href="#第5章-Go和Web" class="headerlink" title="第5章 Go和Web"></a>第5章 Go和Web</h1><h2 id="哪些事情适合在中间件中做"><a href="#哪些事情适合在中间件中做" class="headerlink" title="哪些事情适合在中间件中做"></a>哪些事情适合在中间件中做</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">compress.go</span><br><span class="line">  &#x3D;&gt; 对http的响应体进行压缩处理</span><br><span class="line">heartbeat.go</span><br><span class="line">  &#x3D;&gt; 设置一个特殊的路由，例如&#x2F;ping，&#x2F;healthcheck，用来给负载均衡一类的前置服务进行探活</span><br><span class="line">logger.go</span><br><span class="line">  &#x3D;&gt; 打印请求处理处理日志，例如请求处理时间，请求路由</span><br><span class="line">profiler.go</span><br><span class="line">  &#x3D;&gt; 挂载pprof需要的路由，如&#96;&#x2F;pprof&#96;、&#96;&#x2F;pprof&#x2F;trace&#96;到系统中</span><br><span class="line">realip.go</span><br><span class="line">  &#x3D;&gt; 从请求头中读取X-Forwarded-For和X-Real-IP，将http.Request中的RemoteAddr修改为得到的RealIP</span><br><span class="line">requestid.go</span><br><span class="line">  &#x3D;&gt; 为本次请求生成单独的requestid，可一路透传，用来生成分布式调用链路，也可用于在日志中串连单次请求的所有逻辑</span><br><span class="line">timeout.go</span><br><span class="line">  &#x3D;&gt; 用context.Timeout设置超时时间，并将其通过http.Request一路透传下去</span><br><span class="line">throttler.go</span><br><span class="line">  &#x3D;&gt; 通过定长大小的channel存储token，并通过这些token对接口进行限流</span><br></pre></td></tr></table></figure>

<h2 id="常见的流量限制手段"><a href="#常见的流量限制手段" class="headerlink" title="常见的流量限制手段"></a>常见的流量限制手段</h2><p>1.漏桶是指我们有一个一直装满了水的桶，每过固定的一段时间即向外漏一滴水。如果你接到了这滴水，那么你就可以继续服务请求，如果没有接到，那么就需要等待下一滴水。  </p>
<p>2.令牌桶则是指匀速向桶中添加令牌，服务请求时需要从桶中获取令牌，令牌的数目可以按照需要消耗的资源进行相应的调整。如果没有令牌，可以选择等待，或者放弃。  </p>
<p>实际应用中令牌桶应用较为广泛，开源界流行的限流器大多数都是基于令牌桶思想的。并且在此基础上进行了一定程度的扩充，比如github.com/juju/ratelimit  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://phpdi.github.io/2020/04/01/redis/%E4%B8%80%E7%AB%99%E5%BC%8F%E5%AD%A6%E4%B9%A0redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_20200115_173549.jpg">
      <meta itemprop="name" content="Chen Yu">
      <meta itemprop="description" content="自律给我自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="phpdi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/redis/%E4%B8%80%E7%AB%99%E5%BC%8F%E5%AD%A6%E4%B9%A0redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">redis/一站式学习redis从入门到高可用分布式实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 17:02:57" itemprop="dateCreated datePublished" datetime="2020-04-01T17:02:57+08:00">2020-04-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第1章到第3章"><a href="#第1章到第3章" class="headerlink" title="第1章到第3章"></a>第1章到第3章</h1><h2 id="redis-特性"><a href="#redis-特性" class="headerlink" title="redis 特性"></a>redis 特性</h2><ul>
<li>速度快</li>
<li>持久化</li>
<li>多种数据结构</li>
<li>支持多种编程语言</li>
<li>功能丰富</li>
<li>简单</li>
<li>主从复制</li>
<li>高可用,分布式</li>
</ul>
<h2 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h2><ul>
<li>keys *: 列出所有的key ,不建议线上使用</li>
<li>dbsize :统计所有的key数量</li>
<li>exists :检查某个key是否存在</li>
<li>del: 删除某个key</li>
<li>expire key seconds :key 在seconds秒后过期</li>
<li>ttl key :查询key剩余的过期时间</li>
<li>persist key:去掉key的过期时间</li>
<li>type key :返回key的类型</li>
<li>info memory: 占用内存</li>
<li>config get : 获取当前生效的配置</li>
<li>flushall :清空数据库</li>
</ul>
<h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><ul>
<li>一次只运行长慢的命令</li>
<li>拒绝长（慢）的命令</li>
</ul>
<h1 id="第4章-Redis持久化的取舍与选择"><a href="#第4章-Redis持久化的取舍与选择" class="headerlink" title="第4章 Redis持久化的取舍与选择"></a>第4章 Redis持久化的取舍与选择</h1><h2 id="持久化的作用"><a href="#持久化的作用" class="headerlink" title="持久化的作用"></a>持久化的作用</h2><h3 id="什么是持久化"><a href="#什么是持久化" class="headerlink" title="什么是持久化"></a>什么是持久化</h3><p>redis所有数据保持在内存中，对数据的更新将异步的保存到磁盘上  </p>
<h3 id="持久化的实现方式"><a href="#持久化的实现方式" class="headerlink" title="持久化的实现方式"></a>持久化的实现方式</h3><h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p>在某个时间将数据进行完全的拷贝  </p>
<ul>
<li>Mysql Dump</li>
<li>Redis RDB</li>
</ul>
<h4 id="写日志"><a href="#写日志" class="headerlink" title="写日志"></a>写日志</h4><p>记录命令日志  </p>
<ul>
<li>Mysql Binlog</li>
<li>Hbase Hlog</li>
<li>Redis AOF</li>
</ul>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><h3 id="什么是RDB"><a href="#什么是RDB" class="headerlink" title="什么是RDB"></a>什么是RDB</h3><ul>
<li>二进制文件</li>
<li>复制媒介</li>
</ul>
<h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><h4 id="主要三种触发方式"><a href="#主要三种触发方式" class="headerlink" title="主要三种触发方式"></a>主要三种触发方式</h4><h5 id="save-同步"><a href="#save-同步" class="headerlink" title="save (同步)　"></a>save (同步)　</h5><ul>
<li>命令执行过程中redis处于阻塞状态</li>
<li>文件策略，如存在老的RDB文件，新替换老</li>
<li>O(N)</li>
</ul>
<h5 id="bgsave-异步"><a href="#bgsave-异步" class="headerlink" title="bgsave (异步)"></a>bgsave (异步)</h5><ul>
<li>bgsave 命令执行的时候redis 会fork出一个子进程，由这个子进程去执行RDB文件的生成</li>
</ul>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">save</th>
<th align="left">bgsave</th>
</tr>
</thead>
<tbody><tr>
<td align="left">IO类型</td>
<td align="left">同步</td>
<td align="left">异步</td>
</tr>
<tr>
<td align="left">阻塞</td>
<td align="left">是</td>
<td align="left">是（阻塞发生在fork）,fork的过程很快</td>
</tr>
<tr>
<td align="left">复杂度</td>
<td align="left">O(n)</td>
<td align="left">O(n)</td>
</tr>
<tr>
<td align="left">优点</td>
<td align="left">不会消耗额外内存</td>
<td align="left">不阻塞客户端命令</td>
</tr>
<tr>
<td align="left">缺点</td>
<td align="left">阻塞客户端命令</td>
<td align="left">需要fork,消耗内存</td>
</tr>
</tbody></table>
<h5 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h5><table>
<thead>
<tr>
<th align="left">配置</th>
<th align="left">seconds</th>
<th align="left">changes</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">save</td>
<td align="left">900</td>
<td align="left">1</td>
<td align="left">900秒内发生1次数据变动，执行bgsave</td>
</tr>
<tr>
<td align="left">save</td>
<td align="left">300</td>
<td align="left">10</td>
<td align="left">300秒内发生10次数据变动，执行bgsave</td>
</tr>
<tr>
<td align="left">save</td>
<td align="left">60</td>
<td align="left">10000</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">以上条件满足任一条件都会执行bgsave</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>1.redis默认配置文件 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir .&#x2F;</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure>
<p>2.redis推荐配置  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dbfilename dump-$&#123;port&#125;.rdb</span><br><span class="line">dir &#x2F;bigdiskpath </span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure>

<h4 id="不容忽视的方式"><a href="#不容忽视的方式" class="headerlink" title="不容忽视的方式"></a>不容忽视的方式</h4><ul>
<li>全量复制</li>
<li>debug reload</li>
<li>shutdown </li>
</ul>
<h3 id="RDB-总结"><a href="#RDB-总结" class="headerlink" title="RDB 总结"></a>RDB 总结</h3><ul>
<li>RDB是Redis内存到硬盘的快照，用于持久化</li>
<li>save通常会阻塞redis</li>
<li>bgsave不会阻塞redis,但会fork新进程</li>
<li>save自动配置满足任一就会被执行</li>
<li>有些触发机制不容忽视</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><h3 id="RDB的问题"><a href="#RDB的问题" class="headerlink" title="RDB的问题"></a>RDB的问题</h3><ul>
<li>耗时、耗性能</li>
<li>不可控、容易丢失数据</li>
</ul>
<h3 id="什么是AOF"><a href="#什么是AOF" class="headerlink" title="什么是AOF"></a>什么是AOF</h3><p>日志原理，每执行一条命令，都会写入到aof文件中<br>具体过程：  </p>
<ol>
<li>写命令刷新到缓冲区</li>
<li>缓冲区的命令会根据一定的策略fsync到硬盘的AOF文件中    </li>
</ol>
<h3 id="AOF三种策略"><a href="#AOF三种策略" class="headerlink" title="AOF三种策略"></a>AOF三种策略</h3><ul>
<li>always : 每执行一条命令就会执行fsync</li>
<li>everysec （默认值）: 每秒写入到硬盘中</li>
<li>no : 根据操作系统的策略决定的<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">always</th>
<th align="left">everysec</th>
<th align="left">no</th>
</tr>
</thead>
<tbody><tr>
<td align="left">优点</td>
<td align="left">不丢失数据</td>
<td align="left">每秒一次fsync丢1秒数据</td>
<td align="left">不用管</td>
</tr>
<tr>
<td align="left">缺点</td>
<td align="left">IO开销大一般的sata盘只有几百TPS</td>
<td align="left">丢1秒数据</td>
<td align="left">不可控</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><h4 id="为什么要进行AOF重写"><a href="#为什么要进行AOF重写" class="headerlink" title="为什么要进行AOF重写"></a>为什么要进行AOF重写</h4><p>把过期的、没有用的、重复的、 以及一些可以优化的命令进行化简</p>
<ul>
<li>减少磁盘的占用量</li>
<li>加速恢复速度</li>
</ul>
<h4 id="AOF重写实现的两种方式"><a href="#AOF重写实现的两种方式" class="headerlink" title="AOF重写实现的两种方式"></a>AOF重写实现的两种方式</h4><h5 id="bgrewriteaof"><a href="#bgrewriteaof" class="headerlink" title="bgrewriteaof"></a>bgrewriteaof</h5><h5 id="AOF重写配置"><a href="#AOF重写配置" class="headerlink" title="AOF重写配置"></a>AOF重写配置</h5><table>
<thead>
<tr>
<th align="left">配置名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">auto-aof-rewrite-min-size</td>
<td align="left">AOF文件重写需要的尺寸</td>
</tr>
<tr>
<td align="left">auto-aof-rewrite-percentage</td>
<td align="left">AOF文件增长率（(aof_current_size-aof_base_size)/aof_base_size）</td>
</tr>
</tbody></table>
<p>以上两个条件同时满足才会触发aof自动重写</p>
<table>
<thead>
<tr>
<th align="left">统计名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">aof_current_size</td>
<td align="left">AOF当前尺寸（单位：字节）</td>
</tr>
<tr>
<td align="left">aof_base_size</td>
<td align="left">AOF上次启动和重写的尺寸（单位：字节）</td>
</tr>
</tbody></table>
<h3 id="AOF-配置"><a href="#AOF-配置" class="headerlink" title="AOF 配置"></a>AOF 配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly-$&#123;port&#125;.aof&quot;</span><br><span class="line">appendfsync everysec</span><br><span class="line">dir &#x2F;bigdiskpath</span><br><span class="line">no-appendfsync-on-rewrite yes  # 在进行aof重写的时候，不进行aof操作</span><br><span class="line">auto-aof-rewrite-min-size 100</span><br><span class="line">auto-aof-rewrite-percentage 64mb</span><br></pre></td></tr></table></figure>

<h2 id="RDB和AOF的选择"><a href="#RDB和AOF的选择" class="headerlink" title="RDB和AOF的选择"></a>RDB和AOF的选择</h2><h3 id="RDB与AOF比较"><a href="#RDB与AOF比较" class="headerlink" title="RDB与AOF比较"></a>RDB与AOF比较</h3><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">RDB</th>
<th align="left">AOF</th>
</tr>
</thead>
<tbody><tr>
<td align="left">启动优先级</td>
<td align="left">低</td>
<td align="left">高</td>
</tr>
<tr>
<td align="left">体积</td>
<td align="left">小</td>
<td align="left">大</td>
</tr>
<tr>
<td align="left">恢复速度</td>
<td align="left">块</td>
<td align="left">慢</td>
</tr>
<tr>
<td align="left">数据安全</td>
<td align="left">丢数据</td>
<td align="left">根据策略决定</td>
</tr>
<tr>
<td align="left">轻重</td>
<td align="left">重</td>
<td align="left">轻</td>
</tr>
</tbody></table>
<h3 id="RDB最佳策略"><a href="#RDB最佳策略" class="headerlink" title="RDB最佳策略"></a>RDB最佳策略</h3><ul>
<li><p>“关”<br>在主从进行全量复制的时候会生成RDB文件，所以关是关不绝对的</p>
</li>
<li><p>集中管理<br>在固定的时间点进行备份的时候可以用</p>
</li>
<li><p>主、从<br>一定要开的情况下建议主关，从开</p>
</li>
</ul>
<h3 id="AOF最佳策略"><a href="#AOF最佳策略" class="headerlink" title="AOF最佳策略"></a>AOF最佳策略</h3><ul>
<li><p>开<br>redis作为存储的时候建议开启<br>redis作为缓存的时候可以不开启</p>
</li>
<li><p>AOF重写集中管理<br>避免单机多部署的时候aof重写集中发生，占满内存</p>
</li>
<li><p>aof重写策略推荐everysec<br>只会丢失1s的数据，不会频繁将buffer中的数据fsync到硬盘</p>
</li>
</ul>
<h3 id="最佳策略"><a href="#最佳策略" class="headerlink" title="最佳策略"></a>最佳策略</h3><ul>
<li>小分片</li>
<li>缓存或存储</li>
<li>监控（硬盘、内存、负载、网络）</li>
<li>足够的内存</li>
</ul>
<h1 id="第5章-常见持久化开发运维问题"><a href="#第5章-常见持久化开发运维问题" class="headerlink" title="第5章 常见持久化开发运维问题"></a>第5章 常见持久化开发运维问题</h1><h2 id="fork操作"><a href="#fork操作" class="headerlink" title="fork操作"></a>fork操作</h2><ul>
<li>同步操作</li>
<li>与内存量息息相关：内存越大、耗时越长（与机器类型有关）</li>
<li>info:last_fork_usec</li>
</ul>
<h3 id="改善fork"><a href="#改善fork" class="headerlink" title="改善fork"></a>改善fork</h3><ul>
<li>优先使用物理机或者高效支持fork操作的虚拟化技术</li>
<li>控制Redis实例最大可用内存：maxmemory</li>
<li>合理配置Linux内存分配策略：vm.overcommit_memory=1</li>
<li>降低fork频率：例如放宽AOF重写自动触发机制，不必要的全量复制</li>
</ul>
<h2 id="进程外开销"><a href="#进程外开销" class="headerlink" title="进程外开销"></a>进程外开销</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul>
<li>开销 RDB和AOF文件生成，属于CPU密集型</li>
<li>优化 不做CPU绑定，不和CPU密集型部署</li>
</ul>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><ul>
<li>开销 fork内存开销，copy-on-write</li>
<li>优化 echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</li>
</ul>
<h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><ul>
<li>开销： AOF和RDB文件写入，可以结合iostat,iotop分析</li>
<li>优化<br>不要和高硬盘负载服务器部署一起，存储服务、消息队列等<br>no-appendfsync-on-rewrite=yes<br>根据写入量决定磁盘类型 例如ssd<br>单机多实例持久化文件目录可以考虑分盘</li>
</ul>
<h2 id="AOF追加阻塞"><a href="#AOF追加阻塞" class="headerlink" title="AOF追加阻塞"></a>AOF追加阻塞</h2><h2 id="单机多部署实例"><a href="#单机多部署实例" class="headerlink" title="单机多部署实例"></a>单机多部署实例</h2><h1 id="第6章-Redis主从复制原理以及优化"><a href="#第6章-Redis主从复制原理以及优化" class="headerlink" title="第6章 Redis主从复制原理以及优化"></a>第6章 Redis主从复制原理以及优化</h1><h2 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h2><h3 id="单机有什么问题？"><a href="#单机有什么问题？" class="headerlink" title="单机有什么问题？"></a>单机有什么问题？</h3><ul>
<li>机器故障</li>
<li>容量瓶颈</li>
<li>QPS瓶颈 </li>
</ul>
<h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><ul>
<li>数据副本</li>
<li>扩展读性能</li>
</ul>
<h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><ul>
<li>一个master可以有多个slave</li>
<li>一个slave只能有一个master</li>
<li>数据流向是单向的，master到slave</li>
</ul>
<h2 id="复制的配置"><a href="#复制的配置" class="headerlink" title="复制的配置"></a>复制的配置</h2><h3 id="replicaof-命令"><a href="#replicaof-命令" class="headerlink" title="replicaof 命令"></a>replicaof 命令</h3><ul>
<li>replicaof 127.0.0.1 6379 </li>
<li>replicaof no one<blockquote>
<p>任何一个节点成为从节点的时候，都会将自身节点的数据进行清除</p>
</blockquote>
</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replicaof ip port</span><br><span class="line">replica-read-only yes</span><br></pre></td></tr></table></figure>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><table>
<thead>
<tr>
<th align="left">方式</th>
<th align="left">命令</th>
<th align="left">配置</th>
</tr>
</thead>
<tbody><tr>
<td align="left">优点</td>
<td align="left">无需重启</td>
<td align="left">统一配置</td>
</tr>
<tr>
<td align="left">缺点</td>
<td align="left">不便于管理</td>
<td align="left">需要重启</td>
</tr>
</tbody></table>
<h2 id="全量复制和部分复制"><a href="#全量复制和部分复制" class="headerlink" title="全量复制和部分复制"></a>全量复制和部分复制</h2><h3 id="全量复制过程"><a href="#全量复制过程" class="headerlink" title="全量复制过程"></a>全量复制过程</h3><ol>
<li>slave: psync ? -1</li>
<li>master: FULLRESYNC {runId} {offset}</li>
<li>slave: save masterInfo</li>
<li>master: 执行bgsave 生成rdb文件,send RDB to slave</li>
<li>master: send buffer </li>
<li>slave: flush old data</li>
<li>slave: load RDB</li>
</ol>
<h3 id="全量复制开销"><a href="#全量复制开销" class="headerlink" title="全量复制开销"></a>全量复制开销</h3><ol>
<li>bgsave时间</li>
<li>RDB文件网络传输</li>
<li>从节点清空数据时间</li>
<li>从节点加载RDB时间</li>
<li>可能的AOF重写时间</li>
</ol>
<h3 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h3><p>部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施；<br>如果出现网络闪断或者命令丢失等异常情况时，从节点会向主节点要求补发丢失的命令数据，如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点</p>
<h2 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h2><h3 id="slave-故障"><a href="#slave-故障" class="headerlink" title="slave 故障"></a>slave 故障</h3><h3 id="master-故障"><a href="#master-故障" class="headerlink" title="master 故障"></a>master 故障</h3><h2 id="开发运维常见问题"><a href="#开发运维常见问题" class="headerlink" title="开发运维常见问题"></a>开发运维常见问题</h2><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><ol>
<li>读流量分摊到节点</li>
<li>可能遇到的问题  </li>
</ol>
<ul>
<li>复制数据延迟</li>
<li>读到过期的数据</li>
<li>从节点故障</li>
</ul>
<h3 id="配置不一致"><a href="#配置不一致" class="headerlink" title="配置不一致"></a>配置不一致</h3><ol>
<li>例如maxmemory不一致：丢失数据<h3 id="主从配置不一致"><a href="#主从配置不一致" class="headerlink" title="主从配置不一致"></a>主从配置不一致</h3><h3 id="规避全量复制"><a href="#规避全量复制" class="headerlink" title="规避全量复制"></a>规避全量复制</h3></li>
<li>第一次全量复制  </li>
</ol>
<ul>
<li>第一次不可避免</li>
<li>小主节点、低峰</li>
</ul>
<ol start="2">
<li>节点运行ID不匹配</li>
</ol>
<ul>
<li>主节点重启（运行ID变化）</li>
<li>故障转移，列如哨兵或集群</li>
</ul>
<ol start="3">
<li>复制积压缓冲区不足</li>
</ol>
<ul>
<li>网络中断，部分复制无法满足</li>
<li>增大复制缓冲区配置rel_backlog_size, 网络“增强”，默认为1M,可以配置成10M</li>
</ul>
<h3 id="规避复制风暴"><a href="#规避复制风暴" class="headerlink" title="规避复制风暴"></a>规避复制风暴</h3><ol>
<li>单节点复制风暴  </li>
</ol>
<ul>
<li>问题： 主节点重启，多从节点复制</li>
<li>解决： 更换复制拓扑</li>
</ul>
<ol start="2">
<li>单机器复制风暴</li>
</ol>
<ul>
<li>机器宕机后，大量全量复制</li>
<li>主节点分散多机器</li>
</ul>
<h1 id="第7章-Redis-sentine-哨兵"><a href="#第7章-Redis-sentine-哨兵" class="headerlink" title="第7章 Redis sentine (哨兵)"></a>第7章 Redis sentine (哨兵)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis Sentinel为Redis提供了很高的可用性，在实践中，这意味着你可以部署一个可以解决非人为干预导致节点故障的Redis集群系统。Redis Sentinel还提供了其他的功能：如监控，通知和客户端配置服务的提供方。下面列出来了Redis Sentinel的功能列表：  </p>
<ul>
<li>监控：Sentinel能够监控master节点或slave节点是否处于按照预期工作的状态。</li>
<li>通知：Sentinel能够通过api通知系统管理原，其他的计算机程序，Redis实例运行过程中发生了错误。</li>
<li>自动故障转移：如果Redis的master节点出现问题，Sentinel能够启动一个故障转移处理，该处理会将一个slave节点提升为master节点，其他的slave节点则会自动配置成新的master节点的slave节点，如果原来的master重新正常启动后，也会成为该新Master的slave节点。</li>
<li>客户端配置提供者：Sentinel可作为客户端服务发现的一个权威来源，客户端通过连接到Sentinel来请求当前的Redis Master节点，如果Master节点发生故障，Sentinel将会提供新的master地址。</li>
</ul>
<p>Redis Sentinel 是一个分布式系统， 你可以在架构中运行多个 Sentinel 进程，这些进程通过相互通讯来判断一个主服务器是否断线，以及是否应该执行故障转移。<br>在配置Redis Sentinel时，至少需要有1个Master和1个Slave。当Master失效后,Redis Sentinel会报出失效警告，并使用投票协议（agreement protocols）<br>来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器，并提供读写服务;当失效的Master恢复后，Redis Sentinel会自动识别，<br>将Master自动转换为Slave并完成数据同步。通过Redis Sentinel可以实现Redis零手工干预并且短时间内进行M-S切换，减少业务影响时间。  </p>
<p>虽然 Redis Sentinel 释出为一个单独的可执行文件 redis-sentinel ， 但实际上它只是一个运行在特殊模式下的 Redis 服务器， 你可以在启动一个普通 Redis 服务器时通过给定 –sentinel 选项来启动 Redis Sentinel。</p>
<h2 id="主从复制高可用的问题"><a href="#主从复制高可用的问题" class="headerlink" title="主从复制高可用的问题"></a>主从复制高可用的问题</h2><ul>
<li>手动故障转移</li>
<li>写能力和存储能力受限</li>
</ul>
<h2 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h2><p>sentinel 主要作用是监控、故障转移、通知<br>一个sentinel可以监控多套master,slave</p>
<h3 id="Redis-Sentinel故障转移"><a href="#Redis-Sentinel故障转移" class="headerlink" title="Redis Sentinel故障转移"></a>Redis Sentinel故障转移</h3><ol>
<li>多个sentinel发现并确认master有问题</li>
<li>选举出一个sentinel作为领导</li>
<li>选出一个slave作为master</li>
<li>通知其余slave成为新的master的slave</li>
<li>通知客户端主从变化</li>
</ol>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p>sentinel默认监听节点是26379</p>
<ol>
<li>配置开启主从节点</li>
<li>配置开启sentinel监控节点（sentinel是特殊的redis）</li>
<li>实际应该是多台机器</li>
<li>详细配置节点</li>
</ol>
<h3 id="redis-master节点配置"><a href="#redis-master节点配置" class="headerlink" title="redis master节点配置"></a>redis master节点配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis-7000.pid</span><br><span class="line">logfile &quot;7000.log&quot;</span><br><span class="line">dir &quot;&#x2F;data&quot;</span><br></pre></td></tr></table></figure>
<h3 id="redis-slave1节点配置"><a href="#redis-slave1节点配置" class="headerlink" title="redis slave1节点配置"></a>redis slave1节点配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7001</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis-7001.pid</span><br><span class="line">logfile &quot;7001.log&quot;</span><br><span class="line">dir &quot;&#x2F;data&quot;</span><br><span class="line">replicaof 127.0.0.1 7000</span><br></pre></td></tr></table></figure>

<h3 id="redis-sentinel主要配置"><a href="#redis-sentinel主要配置" class="headerlink" title="redis sentinel主要配置"></a>redis sentinel主要配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port $&#123;port&#125;</span><br><span class="line">dir &quot;&#x2F;data&quot;</span><br><span class="line">logfile &quot;$&#123;port&#125;.log&quot;</span><br><span class="line"># 设置判定mymaster 失效的monitor 个数 </span><br><span class="line">sentinel monitor mymaster 127.0.0.1 7000 2 </span><br><span class="line">sentinel down-after-millseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure>
<h2 id="sentinel中的3个定时任务"><a href="#sentinel中的3个定时任务" class="headerlink" title="sentinel中的3个定时任务"></a>sentinel中的3个定时任务</h2><h3 id="每10秒每个sentinel对master和slave-执行info"><a href="#每10秒每个sentinel对master和slave-执行info" class="headerlink" title="每10秒每个sentinel对master和slave 执行info"></a>每10秒每个sentinel对master和slave 执行info</h3><ul>
<li>发现slave节点</li>
<li>确认主从关系<h3 id="每两秒每个sentinel通过master节点的channel交换信息（pub-sub）"><a href="#每两秒每个sentinel通过master节点的channel交换信息（pub-sub）" class="headerlink" title="每两秒每个sentinel通过master节点的channel交换信息（pub/sub）"></a>每两秒每个sentinel通过master节点的channel交换信息（pub/sub）</h3></li>
<li>通过 <em>sentinel</em>:hello 频道交换信息</li>
<li>交换对节点的“看法”和自身信息</li>
</ul>
<h3 id="每1秒每个sentinel对其他sentinel和redis进ping"><a href="#每1秒每个sentinel对其他sentinel和redis进ping" class="headerlink" title="每1秒每个sentinel对其他sentinel和redis进ping"></a>每1秒每个sentinel对其他sentinel和redis进ping</h3><ul>
<li>心跳检测，失败判定依据</li>
</ul>
<h2 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h2><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h2 id="常见开发运维问题"><a href="#常见开发运维问题" class="headerlink" title="常见开发运维问题"></a>常见开发运维问题</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Redis Sentinel 的Sentinel节点数应该大于等于3且最好为奇数</li>
<li>Redis Sentinel 中的数据节点与普通数据节点没有区别</li>
<li>客户端初始化时连接的是Sentinel节点集合，不再是具体的Redis节点，但Sentinel只是配置中心而不是代理</li>
<li>Redis Sentinel 通过三个定时任务实现了Sentinel节点对于主节点、从节点、其余Sentinel节点的监控</li>
<li>Redis Sentinel 在对节点做失败判定时分为主观下线和客观下线</li>
<li>看懂Redis Sentinel 故障转移日志对于Redis Sentinel以及排查问题非常有帮助</li>
<li>Redis Sentinel 实现读写分离高可用可以依赖Sentinel节点的消息通知，获取Redis数据节点的状态变化</li>
</ul>
<h1 id="第8章-Redis-Cluster"><a href="#第8章-Redis-Cluster" class="headerlink" title="第8章 Redis Cluster"></a>第8章 Redis Cluster</h1><h2 id="数据分布概论"><a href="#数据分布概论" class="headerlink" title="数据分布概论"></a>数据分布概论</h2><h3 id="数据分布对比"><a href="#数据分布对比" class="headerlink" title="数据分布对比"></a>数据分布对比</h3><table>
<thead>
<tr>
<th align="left">分布方式</th>
<th align="left">特点</th>
<th align="left">典型产品</th>
</tr>
</thead>
<tbody><tr>
<td align="left">哈希分布</td>
<td align="left">数据分散度高键值分布业务无关，无法顺序访问，支持批量操作</td>
<td align="left">一致性哈希Memcache,Redis cluster,其他缓存产品</td>
</tr>
<tr>
<td align="left">顺序分布</td>
<td align="left">数据分散度易倾斜，键值业务相关，可顺序访问，支持批量操作</td>
<td align="left">BigTable HBase</td>
</tr>
</tbody></table>
<h3 id="哈希分布方式"><a href="#哈希分布方式" class="headerlink" title="哈希分布方式"></a>哈希分布方式</h3><h4 id="节点取余分区"><a href="#节点取余分区" class="headerlink" title="节点取余分区"></a>节点取余分区</h4><ul>
<li>客户端分片：哈希+取余</li>
<li>节点伸缩： 数据节点变化，导致数据迁移</li>
<li>迁移数量和添加节点数量有关：建议翻倍扩容<h4 id="一致性哈希分区"><a href="#一致性哈希分区" class="headerlink" title="一致性哈希分区"></a>一致性哈希分区</h4></li>
<li>客户端分片：哈希+顺时针（优化取余）</li>
<li>节点伸缩： 只影响临近节点，但是还是有数据迁移</li>
<li>翻倍伸缩： 保证最小迁移数据和负载均衡</li>
</ul>
<h4 id="虚拟槽分区"><a href="#虚拟槽分区" class="headerlink" title="虚拟槽分区"></a>虚拟槽分区</h4><ul>
<li>预设虚拟槽：每个槽映射一个数据子集，一般比节点数大</li>
<li>良好的哈希函数：例如CRC16</li>
<li>服务端管理节点、槽、数据 例如：Redis Cluster</li>
</ul>
<h2 id="Cluster节点主要配置"><a href="#Cluster节点主要配置" class="headerlink" title="Cluster节点主要配置"></a>Cluster节点主要配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cluster-enabled yes</span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line">cluster-config-file &quot;nodes.conf&quot;</span><br><span class="line">cluster-require-full-coverage yes</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://phpdi.github.io/2020/04/01/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_20200115_173549.jpg">
      <meta itemprop="name" content="Chen Yu">
      <meta itemprop="description" content="自律给我自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="phpdi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">linux/常用命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 17:02:57" itemprop="dateCreated datePublished" datetime="2020-04-01T17:02:57+08:00">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-20 17:35:41" itemprop="dateModified" datetime="2020-07-20T17:35:41+08:00">2020-07-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h1><ul>
<li>cat mysql.conf | grep -v “#” | grep -v “^$” 查看未被注释掉的行 </li>
</ul>
<h1 id="生成随机密码"><a href="#生成随机密码" class="headerlink" title="生成随机密码"></a>生成随机密码</h1><p>date +%s |sha256sum |base64 |head -c 10 ;echo</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://phpdi.github.io/2020/04/01/linux/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_20200115_173549.jpg">
      <meta itemprop="name" content="Chen Yu">
      <meta itemprop="description" content="自律给我自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="phpdi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/linux/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/" class="post-title-link" itemprop="url">linux/疑难杂症</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 17:02:57" itemprop="dateCreated datePublished" datetime="2020-04-01T17:02:57+08:00">2020-04-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ubuntu中解决机箱前置耳机没声音"><a href="#ubuntu中解决机箱前置耳机没声音" class="headerlink" title="ubuntu中解决机箱前置耳机没声音"></a>ubuntu中解决机箱前置耳机没声音</h2><p>1.安装pavucontrol软件：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install pavucontrol</span><br></pre></td></tr></table></figure><br>2.选择配置-》模拟立体声双工</p>
<p>3.输出设备-》模拟耳机</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/04/01/linux/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://phpdi.github.io/2020/04/01/linux/ubuntu%20%E5%AE%89%E8%A3%85%E5%90%84%E7%A7%8D%E8%BD%AF%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_20200115_173549.jpg">
      <meta itemprop="name" content="Chen Yu">
      <meta itemprop="description" content="自律给我自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="phpdi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/linux/ubuntu%20%E5%AE%89%E8%A3%85%E5%90%84%E7%A7%8D%E8%BD%AF%E4%BB%B6/" class="post-title-link" itemprop="url">linux/ubuntu 安装各种软件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 17:02:57" itemprop="dateCreated datePublished" datetime="2020-04-01T17:02:57+08:00">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-27 10:51:10" itemprop="dateModified" datetime="2020-05-27T10:51:10+08:00">2020-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h3><h4 id="deb包"><a href="#deb包" class="headerlink" title="deb包"></a>deb包</h4><p><a href="http://www.ubuntuchrome.com/" target="_blank" rel="noopener">http://www.ubuntuchrome.com/</a></p>
<h4 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https://repo.fdzh.org/chrome/google-chrome.list -P /etc/apt/sources.list.d/ &amp;&amp;</span><br><span class="line">wget -q -O - https://dl.google.com/linux/linux_signing_key.pub  | sudo apt-key add - &amp;&amp;</span><br><span class="line">sudo apt-get update &amp;&amp;</span><br><span class="line">sudo apt-get install google-chrome-stable</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/04/01/linux/ubuntu%20%E5%AE%89%E8%A3%85%E5%90%84%E7%A7%8D%E8%BD%AF%E4%BB%B6/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chen Yu"
      src="/images/IMG_20200115_173549.jpg">
  <p class="site-author-name" itemprop="name">Chen Yu</p>
  <div class="site-description" itemprop="description">自律给我自由</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Yu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
